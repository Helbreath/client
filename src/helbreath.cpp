//
// Copyright (c) Sharon Fox (sharon at sharonfox dot dev)
//
// Distributed under the MIT License. (See accompanying file LICENSE)
//

#include "helbreath.h"
#include "buffer.h"
#include <algorithm>
#include <iostream>

#include "lan_eng.h"
#include <fmt/format.h>
#include <SFML/Window/ContextSettings.hpp>

#include <ixwebsocket/IXNetSystem.h>
#include <ixwebsocket/IXWebSocket.h>
#include <ixwebsocket/IXUserAgent.h>

extern helbreath * game;

extern bool isrunning;

extern char G_cSpriteAlphaDegree;

char _cDrawingOrder[] = { 0, 1, 0, 0, 0, 0, 0, 1, 1 };
char _cMantleDrawingOrder[] = { 0, 1, 1, 1, 0, 0, 0, 2, 2 };
char _cMantleDrawingOrderOnRun[] = { 0, 1, 1, 1, 1, 1, 1, 1, 1 };

short _tmp_sOwnerType, _tmp_sAppr1, _tmp_sAppr2, _tmp_sAppr3, _tmp_sAppr4;
int _tmp_iStatus;
short _tmp_sHeadApprValue, _tmp_sBodyApprValue, _tmp_sArmApprValue, _tmp_sLegApprValue;
char _tmp_cAction, _tmp_cDir, _tmp_cFrame, _tmp_cName[12];
int _tmp_iChatIndex, _tmp_dx, _tmp_dy, _tmp_iApprColor, _tmp_iEffectType, _tmp_iEffectFrame, _tmp_dX, _tmp_dY;
uint16_t _tmp_wObjectID;
char cDynamicObjectData1, cDynamicObjectData2, cDynamicObjectData3, cDynamicObjectData4;
uint16_t wFocusObjectID;
short sFocus_dX, sFocus_dY;
char cFocusAction, cFocusFrame, cFocusDir, cFocusName[12];
short sFocusX, sFocusY, sFocusOwnerType, sFocusAppr1, sFocusAppr2, sFocusAppr3, sFocusAppr4;
int iFocuiStatus;
int iFocusApprColor;
short sFocusHeadApprValue, sFocusBodyApprValue, sFocusArmApprValue, sFocusLegApprValue;

std::unordered_map<uint8_t, const char *> g_socketMap;

uint64_t unixtime()
{
	int64_t time = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
#ifdef WIN32
	struct __timeb64 tstruct;
	_ftime64_s(&tstruct);
#else
	struct timeb tstruct;
	ftime(&tstruct);
#endif
	return tstruct.millitm + tstruct.time * 1000;
}

uint32_t unixseconds()
{
#ifdef WIN32
	struct __timeb64 tstruct;
	_ftime64_s(&tstruct);
#else
	struct timeb tstruct;
	ftime(&tstruct);
#endif
	return tstruct.time;
}

void helbreath::ReadSettings()
{
	m_sMagicShortCut = -1;
	m_sRecentShortCut = -1;
	for (short & i : m_sShortCut)
		i = -1;

	uint32_t val;
	if ((val = ReadSettingsVar("ShowFPS")) == -1)
		m_bShowFPS = false;
	else
		m_bShowFPS = val;

	if ((val = ReadSettingsVar("ShowTime")) == -1)
		m_bShowFPS = false;
	else
		m_bShowFPS = val;

	if ((val = ReadSettingsVar("ShowGrid")) == -1)
		m_showGrid = false;
	else
		m_showGrid = val;

	if ((val = ReadSettingsVar("ShowAllDmg")) == -1)
		m_showAllDmg = true;
	else
		m_showAllDmg = val;

	if ((val = ReadSettingsVar("BigItems")) == -1)
		m_bigItems = false;
	else
		m_bigItems = val;

	if ((val = ReadSettingsVar("PartyAutoAccept")) == -1)
		m_partyAutoAccept = false;
	else
		m_partyAutoAccept = val;

	if ((val = ReadSettingsVar("DetailLevel")) == -1)
		m_cDetailLevel = false;
	else
		m_cDetailLevel = val;

	if ((val = ReadSettingsVar("Music")) == -1)
		m_bMusicStat = true;
	else
		m_bMusicStat = val;

	if ((val = ReadSettingsVar("Sound")) == -1)
		m_bSoundStat = true;
	else
		m_bSoundStat = val;

	if ((val = ReadSettingsVar("EKScreenshot")) == -1)
		m_ekScreenshot = false;
	else
		m_ekScreenshot = val;

	if ((val = ReadSettingsVar("TabbedNotification")) == -1)
		m_tabbedNotification = false;
	else
		m_tabbedNotification = val;

	if ((val = ReadSettingsVar("ManuAutoFill")) == -1)
		m_manuAutoFill = false;
	else
		m_manuAutoFill = val;

	if ((val = ReadSettingsVar("TimeStamp")) == -1)
		m_showTimeStamp = false;
	else
		m_showTimeStamp = val;

	if ((val = ReadSettingsVar("WindowsKey")) == -1)
		m_windowsKey = true;
	else
		m_windowsKey = val;

	if ((val = ReadSettingsVar("ShowQuest")) == -1)
		m_displayQuest = false;
	else
		m_displayQuest = val;

	if ((val = ReadSettingsVar("Remember")) == -1)
		b_cRemember = false;
	else
		b_cRemember = val;

	uint32_t ret;
	ret = ReadSettingsVar("Magic");

	if (ret > 0 && ret < 101)
		m_sMagicShortCut = ret - 1;
	else
		m_sMagicShortCut = -1;

	ret = ReadSettingsVar("ShortCut0");

	if (ret > 0 && ret < 201)
		m_sShortCut[0] = ret - 1;
	else
		m_sShortCut[0] = -1;

	ret = ReadSettingsVar("ShortCut1");

	if (ret > 0 && ret < 201)
		m_sShortCut[1] = ret - 1;
	else
		m_sShortCut[1] = -1;

	ret = ReadSettingsVar("ShortCut2");

	if (ret > 0 && ret < 201)
		m_sShortCut[2] = ret - 1;
	else
		m_sShortCut[2] = -1;

	ret = ReadSettingsVar("ShortCut3");

	if (ret > 0 && ret < 201)
		m_sShortCut[3] = ret - 1;
	else
		m_sShortCut[3] = -1;

	ret = ReadSettingsVar("ShortCut4");

	if (ret > 0 && ret < 201)
		m_sShortCut[4] = ret - 1;
	else
		m_sShortCut[4] = -1;
}

uint32_t helbreath::ReadSettingsVar(const char * var)
{
	// 	HKEY key;
	// 	unsigned long dwDisp;
	//
	// 	unsigned long val;
	// 	unsigned long size = sizeof(unsigned long);
	// 	if( RegCreateKeyExA( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, 0,
	// 		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 0, &key, &dwDisp ) != ERROR_SUCCESS )
	// 		return -1;
	//
	// 	if( RegQueryValueExA(key, var, 0, 0, (LPBYTE)&val, &size) != ERROR_SUCCESS )
	// 	{
	// 		RegCloseKey(key);
	// 		return -1;
	// 	}
	//
	// 	RegCloseKey(key);
	// 	return val;
	return 0;
}

void helbreath::WriteSettings()
{
	WriteSettingsVar("ShowFPS", m_bShowFPS);
	WriteSettingsVar("ShowTime", m_showTime);
	WriteSettingsVar("ShowGrid", m_showGrid);
	WriteSettingsVar("ShowAllDmg", m_showAllDmg);
	WriteSettingsVar("BigItems", m_bigItems);
	WriteSettingsVar("PartyAutoAccept", m_partyAutoAccept);
	WriteSettingsVar("DetailLevel", m_cDetailLevel);
	WriteSettingsVar("Music", m_bMusicStat);
	WriteSettingsVar("Sound", m_bSoundStat);
	WriteSettingsVar("EKScreenshot", m_ekScreenshot);
	WriteSettingsVar("TabbedNotification", m_tabbedNotification);
	WriteSettingsVar("ManuAutoFill", m_manuAutoFill);
	WriteSettingsVar("TimeStamp", m_showTimeStamp);
	WriteSettingsVar("WindowsKey", m_windowsKey);
	WriteSettingsVar("ShowQuest", m_displayQuest);
	WriteSettingsVar("Remember", b_cRemember);
	if (m_sMagicShortCut >= 0 && m_sMagicShortCut < 100)
		WriteSettingsVar("Magic", m_sMagicShortCut + 1);

	if (m_sShortCut[0] >= 0 && m_sShortCut[0] < 200)
		WriteSettingsVar("ShortCut0", m_sShortCut[0] + 1);

	if (m_sShortCut[1] >= 0 && m_sShortCut[1] < 200)
		WriteSettingsVar("ShortCut1", m_sShortCut[1] + 1);

	if (m_sShortCut[2] >= 0 && m_sShortCut[2] < 200)
		WriteSettingsVar("ShortCut2", m_sShortCut[2] + 1);

	if (m_sShortCut[3] >= 0 && m_sShortCut[3] < 200)
		WriteSettingsVar("ShortCut3", m_sShortCut[3] + 1);

	if (m_sShortCut[4] >= 0 && m_sShortCut[4] < 200)
		WriteSettingsVar("ShortCut4", m_sShortCut[4] + 1);
}

void helbreath::WriteSettingsVar(const char * var, uint32_t val)
{
	// 	HKEY key;
	// 	unsigned long dwDisp;
	//
	// 	unsigned long size = sizeof(unsigned long);
	// 	if( RegCreateKeyExA( HKEY_CURRENT_USER, "Software\\Siementech\\Helbreath\\Settings", 0, 0,
	// 		REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 0, &key, &dwDisp ) != ERROR_SUCCESS )
	// 		return;
	//
	// 	RegSetValueExA(key, var, 0, REG_DWORD, (LPBYTE)&val, sizeof(UINT) );
	//
	// 	RegCloseKey(key);
}

shared_ptr<helbreath::MsgQueueEntry> helbreath::GetLoginMsgQueue()
{
	shared_ptr<helbreath::MsgQueueEntry> msg = loginpipe.front();
	loginpipe.pop_front();
	return msg;
}

void helbreath::on_message(const ix::WebSocketMessagePtr & msg)
{
	if (msg->type == ix::WebSocketMessageType::Message)
	{
        std::cout << "received message\n";
        auto message = std::make_shared<helbreath::MsgQueueEntry>();
		message->data = new char[msg->str.length()];
        memcpy(message->data, msg->str.c_str(), msg->str.length());
		message->size = msg->str.length();
        PutMsgQueue(message, loginpipe);

	}
	else if (msg->type == ix::WebSocketMessageType::Open)
	{
		m_dwConnectMode = MSGID_REQUEST_LOGIN;
		ConnectionEstablishHandler(SERVERTYPE_LOG);
	}
	else if (msg->type == ix::WebSocketMessageType::Error)
	{
		std::cout << "ws error\n";
		connection_loss_gamemode();
		socketmode(0);
		loggedin = false;
	}
	else if (msg->type == ix::WebSocketMessageType::Close)
	{
		std::cout << "ws close\n";
		connection_loss_gamemode();
		socketmode(0);
		loggedin = false;
	}
}

bool helbreath::is_connected() const
{
	return ws->getReadyState() == ix::ReadyState::Open;
}

bool helbreath::is_closed() const
{
	return ws->getReadyState() == ix::ReadyState::Closed;
}

bool helbreath::is_connecting() const
{
	return ws->getReadyState() == ix::ReadyState::Connecting;
}

bool helbreath::is_closing() const
{
	return ws->getReadyState() == ix::ReadyState::Closing;
}

void helbreath::PutMsgQueue(MsgQueue & q, char * data, uint32_t size)
{
	//poco_information(*logger, "PutMsgQueue()");
	shared_ptr<MsgQueueEntry> msg(new MsgQueueEntry);

	msg->data = new char[size];
	memcpy(msg->data, data, size);
	msg->size = size;

	q.push_back(msg);
}

void helbreath::PutMsgQueue(shared_ptr<helbreath::MsgQueueEntry> msg, MsgQueue & q)
{
	q.push_back(msg);
}

shared_ptr<helbreath::MsgQueueEntry> helbreath::GetMsgQueue()
{
	shared_ptr<helbreath::MsgQueueEntry> msg = socketpipe.front();
	socketpipe.pop_front();
	return msg;
}

void helbreath::perform_connect()
{
	ws->disableAutomaticReconnection();
	//ws->setUrl(fmt::format("wss://{}:8443", SERVER_IP));
	ws->setUrl(fmt::format("ws://{}:80", SERVER_IP));

	ws->setOnMessageCallback(
        [&](const ix::WebSocketMessagePtr & message)
    {
		on_message(message);
    }
    );
	ws->start();
}

void helbreath::write(const char * data, const uint64_t size)
{
    std::cout << "Sent " << size << " cbytes of data\n";
    auto d = ix::IXWebSocketSendData{ data, size };
    ws->sendBinary(d);
}

void helbreath::write(StreamWrite & sw)
{
	std::cout << "Sent " << sw.position << " bytes of data\n";
	auto d = ix::IXWebSocketSendData{ sw.data, sw.position };
	ws->sendBinary(d);
}

void helbreath::write(nlohmann::json & obj)
{
	ws->send(obj.dump(-1, 0x32, false, nlohmann::detail::error_handler_t::ignore));
}

void helbreath::connection_loss_gamemode()
{
	switch (m_cGameMode)
	{
		case GAMEMODE_ONCONNECTING:
		case GAMEMODE_ONMAINGAME:
		case GAMEMODE_ONLOGIN:
		case GAMEMODE_ONSELECTCHARACTER:
		case GAMEMODE_ONLOGRESMSG:
			// play mode. connection stop here would typically indicate a disconnect
			ChangeGameMode(GAMEMODE_ONCONNECTIONLOST);
			break;
		case GAMEMODE_ONMAINMENU:
			break;
		default:
			ChangeGameMode(GAMEMODE_ONMAINMENU);
			break;
	}
}

void helbreath::handle_stop()
{
	close(1000, "handle_stop()");
}

void helbreath::close(uint32_t code, const std::string & reason)
{
	try
	{
		ws->close(code, "close()");
	}
	catch (std::system_error & ex)
	{
		std::cout << "close() mutex lock timeout?\n";
	}
}

void helbreath::OnEvent(sf::Event event)
{
	//TODO: fix

	switch (event.type)
	{
		case sf::Event::KeyPressed:
		{
			switch (event.key.code)
			{
				case Keyboard::Left:
					m_cArrowPressed = 1;
					xtest--;
                    break;
                case Keyboard::Right:
                    m_cArrowPressed = 3;
                    xtest++;
                    break;
				case Keyboard::Up:
                    m_cArrowPressed = 2;
                    ytest--;
                    break;
				case Keyboard::Down:
                    m_cArrowPressed = 4;
                    ytest++;
                    break;

				case Keyboard::F5:
					break;
				case Keyboard::F7:
					break;
				case Keyboard::Escape:
					if (m_bCtrlPressed)
					{
						clipmousegame = !clipmousegame;
						window.setMouseCursorGrabbed(clipmousegame);
					}
					captured = true;
					break;
				case Keyboard::LShift:
					m_bShiftPressed = true;
					break;
				case Keyboard::LControl:
					m_bCtrlPressed = true;
					break;
				case Keyboard::LAlt:
					m_altPressed = true;
					break;
				case Keyboard::Tab:
					break;
				case Keyboard::Return:
					if (event.key.alt)
					{
						fullscreen = !fullscreen;
						window.close();
						window.create(sf::VideoMode(screenwidth, screenheight), winName, (fullscreen ? sf::Style::Fullscreen : (sf::Style::Resize | sf::Style::Close)));
						captured = true;
					}
					else
					{
						m_bEnterPressed = true;
					}
					break;
				case Keyboard::F12:
					CreateScreenShot();
					break;

				case Keyboard::F6:
					calcoldviewport = !calcoldviewport;
					if (!calcoldviewport)
					{
						AddEventList("Switched to new viewport code.");
					}
					else
					{
						AddEventList("Switched to old viewport code.");
					}
					break;
			}
			break;
		}
		case sf::Event::KeyReleased:
		{
			if (event.key.code == Keyboard::Backspace)
			{
			}
			if (event.key.code == Keyboard::Tab)
			{
			}

			switch (event.key.code)
			{
				case Keyboard::Escape:
					break;
				case Keyboard::LShift:
					m_bShiftPressed = false;
					break;
				case Keyboard::LControl:
					m_bCtrlPressed = false;
					break;
				case Keyboard::LAlt:
					m_altPressed = false;
					break;
				case Keyboard::Tab:
					break;
				case Keyboard::Return:
					break;
				case Keyboard::F12:
					break;
				case Keyboard::F5:
					break;
			}
			break;
		}
		case sf::Event::Resized:
			break;
		case sf::Event::LostFocus:
			window.setFramerateLimit(frame_limit_bg); //set to var
			break;
		case sf::Event::GainedFocus:
			if (m_cGameMode != GAMEMODE_ONLOADING)
				window.setFramerateLimit(frame_limit);
			else
				window.setFramerateLimit(0);
			break;
		case sf::Event::MouseWheelScrolled:
			if (event.mouseWheelScroll.wheel == sf::Mouse::VerticalWheel)
			{
			}
			else if (event.mouseWheelScroll.wheel == sf::Mouse::HorizontalWheel)
			{
			}
			else
			{
			}
			break;
	}

	switch (event.type)
	{
		case sf::Event::TextEntered:
		{
			//             std::string s = ((char *)event.text.unicode) + 3;
			//             std::cout << s << "\n";
						/*
							std::string s = ((char *)event.text.unicode) + 4;
							if (s == "-")
							{
								ui_update_frequency--;
								if (ui_update_frequency <= 0) ui_update_frequency = 1;
							}
							else if (s == "+")
							{
								ui_update_frequency++;
							}
							else if (s == "*")
							{
								responsive_ui = !responsive_ui;
							}
							else if (s == "/")
							{
								hide_ui = !hide_ui;
							}
							else if (s == "q")
							{
								take_screen = true;
							}*/
			break;
		}
		case sf::Event::KeyPressed:
		{
			switch (event.key.code)
			{
				case Keyboard::F5:
					break;
				case Keyboard::F7:
					break;
				case Keyboard::M:
					m_pBGM.stop();
					break;
				case Keyboard::Escape:
					clipmousegame = !clipmousegame;
					window.setMouseCursorGrabbed(clipmousegame);
					break;
				case Keyboard::LShift:
					m_bShiftPressed = true;
					break;
				case Keyboard::LControl:
					m_bCtrlPressed = true;
					break;
				case Keyboard::LAlt:
					m_altPressed = true;
					break;
				case Keyboard::Tab:
					break;
				case Keyboard::Return:
					if (event.key.alt)
					{
						fullscreen = !fullscreen;
						window.close();
						window.create(sf::VideoMode(screenwidth, screenheight), winName, (fullscreen ? sf::Style::Fullscreen : (sf::Style::Resize | sf::Style::Close)));
					}
					else
					{
						m_bEnterPressed = true;
					}
					break;
				case Keyboard::F12:
					CreateScreenShot();
					break;

				case Keyboard::F6:
					calcoldviewport = !calcoldviewport;
					if (!calcoldviewport)
					{
						AddEventList("Switched to new viewport code.");
					}
					else
					{
						AddEventList("Switched to old viewport code.");
					}
					break;
			}
			break;
		}
		case sf::Event::KeyReleased:
		{
			if (event.key.code == Keyboard::Backspace)
			{
			}
			if (event.key.code == Keyboard::Tab)
			{
			}

			switch (event.key.code)
			{
				case Keyboard::Escape:
					break;
				case Keyboard::LShift:
					m_bShiftPressed = false;
					break;
				case Keyboard::LControl:
					m_bCtrlPressed = false;
					break;
				case Keyboard::LAlt:
					m_altPressed = false;
					break;
				case Keyboard::Tab:
					break;
				case Keyboard::Return:
					break;
				case Keyboard::F12:
					break;
				case Keyboard::F5:
					break;
			}
			break;
		}
		case sf::Event::Resized:
			break;
		case sf::Event::LostFocus:
			window.setFramerateLimit(frame_limit_bg); //set to var
			break;
		case sf::Event::GainedFocus:
			if (m_cGameMode != GAMEMODE_ONLOADING)
				window.setFramerateLimit(frame_limit);
			else
				window.setFramerateLimit(0);
			break;
		case sf::Event::MouseWheelScrolled:
			if (event.mouseWheelScroll.wheel == sf::Mouse::VerticalWheel)
			{
			}
			else if (event.mouseWheelScroll.wheel == sf::Mouse::HorizontalWheel)
			{
			}
			else
			{
			}
			break;
		case sf::Event::MouseButtonPressed:
		{
			if (wasinactive)
			{
				wasinactive = false;
			}

			for (auto & rect : dialogs)
			{
				if (rect.contains(m_stMCursor.sX, m_stMCursor.sY))
				{
					break;
				}
			}

			if (event.mouseButton.button == sf::Mouse::Right)
			{
				m_stMCursor.RB = true;
			}
			else if (event.mouseButton.button == sf::Mouse::Left)
			{
				m_stMCursor.LB = true;
			}
			else if (event.mouseButton.button == sf::Mouse::Middle)
			{
				m_stMCursor.MB = true;
			}
			break;
		}
		case sf::Event::MouseButtonReleased:
		{
			if (event.mouseButton.button == sf::Mouse::Right)
			{
				m_stMCursor.RB = false;
			}
			else if (event.mouseButton.button == sf::Mouse::Left)
			{
				m_stMCursor.LB = false;
			}
			else if (event.mouseButton.button == sf::Mouse::Middle)
			{
				m_stMCursor.MB = false;
			}
			break;
		}
		case sf::Event::MouseMoved:
		{
			float diffx = static_cast<float>(screenwidth_v) / screenwidth;
			float diffy = static_cast<float>(screenheight_v) / screenheight;
			uint16_t x = uint16_t(event.mouseMove.x * diffx);
			uint16_t y = uint16_t(event.mouseMove.y * diffy);

			m_stMCursor.sX = x;
			m_stMCursor.sY = y;

			//std::cout << fmt::format("{:#4}, {:#4} || {:#4}, {:#4}\n", event.mouseMove.x, event.mouseMove.y, x, y);

			break;
		}
	}
}

void helbreath::DrawVersion2()
{
	//sprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->DrawRGB(14, 463, 19, 140, 140, 140, mtime);
	// Upper Version
	char version[20];
	fmt::format_to(version, "V. %d.%.2d", UPPER_VERSION, LOWER_VERSION);
	//font[TESTFONT]->draw(version, rect<s32>(36, 463, 100, 475), SColor(255, 140, 140, 140));
	//sprite[DEF_SPRID_INTERFACE_ADDINTERFACE]->DrawRGB(42, 463, 18, 140, 140, 140, mtime);
}

helbreath::helbreath()
{
#if defined(WIN32)
	ix::initNetSystem();
#endif

	ws = std::make_unique<ix::WebSocket>();

	ws->setOnMessageCallback(std::bind(&helbreath::on_message, this, std::placeholders::_1));

	socketmode(0);
	oldmode = 0;
	int i;
	srand((unsigned)time(0));
	ReadSettings();

	m_stMCursor.sCursorFrame = 0;

	loggedin = false;

	if (!autoresolution)
	{
		//SetResolution(640, 480);
		//SetResolution(800, 600);
		//SetResolution(1024, 768);
		//SetResolution(1280, 1024);
		//SetResolution(1920, 1200);

		//SetResolution(1280, 720);
		//SetResolution(1366, 768);
		//SetResolution(1600, 900);
		//SetResolution(1920, 1080);

		//SetVirtualResolution(5120, 2160);
		SetResolution(800, 600);
	}
	if (!autovresolution)
	{
		SetVirtualResolution(800, 600);
	}

	for (i = 0; i < MAXMENUITEMS; i++)
		m_pTitles[i] = 0;
	m_iTitleIndex = -1;

	for (i = 0; i < MAXITEMSTATS; i++)
		m_pBuildItemListStats[i] = 0;

	m_hPakFile = nullptr;

	memset(m_cCurLocation, 0, sizeof(m_cCurLocation));

	memset(&m_rcBodyRect, 0, sizeof(m_rcBodyRect));
	memset(&m_rcPlayerRect, 0, sizeof(m_rcBodyRect));

	memset(m_cItemDrop, 0, sizeof(m_cItemDrop));

	m_chatDisplay = nullptr;

	for (i = 0; i < MAXWHISPERMSG; i++)
		m_pWhisperMsg[i] = 0;

#ifdef _DEBUG
	m_bToggleScreen = true;
#else
	m_bToggleScreen = false;
#endif

	m_cLoading = 0;
	m_bZoomMap = false;
	m_bIsFirstConn = true;
	m_iItemDropCnt = 0;
	m_bItemDrop = false;
	m_bIsSpecial = false;
	m_cGameMode = GAMEMODE_ONLOADING;
	m_cWhisperIndex = MAXWHISPERMSG;
	m_cGameModeCount = 0;
	memset(m_cMapName, 0, sizeof(m_cMapName));
	//	m_pGSock   = 0;
	m_pMapData = 0;
	m_cCommandCount = 0;
	m_dwCommandTime = 0; //v2.15 SpeedHack
	m_sPlayerX = 0;
	m_sPlayerY = 0;
	m_sViewDX = 0;
	m_sViewDY = 0;
	m_cCommand = OBJECTSTOP;
	m_bIsObserverMode = false;
	m_ekSSTime = 0;
	m_showBtns = false;
	m_weight = 0;
	m_droppedOnIconbar = false;

	//m_voteUrls.push_back("hbtop50.com/button.php?u=Legion"); // Voting ? xRisenx

	for (i = 0; i < MAXSPRITES; i++)
		m_pSprite[i] = 0;
	for (i = 0; i < MAXTILES; i++)
		m_pTileSpr[i] = 0;
	for (i = 0; i < MAXEFFECTSPR; i++)
		m_pEffectSpr[i] = 0;
	for (i = 0; i < 13; i++)
	{
		strcpy(friendsList[i].friendName, "");
		friendsList[i].online = false;
	}
	for (i = 0; i < MAXCHATMSGS; i++)
		m_pChatMsgList[i] = 0;

	for (i = 0; i < MAXEFFECTS; i++)
		m_pEffectList[i] = 0;

	for (i = 0; i < MAXITEMS; i++)
		m_pItemList[i] = 0;

	for (i = 0; i < MAXBANKITEMS; i++)
		m_pBankList[i] = 0;

	for (i = 0; i < MAXDIALOGBOX; i++)
		m_cDialogBoxOrder[i] = 0;

	for (i = 0; i < MAXMAGICTYPE; i++)
		m_pMagicCfgList[i] = 0;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_pSkillCfgList[i] = 0;

	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		m_pMsgTextList[i] = 0;
		m_pMsgTextList2[i] = 0;
		m_pAgreeMsgTextList[i] = 0;
	}

	for (i = 0; i < MAXBUILDITEMS; i++)
		m_pBuildItemList[i] = 0;

	for (i = 0; i < MAXBUILDITEMS; i++)
		m_pDispBuildItemList[i] = 0;
	// Gladiator Arena xRisenx
	/*for (i = 0; i < MAXARENAPLAYERS; i++)
{
   m_stArenaPlayers[i].iKills = 0;
   m_stArenaPlayers[i].iDeaths = 0;
   ZeroMemory(m_stArenaPlayers[i].cCharName, sizeof(m_stArenaPlayers[i].cCharName));
}*/
// Gladiator Arena xRisenx
// Crafting:
	for (i = 0; i < MAXBUILDITEMS; i++)
		m_pCraftItemList[i] = 0;
	for (i = 0; i < MAXBUILDITEMS; i++)
		m_pDispCraftItemList[i] = 0;

	for (i = 0; i < MAXITEMNAMES; i++)
		m_pItemNameList[i] = 0;

	for (i = 0; i < MAXLEVEL + 20; i++)
		m_levelExpTable[i] = iGetLevelExp(i);

	m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
	m_iGameServerMode = 2; // Snoopy: Default is INTERNET

	for (i = 0; i < MAXMENUITEMS; i++)
		m_pItemForSaleList[i] = 0;

	m_cash = 0;

	m_bCtrlPressed = false;
	m_bShiftPressed = false;
	m_bEnterPressed = false;
	m_bEscPressed = false;
	m_bSoundFlag = true;
	m_dwDialogCloseTime = 0;
	m_iTimeLeftSecAccount = 0;
	m_iTimeLeftSecIP = 0;
	m_bWhisper = true;
	m_bShout = true;
}

helbreath::~helbreath()
{
}

bool helbreath::bInit()
{
    int iIndex = {};

    int i;
    CStrTok * pStrTok = {};
    char seps[] = "&= ,\t\n";
    char * token = {};
    for (auto spr : m_pSprite)
        spr = nullptr;

    // #ifdef UPDATER
    // 	if(strcmp(G_cCmdLineTokenA, ENCRYPT_CODE) != 0)
    // 	{
    // 		MessageBoxA(hWnd, LNG_STARTLAUNCHER, LNG_STARTLAUNCHER, MB_OK);
    // 		return false;
    // 	}
    // #endif

    m_bCommandAvailable = true;
    m_dwTime = G_dwGlobalTime;
    m_bSoundFlag = m_bSoundStat = m_bMusicStat = true;
    m_bIsHideLocalCursor = false;
    m_cEnterCheck = m_cTabCheck = m_cLeftArrowCheck = 0;

    memset(m_cLogServerAddr, 0, sizeof(m_cLogServerAddr));
    strcpy(m_cLogServerAddr, SERVER_IP);
    m_iLogServerPort = SERVER_PORT;

    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);
    if ((SysTime.wMonth == 12) || (SysTime.wMonth == 1))
        m_bIsXmas = true;
    else
        m_bIsXmas = false;

    // 	if (bCheckImportantFile() == false)
    // 	{
    // //fix windows
    // 		MessageBoxA(handle, MSG_NOTIFY_CHECKSUM, "ERROR1", MB_ICONEXCLAMATION | MB_OK);
    // 		return false;
    // 	}

    if (_bDecodeBuildItemContents() == false)
    {
        //fix windows
        MessageBoxA(handle, MSG_NOTIFY_CHECKSUM, "ERROR2", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    if (bReadItemNameConfigFile() == false)
    {
        //fix windows
        MessageBoxA(handle, MSG_NOTIFY_ITEMNAME, "ERROR", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    for (int i = 0; i < SG_MAX; i++)
    {
        g_socketMap[i] = SocketGems[i];
    }

    if (bInitMagicCfgList() == false)
    {
        //fix windows
        MessageBoxA(handle, MSG_NOTIFY_MAGICCFG, "ERROR", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }
    // Skill
    if (bInitSkillCfgList() == false)
    {
        //fix windows
        MessageBoxA(handle, MSG_NOTIFY_SKILLCFG, "ERROR", MB_ICONEXCLAMATION | MB_OK);
        return false;
    }

    // 	if (//DIRECTX m_DDraw.bInit(m_hWnd) == FALSE)
    // 	{
    // 		MessageBoxA(m_hWnd, MSG_NOTIFY_DIRECTX7,"ERROR",MB_ICONEXCLAMATION | MB_OK);
    // 		return FALSE;
    // 	}

    // 	if (//DIRECTX m_dInput.bInit(hWnd, hInst) == FALSE)
    // 	{
    // 		MessageBoxA(m_hWnd, MSG_NOTIFY_DIRECTX7,"ERROR",MB_ICONEXCLAMATION | MB_OK);
    // 		return FALSE;
    // 	}

    ////m_hPakFile = CreateFileA("sprites\\New-Dialog.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    m_pSprite[SPRID_INTERFACE_ND_LOADING] = sprite::CreateSprite("New-Dialog", 0, false);
    ////CloseHandle(m_hPakFile);

    ////m_hPakFile = CreateFileA("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    m_pSprite[SPRID_INTERFACE_ADDINTERFACE] = sprite::CreateSprite("interface2", 0, false);
    m_pSprite[SPRID_INTERFACE_CRAFTING] = sprite::CreateSprite("interface2", 3, false);
    ////CloseHandle(m_hPakFile);

    // CLEROTH - LOAD FONTS BEFORE MAIN LOADINGl
    ////m_hPakFile = CreateFileA("sprites\\interface2.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    if (m_hPakFile != INVALID_HANDLE_VALUE)
    {
        m_pSprite[SPRID_INTERFACE_SPRFONTS2] = sprite::CreateSprite("interface2", 1, false);
        m_pSprite[SPRID_INTERFACE_F1HELPWINDOWS] = sprite::CreateSprite("interface2", 2, false);
        ////CloseHandle(m_hPakFile);
    }

    ////m_hPakFile = CreateFileA("sprites\\sprfonts.pak", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    if (m_hPakFile != INVALID_HANDLE_VALUE)
    {
        m_pSprite[SPRID_INTERFACE_FONT1] = sprite::CreateSprite("sprfonts", 0, false);
        m_pSprite[SPRID_INTERFACE_FONT2] = sprite::CreateSprite("sprfonts", 1, false);
        ////CloseHandle(m_hPakFile);
    }

    m_stMCursor.sX = 0;
    m_stMCursor.sY = 0;
    m_pMapData = new class CMapData(this);
    //memset(m_cPlayerName, 0, sizeof(m_cPlayerName));
    //memset(m_cAccountName, 0, sizeof(m_cAccountName));
    //memset(m_cAccountPassword, 0, sizeof(m_cAccountPassword));

    m_sPlayerType = 2;
    m_cPlayerTurn = 0;

    m_cDialogBoxOrder[MAXDIALOGBOX - 1] = 29;
    m_cDialogBoxOrder[MAXDIALOGBOX - 2] = 30;

    m_cMenuDir = 4;
    m_cMenuDirCnt = 0;
    m_cMenuFrame = 0;

    m_cSoundVolume = 100;
    m_cMusicVolume = 100;

    m_wWR[1] = 70;
    m_wWG[1] = 70;
    m_wWB[1] = 80;
    m_wWR[2] = 70;
    m_wWG[2] = 70;
    m_wWB[2] = 80;
    m_wWR[3] = 70;
    m_wWG[3] = 70;
    m_wWB[3] = 80;
    m_wWR[4] = 70;
    m_wWG[4] = 100;
    m_wWB[4] = 70;
    m_wWR[5] = 130;
    m_wWG[5] = 90;
    m_wWB[5] = 10;
    m_wWR[6] = 42;
    m_wWG[6] = 53;
    m_wWB[6] = 111;
    m_wWR[7] = 145;
    m_wWG[7] = 145;
    m_wWB[7] = 145;
    m_wWR[8] = 120;
    m_wWG[8] = 100;
    m_wWB[8] = 120;
    m_wWR[9] = 75;
    m_wWG[9] = 10;
    m_wWB[9] = 10;
    m_wWR[10] = 135;
    m_wWG[10] = 104;
    m_wWB[10] = 30;

    m_wR[0] = 100;
    m_wWG[0] = 100;
    m_wWB[0] = 100;
    m_wR[1] = 0;
    m_wWG[1] = 0;
    m_wWB[1] = 64;
    m_wR[2] = 61;
    m_wWG[2] = 41;
    m_wWB[2] = 24;
    m_wR[3] = 42;
    m_wWG[3] = 85;
    m_wWB[3] = 53;
    m_wR[4] = 64;
    m_wWG[4] = 0;
    m_wWB[4] = 0;
    m_wR[5] = 0;
    m_wWG[5] = 64;
    m_wWB[5] = 0;
    m_wR[6] = 18;
    m_wWG[6] = 0;
    m_wWB[6] = 32;
    m_wR[7] = 0;
    m_wWG[7] = 64;
    m_wWB[7] = 64;
    m_wR[8] = 127;
    m_wWG[8] = 10;
    m_wWB[8] = 73;
    m_wR[9] = 64;
    m_wWG[9] = 0;
    m_wWB[9] = 64;
    m_wR[10] = 175;
    m_wWG[10] = 175;
    m_wWB[10] = 175;
    m_wR[11] = 127;
    m_wWG[11] = 82;
    m_wWB[11] = 0;
    m_wR[12] = 135;
    m_wWG[12] = 64;
    m_wWB[12] = 84;
    m_wR[13] = 127;
    m_wWG[13] = 107;
    m_wWB[13] = 0;
    m_wR[14] = 64;
    m_wWG[14] = 0;
    m_wWB[14] = 0;
    m_wR[15] = 40;
    m_wWG[15] = 40;
    m_wWB[15] = 40;

    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]); // Normal Dont Change
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0x00/4, 0xff/4),  &m_wR[1], &m_wG[1], &m_wB[1]); // Blue
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xf4/4, 0xa4/4, 0x60/4),  &m_wR[2], &m_wG[2], &m_wB[2]); // Sandy Brown
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x7f/3, 0xff/3, 0xd4/3),  &m_wR[3], &m_wG[3], &m_wB[3]); // AquaMarine
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0x00/4),  &m_wR[4], &m_wG[4], &m_wB[4]); // Red
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0x00/4),  &m_wR[5], &m_wG[5], &m_wB[5]); // Green
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x4b/4, 0x00/4, 0x82/4),  &m_wR[6], &m_wG[6], &m_wB[6]); // Indigo
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0xff/4),  &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0x14/2, 0x93/2),  &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0xff/4),  &m_wR[9], &m_wG[9], &m_wB[9]); // Violet
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 175, 175, 175),  &m_wR[10], &m_wG[10], &m_wB[10]); // White
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xa5/2, 0x00/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Orange
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x0f/3, 0xc0/3, 0xfc/3),  &m_wR[12], &m_wG[12], &m_wB[12]); // Disco Blue
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xd7/2, 0x00/2),  &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow Damage Monster Txt
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0x00/4),  &m_wR[14], &m_wG[14], &m_wB[14]); // Red Casting Txt
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 40, 40, 40),  &m_wR[15], &m_wG[15], &m_wB[15]); // Black

    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  70,  70,  80), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Light-blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  70,  70,  80), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // light-blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  70,  70,  80), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // light-blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  70, 100,  70), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Green
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 130,  90,  10), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  42,  53, 111), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Heavy-blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // White
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]);
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  75,  10,  10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 135, 104,  30), &m_wWR[10],&m_wWG[10],&m_wWB[10]);	// Gold

    // Weapon's
    //
    //
    //TODO: need to remap all colors into irrlicht capable shit
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x7f/3, 0xff/3, 0xd4/3), &m_wWR[1], &m_wWG[1], &m_wWB[1]); // Agile
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x0f/3, 0xc0/3, 0xfc/3), &m_wWR[2], &m_wWG[2], &m_wWB[2]); // Light
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0xff/4), &m_wWR[3], &m_wWG[3], &m_wWB[3]); // Strong
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0x00/4), &m_wWR[4], &m_wWG[4], &m_wWB[4]); // Poison
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xa5/2, 0x00/2), &m_wWR[5], &m_wWG[5], &m_wWB[5]); // Critical
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0x00/4, 0xff/4), &m_wWR[6], &m_wWG[6], &m_wWB[6]); // Sharp
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 145, 145, 145), &m_wWR[7], &m_wWG[7], &m_wWB[7]); // Rightous
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 120, 100, 120), &m_wWR[8], &m_wWG[8], &m_wWB[8]); // Ancient
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  75,  10,  10), &m_wWR[9], &m_wWG[9], &m_wWB[9]); // Heavy-Red
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 175, 175, 175), &m_wWR[10], &m_wWG[10], &m_wWB[10]); // White
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xd7/2, 0x00/2), &m_wWR[11], &m_wWG[11], &m_wWB[11]); // Gold
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 40, 40, 40), &m_wWR[12], &m_wWG[12], &m_wWB[12]); // Black
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0xff/4), &m_wWR[13], &m_wWG[13], &m_wWB[13]); // Violet
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xf4/4, 0xa4/4, 0x60/4), &m_wWR[14], &m_wWG[14], &m_wWB[14]); // Sandy Brown
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x4b/4, 0x00/4, 0x82/4), &m_wWR[15], &m_wWG[15], &m_wWB[15]); // Indigo
    // #ifdef MoreColors
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00, 0xff, 0x00), &m_wWR[16], &m_wWG[16], &m_wWB[16]); // Test 1 Green
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff, 0xff, 0x00), &m_wWR[17], &m_wWG[17], &m_wWB[17]); // Test 2 Yellow
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff, 0xff, 0xff), &m_wWR[18], &m_wWG[18], &m_wWB[18]); // Test 3 White
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff, 0x00, 0x00), &m_wWR[19], &m_wWG[19], &m_wWB[19]); // Test 4 Red
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff, 0x00, 0xff), &m_wWR[20], &m_wWG[20], &m_wWB[20]); // Test 5 PINK
    // #endif
    // 	// Armor's
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]); // Normal Dont Change
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0x00/4, 0xff/4),  &m_wR[1], &m_wG[1], &m_wB[1]); // Blue
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xf4/4, 0xa4/4, 0x60/4),  &m_wR[2], &m_wG[2], &m_wB[2]); // Sandy Brown
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x7f/3, 0xff/3, 0xd4/3),  &m_wR[3], &m_wG[3], &m_wB[3]); // AquaMarine
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0x00/4),  &m_wR[4], &m_wG[4], &m_wB[4]); // Red
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0x00/4),  &m_wR[5], &m_wG[5], &m_wB[5]); // Green
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x4b/4, 0x00/4, 0x82/4),  &m_wR[6], &m_wG[6], &m_wB[6]); // Indigo
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x00/4, 0xff/4, 0xff/4),  &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0x14/2, 0x93/2),  &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0xff/4),  &m_wR[9], &m_wG[9], &m_wB[9]); // Violet
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 175, 175, 175),  &m_wR[10], &m_wG[10], &m_wB[10]); // White
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xa5/2, 0x00/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Orange
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0x0f/3, 0xc0/3, 0xfc/3),  &m_wR[12], &m_wG[12], &m_wB[12]); // Disco Blue
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/2, 0xd7/2, 0x00/2),  &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow Damage Monster Txt
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 0xff/4, 0x00/4, 0x00/4),  &m_wR[14], &m_wG[14], &m_wB[14]); // Red Casting Txt
    // 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 40, 40, 40),  &m_wR[15], &m_wG[15], &m_wB[15]); // Black

    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 200/2,  200/2,  200/2),  &m_wR[0], &m_wG[0], &m_wB[0]);
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0x50/2, 0x50/2, 0xC0/2),  &m_wR[1], &m_wG[1], &m_wB[1]); // Indigo Blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,    87,   87,     62),  &m_wR[2], &m_wG[2], &m_wB[2]); // Custom-Weapon Color
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,   135,    104,     30),  &m_wR[3], &m_wG[3], &m_wB[3]); // Gold
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255, 255/2,   36/2,      0),  &m_wR[4], &m_wG[4], &m_wB[4]); // Crimson
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,    10,     60,     10),  &m_wR[5], &m_wG[5], &m_wB[5]); // Green
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0x50/2, 0x50/2, 0x50/2),  &m_wR[6], &m_wG[6], &m_wB[6]); // Gray
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0x5F/2, 0x9E/2, 0xA0/2),  &m_wR[7], &m_wG[7], &m_wB[7]); // Aqua
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0xFF/2, 0x69/2, 0xB4/2),  &m_wR[8], &m_wG[8], &m_wB[8]); // Pink
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,    90,     60,     90),  &m_wR[9], &m_wG[9], &m_wB[9]);
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,     60,     60,     80),  &m_wR[10], &m_wG[10], &m_wB[10]); // Blue
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0xD2/2, 0xB4/2, 0x8C/2),  &m_wR[11], &m_wG[11], &m_wB[11]); // Tan
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,0xBD/2, 0xB7/2, 0x6B/2),  &m_wR[12], &m_wG[12], &m_wB[12]); // Khaki
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,    85,     85,      8),  &m_wR[13], &m_wG[13], &m_wB[13]); // Yellow
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,    75,     10,     10),  &m_wR[14], &m_wG[14], &m_wB[14]); // Red
    //m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,video::SColor(255,  12,   20,   30),  &m_wR[15], &m_wG[15], &m_wB[15]); // Black

    memset(m_cWorldServerName, 0, sizeof(m_cWorldServerName));

    return true;
}

void helbreath::Quit()
{
	int i;
	WriteSettings();
	ChangeGameMode(GAMEMODE_NULL);

	for (i = 0; i < MAXSPRITES; i++)
		if (m_pSprite[i] != 0) delete m_pSprite[i];
	for (i = 0; i < MAXTILES; i++)
		if (m_pTileSpr[i] != 0) delete m_pTileSpr[i];
	for (i = 0; i < MAXEFFECTSPR; i++)
		if (m_pEffectSpr[i] != 0) delete m_pEffectSpr[i];

	for (i = 0; i < MAXITEMS; i++)
		if (m_pItemList[i] != 0)	delete m_pItemList[i];

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)	delete m_pBankList[i];

	for (i = 0; i < MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];

	for (i = 0; i < MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];

	for (int i = 0; i < CHAT_MAX; i++)
	{
		for (std::vector<CMsg *>::iterator it = m_chatMsgs[i].begin();
			it != m_chatMsgs[i].end();
			++it)
		{
			delete (*it);
		}
		m_chatMsgs[i].clear();
	}
	if (m_chatDisplay)
		delete m_chatDisplay;

	for (i = 0; i < MAXWHISPERMSG; i++)
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];

	for (i = 0; i < MAXMENUITEMS; i++)
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];

	for (i = 0; i < MAXMAGICTYPE; i++)
		if (m_pMagicCfgList[i] != 0) delete m_pMagicCfgList[i];

	for (i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != 0) delete m_pSkillCfgList[i];

	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)  delete m_pMsgTextList[i];
		if (m_pMsgTextList2[i] != 0) delete m_pMsgTextList2[i];
		if (m_pAgreeMsgTextList[i] != 0) delete m_pAgreeMsgTextList[i];
	}

	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0) delete m_pDispBuildItemList[i];

	for (i = 0; i < MAXITEMSTATS; i++)
		if (m_pBuildItemListStats[i] != 0) delete m_pBuildItemListStats[i];

	// Crafting:
	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pCraftItemList[i] != 0) delete m_pCraftItemList[i];
	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pDispCraftItemList[i] != 0) delete m_pDispCraftItemList[i];


	for (i = 0; i < MAXITEMNAMES; i++)
		if (m_pItemNameList[i] != 0) delete m_pItemNameList[i];

	delete m_pMapData;

	close(1000, "~");
}

std::string helbreath::get_game_mode_str()
{
    for (auto & mode : game_mode_map)
    {
        if (mode.first == m_cGameMode)
            return mode.second;
    }
    return "unknown";
}

std::string helbreath::get_game_mode(int _gamemode)
{
    for (auto & mode : game_mode_map)
    {
        if (mode.first == _gamemode)
            return mode.second;
    }
    return "unknown";
}

int16_t helbreath::get_game_mode(std::string _gamemode)
{
    for (auto & mode : game_mode_map)
    {
        if (mode.second == _gamemode)
            return mode.first;
    }
    return GAMEMODE_NULL;
}

void helbreath::CalcViewPoint()
{
	short dX, dY;
	dX = m_sViewPointX - m_sViewDstX;
	dY = m_sViewPointY - m_sViewDstY;
	if (abs(dX) < abs(m_sViewDX))
	{
		m_sViewPointX = m_sViewDstX;
		m_sViewDX = 0;
	}
	else
	{
		if (dX > 0) m_sViewDX--;
		if (dX < 0) m_sViewDX++;
		if (dX == 0) m_sViewDX = 0;
		if (abs(dX) < 40)
		{
			if (m_sViewDX > 4)  m_sViewDX = 4;
			else if (m_sViewDX < -4) m_sViewDX = -4;
		}
		m_sViewPointX += m_sViewDX;
	}

	if (abs(dY) < abs(m_sViewDY))
	{
		m_sViewPointY = m_sViewDstY;
		m_sViewDY = 0;
	}
	else
	{
		if (dY > 0) m_sViewDY--;
		if (dY < 0) m_sViewDY++;
		if (dY == 0) m_sViewDY = 0;
		if (abs(dY) < 40)
		{
			if (m_sViewDY > 4)  m_sViewDY = 4;
			else if (m_sViewDY < -4) m_sViewDY = -4;
		}
		m_sViewPointY += m_sViewDY;
	}
}

void helbreath::RestoreSprites()
{
	//for (int i = 0; i < MAXSPRITES; i++)
	//if (m_pSprite[i] != 0) m_pSprite[i]->iRestore();
}

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };
char helbreath::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, bool bMoveCheck, bool isMIM)
{
	char  cDir, cTmpDir;
	//int   aX, aY, aX2, aY2, dX, dY;
	int   aX, aY, dX, dY;
	int   i;
	if ((sX == dstX) && (sY == dstY)) return 0;
	dX = sX;
	dY = sY;

	if (isMIM == false)
		cDir = m_Misc.cGetNextMoveDir(dX, dY, dstX, dstY);
	else cDir = m_Misc.cGetNextMoveDir(dstX, dstY, dX, dY);

	if (m_cPlayerTurn == 0)
		for (i = cDir; i <= cDir + 2; i++)
		{
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}

	if (m_cPlayerTurn == 1)
		for (i = cDir; i >= cDir - 2; i--)
		{
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (((dX + aX) == m_iPrevMoveX) && ((dY + aY) == m_iPrevMoveY) && (m_bIsPrevMoveBlocked == true) && (bMoveCheck == true))
			{
				m_bIsPrevMoveBlocked = false;
			}
			else if (m_pMapData->bGetIsLocateable(dX + aX, dY + aY) == true)
			{
				if (m_pMapData->bIsTeleportLoc(dX + aX, dY + aY) == true)
				{
					if (_bCheckMoveable(dX + aX, dY + aY) == true) return cTmpDir;
					else
					{
						SetTopMsg(MSG_GETNEXTMOVEDIR, 5);
					}
				}
				else return cTmpDir;
			}
		}
	return 0;
}

bool helbreath::_bCheckMoveable(short sx, short sy)
{	// Snoopy: This function prevents the client from asking at TP from some maps to
	// ML or PL if not citizen
	// Incomplete function and useless (the server will handle such cases)
/*	if( m_bIsCrusadeMode ) return TRUE;
	if( m_bHunter == FALSE ) return TRUE;
	if( m_side == NEUTRAL ) return TRUE;
	if( m_side == ARESDEN && m_cMapIndex == 11 )
	{	if( sy == 20 )
		{	if( (sx>=39) && (sx<=47) ) return FALSE;
			if( (sx>=360) && (sx<=368) ) return FALSE;
		}
	}
	if( m_side == ELVINE && m_cMapIndex == 3 )
	{
		if( sy == 373 )
		{	if( (sx>=27) && (sx<=32) ) return FALSE;
		}
		if( sy == 374 )
		{	if( (sx>=298) && (sx<=305) ) return FALSE;
		}
	}*/
	return true;
}

bool helbreath::SendLoginCommand(uint32_t dwMsgID)
{
    char * cp, cMsg[300], cKey;

    StreamWrite sw;

    memset(cMsg, 0, sizeof(cMsg));
    cKey = (char)(rand() % 255) + 1;

    cp = cMsg;

    //TODO: future servers opened under same bin will need a different name
    strcpy(m_cWorldServerName, "Xtreme");

    sw.WriteInt(dwMsgID);

    switch (dwMsgID)
    {
        case MSGID_GETMINIMUMLOADGATEWAY:
        case MSGID_REQUEST_LOGIN:
            sw.WriteString(m_cAccountName, 60);
            sw.WriteString(m_cAccountPassword, 60);
            sw.WriteString(m_cWorldServerName, 30);
            sw.WriteInt(screenwidth_v);
            sw.WriteInt(screenheight_v);
            sw.WriteInt(screenwidth);
            sw.WriteInt(screenheight);
            break;

        case MSGID_REQUEST_ENTERGAME:
            sw.WriteString(player_name, 10);
            sw.WriteShort(m_wEnterGameType);
            sw.WriteString(m_cWorldServerName, 30);
            break;

        case MSGID_REQUEST_CREATENEWCHARACTER:
            sw.WriteString(player_name, 10);
            sw.WriteString(m_cWorldServerName, 30);
            sw.WriteByte(m_cGender);
            sw.WriteByte(m_cSkinCol);
            sw.WriteByte(m_cHairStyle);
            sw.WriteByte(m_cHairCol);
            sw.WriteByte(m_cUnderCol);

            sw.WriteByte(m_createStat[STAT_STR]);
            sw.WriteByte(m_createStat[STAT_VIT]);
            sw.WriteByte(m_createStat[STAT_DEX]);
            sw.WriteByte(m_createStat[STAT_INT]);
            sw.WriteByte(m_createStat[STAT_MAG]);
            sw.WriteByte(m_createStat[STAT_CHR]);
            break;

        case MSGID_REQUEST_DELETECHARACTER:
            sw.WriteString(selectedchar->m_cName, 10);
            sw.WriteString(m_cWorldServerName, 30);
            break;
    }

    write(sw);
    return true;
}

bool helbreath::bSendCommand(uint32_t dwMsgID, uint16_t wCommand, char cDir, int iV1, int iV2, int iV3, char const * const pString, int iV4)
{
	char * cp, cMsg[300 + MAX_MAIL_MSG_LENGTH], cTxt[256], cKey;
	uint16_t * wp;
	uint32_t * dwp, dwTime;
	short * sp;
	int * ip, iRet, i, * fightzonenum;
	CDialogBox * dlg;

	StreamWrite sw;

	dwTime = unixtime();

	cKey = (char)(rand() % 255) + 1;

	wp = (uint16_t *)(cMsg + INDEX2_MSGTYPE);

	cp = cMsg;
	sw.WriteInt(dwMsgID);

	if (dwMsgID & MSGIDTYPE_MOTION)
	{
		if (m_bIsTeleportRequested)
			return false;

		sw.WriteShort(m_sPlayerX);
		sw.WriteShort(m_sPlayerY);
		sw.WriteByte(cDir);
		sw.WriteInt(dwMsgID);
		sw.WriteShort(iV1);

		if (wCommand != MSGID_MOTION_GETITEM && wCommand != MSGID_MOTION_RUN &&
			wCommand != MSGID_MOTION_MOVE && wCommand != MSGID_MOTION_DAMAGEMOVE)
		{
			sw.WriteShort(iV2);
			if (wCommand != MSGID_MOTION_MAGIC)
			{
				sw.WriteShort(iV3);
				if (wCommand == MSGID_MOTION_ATTACK || wCommand == MSGID_MOTION_ATTACKMOVE)
					sw.WriteShort(iV4);
			}
		}

		write(sw);

		m_cCommandCount++;
	}
	else
	{
		sw.WriteShort(0);

		switch (dwMsgID)
		{
			case MSGID_PINGMAP:
				*wp = wCommand;
				sw.WriteShort(iV1);
				sw.WriteShort(iV2);
				write(sw);
				break;

			case MSGID_REQ_GUILDBOARD:
				sw.WriteInt((m_gldBoard.size() > 0) ? m_gldBoard[m_gldBoard.size() - 1]->id : 0);
				write(sw);
				break;

			case MSGID_REQ_MAILBOX:
				sw.WriteInt((m_mails.size() > 0) ? m_mails[m_mails.size() - 1]->id : 0);
				write(sw);
				break;

			case MSGID_REQ_DELETEMAIL:
			case MSGID_REQ_DELETEGUILDPOST:
				sw.WriteInt(iV1);
				write(sw);
				break;

			case MSGID_REQ_SENDMAIL:
				dlg = &m_dialogBoxes[DIALOG_MAILBOX];
				Push(cp, dlg->cStr); // to
				if (dlg->cStr2[0])
					Push(cp, dlg->cStr2); // title
				else
					Push(cp, "Untitled");
				Push(cp, dlg->txt); // msg

				Push(cp, (uint8_t)dlg->vvec.size());
				for (i = 0; i < dlg->vvec.size(); i++)
				{
					Push(cp, dlg->vvec[i].index);
					Push(cp, dlg->vvec[i].count);
				}

				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQ_RETRIEVEMAILITEM:
				dlg = &m_dialogBoxes[DIALOG_MAILBOX];
				Push(cp, m_mails[dlg->sV1]->id);
				Push(cp, m_mails[dlg->sV1]->items[dlg->sV2]->ItemUniqueID);

				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQ_MAILDATA:
			case MSGID_REQ_GUILDPOSTDATA:
				Push(cp, (uint32_t)iV1);

				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQ_POSTGUILDBOARD:
				dlg = &m_dialogBoxes[DIALOG_GUILD];
				if (dlg->cStr2[0])
					Push(cp, dlg->cStr2); // title
				else
					Push(cp, "Untitled");
				Push(cp, dlg->txt); // msg

				write(cMsg, cp - cMsg);
				break;

			case MSGID_GUILDSMANCHANGE:
				Push(cp, (uint8_t)iV1);
				memset(cp, 0, 10);
				strcpy(cp, pString);
				cp += 10;
				write(cMsg, cp - cMsg);
				break;

			case MSGID_GUILDUPGRADE:
				Push(cp, (uint8_t)iV1);
				write(cMsg, cp - cMsg);
				break;

			case MSGID_GUILDCONTRIBUTE:
				Push(cp, (uint8_t)iV1);
				Push(cp, (uint32_t)iV2);
				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQUEST_GUILDBANK:
				Push(cp, m_guildBankVer);
				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQUEST_ANGEL:	// to Game Server
				cp = (char *)(cMsg + 6);
				memset(cp, 0, 20);
				memcpy((char *)cp, pString, strlen(pString) + 1);
				cp += 20;
				ip = (int *)cp;
				*ip = iV1; // Angel ID
				write(cMsg, 30);
				break;

			case MSGID_REQUEST_DKITEM:	// to Game Server
				cp = (char *)(cMsg + 6);
				memset(cp, 0, 20);
				memcpy((char *)cp, pString, strlen(pString) + 1);
				cp += 20;
				ip = (int *)cp;
				*ip = iV1; // DK Item ID
				write(cMsg, 30);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_YES: // By snoopy
			case MSGID_REQUEST_RESURRECTPLAYER_NO:  // By snoopy
			case MSGID_REQUEST_CRITICALS: // CTRL + C Criticals xRisenx
				write(cMsg, 6);
				break;

			case MSGID_REQUEST_HELDENIAN_SCROLL:// By snoopy
				cp = (char *)(cMsg + 6);
				memset(cp, 0, 20);
				memcpy((char *)cp, pString, strlen(pString) + 1);
				cp += 20;
				wp = (uint16_t *)cp;
				*wp = wCommand; // Item ID
				write(cMsg, 28);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:
				cp = (char *)(cMsg + 6);
				memset(cp, 0, 20);
				strcpy(cp, pString);
				write(cMsg, 26);
				break;

			case MSGID_REQUEST_QUEST_LIST:
				cp = (char *)(cMsg + 6);
				memset(cp, 0, 20);
				strcpy(cp, pString);
				write(cMsg, 26);
				break;

			case MSGID_REQUEST_CHARGED_TELEPORT:
				ip = (int *)(cMsg + INDEX2_MSGTYPE + 2);
				*ip = iV1;
				write(cMsg, 10);
				break;

			case MSGID_REQUEST_ACCEPT_QUEST:
				ip = (int *)(cMsg + INDEX2_MSGTYPE + 2);
				*ip = iV1;
				write(cMsg, 10);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				for (i = 0; i < MAXSELLLIST; i++)
				{
					*cp = m_stSellItemList[i].iIndex;
					cp++;
					ip = (int *)cp;
					*ip = m_stSellItemList[i].iAmount;
					cp += 4;
				}

				write(cMsg, 70);
				break;

			case MSGID_REQUEST_RESTART:
				write(cMsg, 6);
				break;

			case MSGID_REQUEST_PANNING:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				*cp = cDir;
				cp++;

				write(cMsg, 7);
				break;

			case MSGID_REQUEST_SETITEMPOS:
				// to Game Server
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);

				*cp = cDir;

				cp++;

				sp = (short *)cp;
				*sp = (short)iV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)iV2;
				cp += 2;

				write(cMsg, 11);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				sw.WriteInt64(dwTime);
				write(sw);

				break;

            case MSGID_REQUEST_INITDATA:
            case MSGID_REQUEST_INITPLAYER:
                // to Game Server
                sw.WriteString(player_name, 10);
                sw.WriteByte(m_bIsObserverMode);
                sw.WriteString(m_cGameServerName, 20);

                write(sw);

                //m_bIsObserverMode = FALSE;
                break;

			case MSGID_LEVELUPSETTINGS:
				// CLEROTH
				//if ((m_luStat[STAT_STR] + m_luStat[STAT_VIT] + m_luStat[STAT_DEX] + m_luStat[STAT_INT] + m_luStat[STAT_MAG] + m_luStat[STAT_CHR]) > 3) return FALSE;

				/*dwp = (DWORD *)(cMsg + INDEX4_MSGID);
				*dwp = dwMsgID;

				wp = (WORD *)(cMsg + INDEX2_MSGTYPE);
				*wp = NULL;*/


				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);

				//			ip = (int *)cp; 
				//			m_luStat[STAT_STR] = *ip;
				//			cp += 4;
				//
				//			ip = (int *)cp; 
				//			m_luStat[STAT_VIT] = *ip;
				//			cp += 4;
				//
				//			ip = (int *)cp; 
				//			m_luStat[STAT_DEX] = *ip;
				//			cp += 4;
				//
				//			ip = (int *)cp; 
				//			m_luStat[STAT_INT] = *ip;
				//			cp += 4;
				//
				//			ip = (int *)cp; 
				//			m_luStat[STAT_MAG] = *ip;
				//			cp += 4;
				//
				//			ip = (int *)cp; 
				//			m_luStat[STAT_CHR] = *ip;
				//			cp += 4;

				* cp = m_luStat[STAT_STR];
				cp += 2;

				*cp = m_luStat[STAT_VIT];
				cp += 2;

				*cp = m_luStat[STAT_DEX];
				cp += 2;

				*cp = m_luStat[STAT_INT];
				cp += 2;

				*cp = m_luStat[STAT_MAG];
				cp += 2;

				*cp = m_luStat[STAT_CHR];
				cp += 2;

				write(cMsg, 18); //12->18
				break;

            case MSGID_COMMAND_CHATMSG:
                if (m_bIsTeleportRequested == true)
                    return false;

                if (bCheckLocalChatCommand(pString) == true)
                    return false;

                sw.WriteShort(m_sPlayerX);
                sw.WriteShort(m_sPlayerY);
                sw.WriteString(player_name);
                sw.WriteString(string(pString));

                write(sw);
                break;

			case MSGID_COMMAND_COMMON:
				if (m_bIsTeleportRequested == true) return false;
				*wp = wCommand;

				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				sp = (short *)cp;
				*sp = m_sPlayerX;
				cp += 2;
				sp = (short *)cp;
				*sp = m_sPlayerY;
				cp += 2;
				*cp = cDir;
				cp++;
				switch (wCommand)
				{
					case COMMONTYPE_BUILDITEM:
						memcpy(cp, pString, 20);
						cp += 20;
						*cp = (char)m_dialogBoxes[26].sV1;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV2;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV3;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV4;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV5;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV6;
						cp++;
						write(cMsg, 37);
						break;

					case COMMONTYPE_REQ_CREATEPOTION:
						*cp = (char)m_dialogBoxes[26].sV1;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV2;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV3;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV4;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV5;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV6;
						cp++;
						write(cMsg, 18);
						break;

						//Crafting
					case COMMONTYPE_CRAFTITEM:
						memcpy(cp, "                    ", 20);
						cp += 20;
						*cp = (char)m_dialogBoxes[26].sV1;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV2;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV3;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV4;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV5;
						cp++;
						*cp = (char)m_dialogBoxes[26].sV6;
						cp++;
						write(cMsg, 37);
						break;

						// Create Slate Request - Diuuude
					case COMMONTYPE_REQ_CREATESLATE:
						*cp = (char)m_dialogBoxes[40].sV1;
						cp++;
						*cp = (char)m_dialogBoxes[40].sV2;
						cp++;
						*cp = (char)m_dialogBoxes[40].sV3;
						cp++;
						*cp = (char)m_dialogBoxes[40].sV4;
						cp++;
						*cp = (char)m_dialogBoxes[40].sV5;
						cp++;
						*cp = (char)m_dialogBoxes[40].sV6;
						cp++;
						write(cMsg, 18);
						break;

					default:
						if (pString == 0)
						{
							ip = (int *)cp;
							*ip = iV1;
							cp += 4;
							ip = (int *)cp;
							*ip = iV2;
							cp += 4;
							ip = (int *)cp;
							*ip = iV3;
							cp += 4;
							dwp = (uint32_t *)cp;
							*dwp = dwTime;
							cp += 4;
							write(cMsg, 23 + 4);
						}
						else
						{
							ip = (int *)cp;
							*ip = iV1;
							cp += 4;
							ip = (int *)cp;
							*ip = iV2;
							cp += 4;
							ip = (int *)cp;
							*ip = iV3;
							cp += 4;
							memcpy(cp, pString, 30);
							cp += 30;
							ip = (int *)cp;
							*ip = iV4;
							cp += 4;
							write(cMsg, 23 + 34);
						}
						break;
				}

				break;

			case MSGID_REQUEST_CREATENEWGUILD:
			case MSGID_REQUEST_DISBANDGUILD:
// 				// to Game Server
// 				*wp = MSGTYPE_CONFIRM;
// 
// 				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
// 
// 				memset(cTxt, 0, sizeof(cTxt));
// 				memcpy(cTxt, m_cPlayerName, 10);
// 				memcpy(cp, cTxt, 10);
// 				cp += 10;
// 
// 				memset(cTxt, 0, sizeof(cTxt));
// 				memcpy(cTxt, m_cAccountName, 10);
// 				memcpy(cp, cTxt, 10);
// 				cp += 10;
// 
// 				memset(cTxt, 0, sizeof(cTxt));
// 				memcpy(cTxt, m_cAccountPassword, 10);
// 				memcpy(cp, cTxt, 10);
// 				cp += 10;
// 				char cTemp[21];
// 				memset(cTemp, 0, sizeof(cTemp));
// 				memcpy(cTemp, m_cGuildName, 20);
// 				m_Misc.ReplaceString(cTemp, ' ', '_');
// 				memcpy(cp, cTemp, 20);
// 				cp += 20;
// 
// 				write(cMsg, 56);
				break;

			case MSGID_REQUEST_TELEPORT:
				*wp = MSGTYPE_CONFIRM;

				write(cMsg, 6);

				m_bIsTeleportRequested = true;
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				*wp = MSGTYPE_CONFIRM;

				write(cMsg, 6);
				break;

			case MSGID_REQGUILDSUMMONS:
				cp = (char *)(cMsg + INDEX2_MSGTYPE);
				Push(cp, (char *)pString, 10);

				write(cMsg, cp - cMsg);
				break;

			case MSGID_RSPGUILDSUMMONS:
				cp = (char *)(cMsg + INDEX2_MSGTYPE);
				Push(cp, (uint8_t)iV1);

				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQUEST_RETRIEVEITEM_GUILDBANK:
				cp = (char *)(cMsg + INDEX2_MSGTYPE);
				Push(cp, (uint32_t)iV1);

				write(cMsg, cp - cMsg);
				break;

			case MSGID_REQUEST_RETRIEVEITEM:
				*wp = MSGTYPE_CONFIRM;

				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				*cp = (char)iV1;

				write(cMsg, 7);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				ip = (int *)cp;
				*ip = iV1;
				cp += 4;

				write(cMsg, 10);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				fightzonenum = (int *)cp;
				*fightzonenum = iV1;
				cp += 4;

				write(cMsg, 10);
				break;

			case MSGID_STATECHANGEPOINT:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);

				Push(cp, (uint16_t)-m_luStat[STAT_STR]);
				Push(cp, (uint16_t)-m_luStat[STAT_VIT]);
				Push(cp, (uint16_t)-m_luStat[STAT_DEX]);
				Push(cp, (uint16_t)-m_luStat[STAT_INT]);
				Push(cp, (uint16_t)-m_luStat[STAT_MAG]);
				Push(cp, (uint16_t)-m_luStat[STAT_CHR]);

				write(cMsg, cp - cMsg);
				break;

#ifdef TitleClient
			case MSGID_SETTITLE:
				//BESK in our client - send 4byte integer instead of 21 byte char array
				dwp = (uint32_t *)(cMsg + INDEX4_MSGID);
				*dwp = dwMsgID;
				wp = (uint16_t *)(cMsg + INDEX2_MSGTYPE);
				*wp = 0;
				cp = (char *)(cMsg + 6);
				//memset( cp, 0, 21 );
				//memcpy((char *)cp, pString, strlen(pString) + 1);
				//cp += 21;
				ip = (int *)cp;
				*ip = iV1;
				cp += 4;

				write(cMsg, 10/*31*/);//BESK NOTE: we are sending cKey here...
				break;
#endif

			case MSGID_REQUEST_UPDATE_FRIENDS:
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);

				memcpy((char *)cp, pString, strlen(pString) + 1);

				write(cMsg, 6 + strlen(pString));
				break;

			case MSGID_REQUEST_LGNPTS:
			case MSGID_REQUEST_LGNSVC:

				*wp = wCommand;

				write(cMsg, 6);
				break;

			case MSGID_REQUEST_SETRECALLPNT:
				dwp = (uint32_t *)(cMsg + INDEX4_MSGID);
				*dwp = dwMsgID;
				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
				*cp = (char)iV1;

				write(cMsg, 7);
				break;

			default:
				if (m_bIsTeleportRequested == true) return false;

				*wp = wCommand;

				cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);

				sp = (short *)cp;
				*sp = m_sPlayerX;
				cp += 2;

				sp = (short *)cp;
				*sp = m_sPlayerY;
				cp += 2;

				*cp = cDir;
				cp++;

				sp = (short *)cp;
				*sp = (short)iV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)iV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)iV3;
				cp += 2;

				if (wCommand == OBJECTATTACK || wCommand == OBJECTATTACKMOVE)
				{
					sp = (short *)cp;
					*sp = (short)iV4;
					cp += 2;
					dwp = (uint32_t *)cp;
					*dwp = dwTime;
					cp += 4;

					write(cMsg, 19 + 4);
				}
				else
				{
					dwp = (uint32_t *)cp;
					*dwp = dwTime;
					cp += 4;
					write(cMsg, 17 + 4);
				}

				m_cCommandCount++;
				break;
		}
	}

	return true;
}

bool helbreath::GameRecvMsgHandler(char * pData, uint32_t dwMsgSize)
{
	uint32_t * dwpMsgID;
	dwpMsgID = (uint32_t *)(pData + INDEX4_MSGID);

	if (*dwpMsgID & MSGIDTYPE_MOTION)
	{
		MotionEventHandler(pData);
		return true;
	}


	uint8_t v;

	switch (*dwpMsgID)
	{
		case MSGID_MODIFYTILE:
			ReceiveModifyTile(pData);
            return true;

		case MSGID_RESPONSE_CHARGED_TELEPORT:
			ResponseChargedTeleport(pData);
            return true;

		case MSGID_RESPONSE_TELEPORT_LIST:
			ResponseTeleportList(pData);
            return true;

		case MSGID_RESPONSE_QUEST_LIST:
			ResponseQuestList(pData);
            return true;

		case MSGID_RESPONSE_NOTICEMENT:
			NoticementHandler(pData);
            return true;

		case MSGID_DYNAMICOBJECT:
			DynamicObjectHandler(pData);
            return true;

		case MSGID_RESPONSE_INITPLAYER:
			InitPlayerResponseHandler(pData);
            return true;

		case MSGID_RESPONSE_INITDATA:
			InitDataResponseHandler(pData);
            return true;

		case MSGID_RESPONSE_MOTION:
			MotionResponseHandler(pData);
            return true;

		case MSGID_EVENT_COMMON:
			CommonEventHandler(pData);
            return true;

		case MSGID_COMMAND_CHATMSG:
			ChatMsgHandler(pData);
            return true;

		case MSGID_PLAYERITEMLISTCONTENTS:
			InitItemList(pData);
            return true;

		case MSGID_GUILDINFO:
			ReceiveGuildInfo(pData + 4);
            return true;

		case MSGID_GUILDSMANSTATUS:
			ReceiveGuildsmanStatus(pData + 4);
            return true;

		case MSGID_REQGUILDSUMMONS:
			pData += 4;
			Pop(pData, (uint8_t &)v);
			EnableDialogBox(49, 0, v, 0);
            return true;

		case MSGID_RESPONSE_GUILDBANK:
			InitItemList_GuildBank(pData + 4);
            return true;

		case MSGID_RSP_GUILDBOARD:
			ReceiveGuildBoard(pData + 8);
            return true;

		case MSGID_RSP_MAILBOX:
			ReceiveMailbox(pData + 8);
            return true;

		case MSGID_RSP_MAILDATA:
			ReceiveMailData(pData + 12);
            return true;

		case MSGID_RSP_GUILDBOARDPOST:
			ReceiveGuildBoardPost(pData + 8);
            return true;

		case MSGID_RSP_RETRIEVEMAILITEM:
			m_mails[m_dialogBoxes[DIALOG_MAILBOX].sV1]->
				items.erase(m_mails[m_dialogBoxes[DIALOG_MAILBOX].sV1]->items.begin() + m_dialogBoxes[DIALOG_MAILBOX].sV2);

			if (m_mails[m_dialogBoxes[DIALOG_MAILBOX].sV1]->items.size() == 0)
				m_dialogBoxes[DIALOG_MAILBOX].SetMode(2);
			else
				m_dialogBoxes[DIALOG_MAILBOX].SetMode(4);
            return true;

		case MSGID_RSP_SENDMAIL:
			m_dialogBoxes[DIALOG_MAILBOX].bFlag = false;

			if (*(uint16_t *)(pData + 4) == MSGTYPE_CONFIRM)
			{
				AddEventList(NOTIFY_MSG_HANDLER80, CHAT_GM);

				std::vector<MailItemSend> & vvec = m_dialogBoxes[DIALOG_MAILBOX].vvec;
				for (std::vector<MailItemSend>::iterator it = vvec.begin();
					it != vvec.end();
					++it)
				{
					int index = (*it).index;
					int count = (*it).count;

					m_bIsItemDisabled[index] = false;
					m_pItemList[index]->m_dwCount -= count;

					if (m_pItemList[index]->m_dwCount == 0)
					{
						if (m_bIsItemEquipped[index])
						{
							m_sItemEquipmentStatus[m_pItemList[index]->m_cEquipPos] = -1;
							m_bIsItemEquipped[index] = false;
						}
						EraseItem(index);
					}
				}

				_iCalcTotalWeight();

				m_dialogBoxes[DIALOG_MAILBOX].SetMode(0);
			}
			else
			{
				fmt::format_to(G_cTxt, NOTIFY_MSG_HANDLER81, m_dialogBoxes[62].cStr);
				AddEventList(G_cTxt, CHAT_GM);
			}
            return true;

		case MSGID_NOTIFY:
			NotifyMsgHandler(pData);
            return true;

		case MSGID_RESPONSE_CREATENEWGUILD:
			CreateNewGuildResponseHandler(pData);
            return true;

		case MSGID_RESPONSE_DISBANDGUILD:
			DisbandGuildResponseHandler(pData);
            return true;

		case MSGID_PLAYERCHARACTERCONTENTS:
			InitPlayerCharacteristics(pData);
            return true;

		case MSGID_RESPONSE_CIVILRIGHT:
			CivilRightAdmissionHandler(pData);
            return true;

		case MSGID_RESPONSE_RETRIEVEITEM:
			RetrieveItemHandler(pData);
            return true;

		case MSGID_RESPONSE_RETRIEVEITEM_GUILDBANK:
			RetrieveItemHandler_GuildBank(pData + 4);
            return true;

		case MSGID_RESPONSE_PANNING:
			ResponsePanningHandler(pData);
            return true;

		case MSGID_RESPONSE_FIGHTZONE_RESERVE:
			ReserveFightzoneResponseHandler(pData);
            return true;
	}
    return false;
}

void helbreath::ConnectionEstablishHandler(char cWhere)
{
	ChangeGameMode(GAMEMODE_ONWAITINGRESPONSE);

	switch (cWhere)
	{
		case SERVERTYPE_GAME:
			bSendCommand(MSGID_REQUEST_INITPLAYER);
			break;

		case SERVERTYPE_LOG:
			switch (m_dwConnectMode)
			{
				case MSGID_REQUEST_LOGIN:
					SendLoginCommand(MSGID_REQUEST_LOGIN);
					break;
				case MSGID_REQUEST_CREATENEWACCOUNT:
					SendLoginCommand(MSGID_REQUEST_CREATENEWACCOUNT);
					break;
				case MSGID_REQUEST_CREATENEWCHARACTER:
					SendLoginCommand(MSGID_REQUEST_CREATENEWCHARACTER);
					break;
				case MSGID_REQUEST_ENTERGAME:
					SendLoginCommand(MSGID_REQUEST_ENTERGAME);
					break;
				case MSGID_REQUEST_DELETECHARACTER:
					SendLoginCommand(MSGID_REQUEST_DELETECHARACTER);
					break;
				case MSGID_REQUEST_CHANGEPASSWORD:
					SendLoginCommand(MSGID_REQUEST_CHANGEPASSWORD);
					break;
				case MSGID_REQUEST_INPUTKEYCODE:
					SendLoginCommand(MSGID_REQUEST_INPUTKEYCODE);
					break;
			}
			break;
	}
}

void helbreath::InitPlayerResponseHandler(char * pData)
{
	uint16_t * wp;
	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	switch (*wp)
	{
		case MSGTYPE_CONFIRM:
			//bSendCommand(MSGID_REQUEST_INITDATA);
			LoadMuteList();
			ChangeGameMode(GAMEMODE_ONWAITINGINITDATA);
			break;

		case MSGTYPE_REJECT:
			ChangeGameMode(GAMEMODE_ONLOGRESMSG);
			memset(m_cMsg, 0, sizeof(m_cMsg));
			strcpy(m_cMsg, "3J");
			break;
	}
}

void helbreath::OnTimer()
{
    // only proceed if gamemode is not null or onquit
    if (m_cGameMode < 0)
        return;
    uint64_t dwTime = unixtime();

    {
        std::lock_guard<std::mutex> lock(socketmut);
        while (loginpipe.size() > 0)
        {
            shared_ptr<helbreath::MsgQueueEntry> entry = GetLoginMsgQueue();
            LogResponseHandler(entry->data, entry->size);
        }

//         while (socketpipe.size() > 0)
//         {
//             shared_ptr<helbreath::MsgQueueEntry> entry = GetMsgQueue();
//             GameRecvMsgHandler(entry->data, entry->size);
//         }
    }

    if (m_cGameMode != GAMEMODE_ONLOADING)
    {
        if (((int64_t)dwTime - m_dwCheckSprTime) > 8000)
        {
            m_dwCheckSprTime = dwTime;
            if (m_bIsProgramActive)
                ReleaseUnusedSprites();
            if (is_connected() && loggedin)
                bSendCommand(MSGID_COMMAND_CHECKCONNECTION, MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
        }
    }

    if (m_cGameMode == GAMEMODE_ONMAINGAME)
    {
        if ((dwTime - m_dwCheckConnTime) > 5000)
        {
            m_dwCheckConnTime = dwTime;
            if ((m_bIsCrusadeMode) && (m_iCrusadeDuty == 0))
                EnableDialogBox(33, 1, 0, 0);
        }

        if (m_ekSSTime != 0 && dwTime > m_ekSSTime)
        {
            m_ekSSTime = 0;
            CreateScreenShot();
        }

        if ((dwTime - m_dwCheckChatTime) > 2000)
        {
            m_dwCheckChatTime = dwTime;
            ReleaseTimeoverChatMsg();
            if (m_cCommandCount >= 6)
            {
                m_iNetLagCount++;
                if (m_iNetLagCount >= 7)
                {
                    ChangeGameMode(GAMEMODE_ONCONNECTIONLOST);
                    socketmode(0);
                    close(1000, "netlagcount");
                    return;
                }
            }
            else
                m_iNetLagCount = 0;
        }
    }
}

void helbreath::CommonEventHandler(char * pData)
{
	uint16_t * wp, wEventType;
	short * sp, sX, sY, sV1, sV2, sV3, sV4;
	char * cp;

	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	wEventType = *wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV2 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV3 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV4 = *sp;
	cp += 2;

	switch (wEventType)
	{
		case COMMONTYPE_ITEMDROP:
			if ((sV1 == 6) && (sV2 == 0))
			{
				bAddNewEffect(4, sX, sY, 0, 0, 0);
			}
			m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3); // 1234 Added NULL LIEs.. wrong!
			break;

		case COMMONTYPE_SETITEM:
			m_pMapData->bSetItem(sX, sY, sV1, sV2, (char)sV3, false);
			break;

		case COMMONTYPE_MAGIC:
			bAddNewEffect(sV3, sX, sY, sV1, sV2, 0, sV4);
			break;

		case COMMONTYPE_CLEARGUILDNAME:
			ClearGuildNameList();
			break;
	}
}

void helbreath::ClearGuildNameList()
{
	for (int i = 0; i < MAXGUILDNAMES; i++)
	{
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}
}

void helbreath::InitGameSettings()
{
	int i;

	m_bHackMoveBlocked = false; // Anti Hack xRisenx

	m_adminLevel = 0;
	m_GMFlags = 0;
	m_eventPot = -1;

	m_bIllusionMVT = false;
	m_bForceAttack = false;
	m_dwCommandTime = 0;

	m_bInputStatus = false;
	m_pInputBuffer = 0;

	m_iPDBGSdivX = 0;
	m_iPDBGSdivY = 0;
	m_bIsRedrawPDBGS = true;

	m_iCameraShakingDegree = 0;

	m_cCommand = OBJECTSTOP;
	m_cCommandCount = 0;

	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1;

	m_bIsCombatMode = false;
	m_bRunningMode = false;

	m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
	m_stMCursor.dwSelectClickTime = 0;

	m_bSkillUsingStatus = false;
	m_bItemUsingStatus = false;
	m_bUsingSlate = false;

	m_weather = WEATHER_SUNNY;

	m_iDownSkillIndex = -1;
	m_dialogBoxes[15].bFlag = false;

	m_bIsConfusion = false;

	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;

	m_iDrawFlag = 0;
	m_bDrawFlagDir = false;
	m_bIsAstoriaMode = false;
	m_relicOwnedTime = 0;
	for (int i = 0; i < MAXSIDES; i++)
	{
		m_astoriaStats[i].deaths = 0;
		m_astoriaStats[i].kills = 0;
	}
	for (int i = 0; i < MAXSIDES; i++)
	{
		m_astoriaShieldsHP[i] = 0;
		m_astoriaShieldsHP[i] = 0;
	}
	m_bIsCrusadeMode = false;
	m_iCrusadeDuty = 0;
	m_bIsAvatarMode = false;
	m_bIsAvatarMessenger = false;

	m_iNetLagCount = 0;

	m_dwEnvEffectTime = unixtime();

	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		memset(m_stGuildName[i].cCharName, 0, sizeof(m_stGuildName[i].cCharName));
		memset(m_stGuildName[i].cGuildName, 0, sizeof(m_stGuildName[i].cGuildName));
	}

	m_guildBankVer = 0;

#ifdef TitleClient
	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		m_stTitles[i].dwRefTime = 0;
		m_stTitles[i].iCurrentNo = -1;
		m_stTitles[i].iRank = 0;
		memset(m_stTitles[i].cCharName, 0, sizeof(m_stTitles[i].cCharName));
		memset(m_stTitles[i].cSubject, 0, sizeof(m_stTitles[i].cSubject));
		strcpy(m_stTitles[i].cCharName, "NONE");
		strcpy(m_stTitles[i].cSubject, "NONE");
	}
	for (i = 0; i < MAXMENUITEMS; i++)
	{
		if (m_pTitles[i] != 0) delete m_pTitles[i];
		m_pTitles[i] = 0;
	}
	m_iTitleIndex = -1;
#endif

	//Snoopy: 61
	for (i = 0; i < MAXDIALOGBOX; i++)
		m_bIsDialogEnabled[i] = false;

	for (i = 0; i < MAXDIALOGBOX - 2; i++)
		m_cDialogBoxOrder[i] = 0;

	for (i = 0; i < MAXEFFECTS; i++)
	{
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];
		m_pEffectList[i] = 0;
	}

	for (i = 0; i < MAXCHATMSGS; i++)
	{
		if (m_pChatMsgList[i])
		{
			delete m_pChatMsgList[i];
		}
		m_pChatMsgList[i] = 0;
	}

	for (int i = 0; i < CHAT_MAX; i++)
	{
		for (std::vector<CMsg *>::iterator it = m_chatMsgs[i].begin();
			it != m_chatMsgs[i].end();
			++it)
		{
			delete (*it);
		}
		m_chatMsgs[i].clear();
	}
	if (m_chatDisplay)
		delete m_chatDisplay;

	m_chatDisplay = new std::vector<CMsg *>;

	for (int i = 0; i < CHAT_MAX; i++)
	{
		m_chatToggle[i] = true;
	}

	for (i = 0; i < MAXWHISPERMSG; i++)
	{
		if (m_pWhisperMsg[i] != 0) delete m_pWhisperMsg[i];
		m_pWhisperMsg[i] = 0;
	}

	ZeroMemory(m_cLocation, sizeof(m_cLocation));

	ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
	m_iGuildRank = GUILDRANK_NONE;
	m_iTotalGuildsMan = 0;
	m_guild.Reset();

	for (i = 0; i < 100; i++)
	{
		m_stGuildOpList[i].cOpMode = 0;
		ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
	}

	for (i = 0; i < 6; i++)
	{
		ZeroMemory(m_stEventHistory[i].cTxt, sizeof(m_stEventHistory[i].cTxt));
		m_stEventHistory[i].dwTime = G_dwGlobalTime;

		ZeroMemory(m_stEventHistory2[i].cTxt, sizeof(m_stEventHistory2[i].cTxt));
		m_stEventHistory2[i].dwTime = G_dwGlobalTime;
	}

	for (i = 0; i < MAXMENUITEMS; i++)
	{
		if (m_pItemForSaleList[i] != 0) delete m_pItemForSaleList[i];
		m_pItemForSaleList[i] = 0;
	}

	for (i = 0; i < MAXITEMSTATS; i++)
	{
		if (m_pBuildItemListStats[i] != 0) delete m_pBuildItemListStats[i];
		m_pBuildItemListStats[i] = 0;
	}

	for (i = 0; i < 61; i++)
	{
		m_dialogBoxes[i].bFlag = false;
		m_dialogBoxes[i].sView = 0;
		m_dialogBoxes[i].bIsScrollSelected = false;
	}

	for (i = 0; i < MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < MAXSELLLIST; i++)
	{
		m_stSellItemList[i].iIndex = -1;
		m_stSellItemList[i].iAmount = 0;
	}

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	m_mails.clear();
	m_gldBoard.clear();

	m_guildBankMap.clear();
	m_guildBankIt = m_guildBankMap.end();

	for (i = 0; i < MAXMAGICTYPE; i++)
		m_cMagicMastery[i] = 0;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_cSkillMastery[i] = 0;

	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;

		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;

		if (m_pAgreeMsgTextList[i] != 0)
			delete m_pAgreeMsgTextList[i];
		m_pAgreeMsgTextList[i] = 0;
	}

	ClearPartyMembers();
	m_stPartyMember.reserve(MAXPARTYMEMBERS);

	m_iLU_Point = 0;
	m_luStat[STAT_STR] = m_luStat[STAT_VIT] = m_luStat[STAT_DEX] = m_luStat[STAT_INT] = m_luStat[STAT_MAG] = m_luStat[STAT_CHR] = 0;
	m_bDialogTrans = false;
	m_cLogOutCount = -1;
	m_dwLogOutCountTime = 0;
	m_iSuperAttackLeft = 0;
	m_bSuperAttackMode = false;
	m_iFightzoneNumber = 0;
	ZeroMemory(m_cBGMmapName, sizeof(m_cBGMmapName));
	m_dwWOFtime = 0;
	m_stQuest.sWho = 0;
	m_stQuest.sQuestType = 0;
	m_stQuest.sContribution = 0;
	m_stQuest.sTargetType = 0;
	m_stQuest.sTargetCount = 0;
	m_stQuest.sCurrentCount = 0;
	m_stQuest.sX = 0;
	m_stQuest.sY = 0;
	m_stQuest.sRange = 0;
	m_stQuest.bIsQuestCompleted = false;
	ZeroMemory(m_stQuest.cTargetName, sizeof(m_stQuest.cTargetName));
	m_bIsObserverMode = false;
	m_bIsObserverCommanded = false;
	m_bIsPoisoned = false;
	m_bIsPrevMoveBlocked = false;
	m_iPrevMoveX = m_iPrevMoveY = -1;
	m_sDamageMove = 0;
#ifdef RaiseCriticalLimit
	m_iDamageMoveAmount = 0; // Removed Critical Limit xRisenx
#else
	m_sDamageMoveAmount = 0;
#endif
	m_bForceDisconn = false;
	m_bIsSpecialAbilityEnabled = false;
	m_iSpecialAbilityType = 0;
	m_dwSpecialAbilitySettingTime = 0;
	m_iSpecialAbilityTimeLeftSec = 0;
	m_stMCursor.cSelectedObjectType = 0;
	m_bIsF1HelpWindowEnabled = false;
	m_bIsTeleportRequested = false;
	for (i = 0; i < MAXCRUSADESTRUCTURES; i++)
	{
		m_stCrusadeStructureInfo[i].cType = 0;
		m_stCrusadeStructureInfo[i].cSide = 0;
		m_stCrusadeStructureInfo[i].sX = 0;
		m_stCrusadeStructureInfo[i].sY = 0;
	}
	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));
	m_dwCommanderCommandRequestedTime = 0;
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	m_iTopMsgLastSec = 0;
	m_dwTopMsgTime = 0;
	m_iConstructionPoint = 0;
	m_iWarContribution = 0;
	ZeroMemory(m_cTeleportMapName, sizeof(m_cTeleportMapName));
	m_iTeleportLocX = m_iTeleportLocY = -1;
	ZeroMemory(m_cConstructMapName, sizeof(m_cConstructMapName));
	m_iConstructLocX = m_iConstructLocY = -1;

	//Snoopy: Apocalypse Gate
	ZeroMemory(m_cGateMapName, sizeof(m_cGateMapName));
	m_iGatePositX = m_iGatePositY = -1;

	m_bIsHeldenianMode = false;
	m_bIsHeldenianMap = false;
	m_iHeldenianAresdenLeftTower = -1;
	m_iHeldenianElvineLeftTower = -1;
	m_iHeldenianAresdenFlags = -1;
	m_iHeldenianElvineFlags = -1;
	m_iHeldenianAresdenDead = -1;
	m_iHeldenianElvineDead = -1;
	m_iHeldenianAresdenKill = -1;

	m_iPartyStatus = 0;

	m_iGizonItemUpgradeLeft = 0;
	// Stats System xRisenx
	/*for (i=0; i<TOTALLEVELUPPOINT; i++) {
		m_cStatChange[i] =0;
	}*/

	EnableDialogBox(9, 0, 0, 0);

	m_bSoccerMode = false;
	m_SoccerAresdenGoals = 0;
	m_SoccerElvineGoals = 0;
}

/*
void CGame::_GetHairColorRGB(int iColorType, int * pR, int * pG, int * pB)
{	switch (iColorType) {
	case 0: // rouge fonc
		*pR = 14; *pG = -5; *pB = -5; break;
	case 1: // Orange
		*pR = 20; *pG = 0; *pB = 0; break;
	case 2: // marron tres clair
		*pR = 22; *pG = 13; *pB = -10; break;
	case 3:
		*pR = 0; *pG = 10; *pB = 0; break;
	case 4: // Bleu flashy
		*pR = 0; *pG = 0; *pB = 22; break;
	case 5: // Bleu fonc
		*pR = -5; *pG = -5; *pB = 15; break;
	case 6: //Mauve
		*pR = 15; *pG = -5; *pB = 16; break;
	case 7: // Noir
		*pR = -6; *pG = -6; *pB = -6; break;
	case 8:
		*pR = 10; *pG = 3; *pB = 10; break;
	case 9:
		*pR = 10; *pG = 3; *pB = -10; break;
	case 10:
		*pR = -10; *pG = 3; *pB = 10; break;
	case 11:
		*pR = 10; *pG = 3; *pB = 20; break;
	case 12:
		*pR = 21; *pG = 3; *pB = 3; break;
	case 13:
		*pR = 3; *pG = 3; *pB = 25; break;
	case 14:
		*pR = 3; *pG = 11; *pB = 3; break;
	case 15:
		*pR = 6; *pG = 8; *pB = 0; break;
	}
}*/
void helbreath::_GetHairColorRGB(int iColorType, int * pR, int * pG, int * pB)
{
	switch (iColorType)
	{
		case 0: // rouge fonc
			*pR = 14; *pG = -5; *pB = -5; break;
		case 1: // Orange
			*pR = 20; *pG = 0; *pB = 0; break;
		case 2: // marron tres clair
			*pR = 22; *pG = 13; *pB = -10; break;
		case 3:
			*pR = 0; *pG = 10; *pB = 0; break;
		case 4: // Bleu flashy
			*pR = 0; *pG = 0; *pB = 22; break;
		case 5: // Bleu fonc
			*pR = -5; *pG = -5; *pB = 15; break;
		case 6: //Mauve
			*pR = 15; *pG = -5; *pB = 16; break;
		case 7: // Noir
			*pR = -6; *pG = -6; *pB = -6; break;
		case 8:
			*pR = 10; *pG = 3; *pB = 10; break;
		case 9:
			*pR = 10; *pG = 3; *pB = -10; break;
		case 10:
			*pR = -10; *pG = 3; *pB = 10; break;
		case 11:
			*pR = 10; *pG = 3; *pB = 20; break;
		case 12:
			*pR = 21; *pG = 3; *pB = 3; break;
		case 13:
			*pR = 3; *pG = 3; *pB = 25; break;
		case 14:
			*pR = 3; *pG = 11; *pB = 3; break;
		case 15:
			*pR = 6; *pG = 8; *pB = 0; break;
	}
}

void helbreath::DlgBoxClick_GuildMenu()
{
	short sX, sY;
	char cTemp[21];

	char onButton = m_dialogBoxes[7].OnButton();
	sX = m_dialogBoxes[7].m_X;
	sY = m_dialogBoxes[7].m_Y;


	switch (m_dialogBoxes[7].GetMode())
	{
		case 0:
			switch (onButton)
			{
				case 1:
					if (m_iGuildRank != GUILDRANK_NONE) return;
					//if (m_stat[STAT_CHR] < 20) return;
					if (m_iLevel < 100) return; // Guild Req xRisenx
					if (m_bIsCrusadeMode) return;
					EndInputString();
					StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
					m_dialogBoxes[7].SetMode(1);
					break;
				case 2:
					if (m_iGuildRank != GUILDRANK_MASTER) return;
					if (m_bIsCrusadeMode) return;
					m_dialogBoxes[7].SetMode(5);
					break;
				case 3:
					m_dialogBoxes[7].SetMode(9);
					break;
				case 4:
					m_dialogBoxes[7].SetMode(11);
					break;
				case 5:
					if (m_iFightzoneNumber < 0) break;
					if (m_iGuildRank != GUILDRANK_MASTER) return;
					if (m_iFightzoneNumber == 0) m_dialogBoxes[7].SetMode(13);
					else  m_dialogBoxes[7].SetMode(19);
					break;
			}
			break;
		case 1:
			switch (onButton)
			{
				case 1:// Submit
					if (strcmp(m_cGuildName, "NONE") == 0) return;
					if (strlen(m_cGuildName) == 0) return;
					bSendCommand(MSGID_REQUEST_CREATENEWGUILD, MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
					m_dialogBoxes[7].SetMode(2);
					EndInputString();
					break;
				case 2:	// Cancel
					m_dialogBoxes[7].SetMode(0);
					EndInputString();
					break;
			}
			break;
		case 3:
		case 4:
		case 7:
		case 8:
		case 10:
		case 12:
			switch (onButton)
			{
				case 1:
					m_dialogBoxes[7].SetMode(0);
					break;
			}
			break;

		case 9:
			switch (onButton)
			{
				case 1:
					ZeroMemory(cTemp, sizeof(cTemp));
					strcpy(cTemp, "GuildAdmissionTicket");
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_PURCHASEITEM, 0, 1, 0, 0, cTemp);
					m_dialogBoxes[7].SetMode(0);
					break;
				case 2:	// Cancel
					m_dialogBoxes[7].SetMode(0);
					break;
			}
			break;

		case 11:
			switch (onButton)
			{
				case 1:// Purchase
					ZeroMemory(cTemp, sizeof(cTemp));
					strcpy(cTemp, "GuildSecessionTicket");
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_PURCHASEITEM, 0, 1, 0, 0, cTemp);
					m_dialogBoxes[7].SetMode(0);
					break;
				case 2:	// Cancel
					m_dialogBoxes[7].SetMode(0);
					break;
			}
			break;

		case 5:
			switch (onButton)
			{
				case 1:// Confirm
					bSendCommand(MSGID_REQUEST_DISBANDGUILD, MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
					m_dialogBoxes[7].SetMode(6);
					break;
				case 2:// Cancel
					m_dialogBoxes[7].SetMode(0);
					break;
			}
			break;

		case 13:
			switch (onButton)
			{
				case 1:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 1, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 1;
					break;
				case 2:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 2, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 2;
					break;
				case 3:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 3, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 3;
					break;
				case 4:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 4, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 4;
					break;
				case 5:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 5, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 5;
					break;
				case 6:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 6, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 6;
					break;
				case 7:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 7, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 7;
					break;
				case 8:
					bSendCommand(MSGID_REQUEST_FIGHTZONE_RESERVE, 0, 0, 8, 0, 0, 0);
					m_dialogBoxes[7].SetMode(18);
					m_iFightzoneNumberTemp = 8;
					break;
				case 9:
					// Cancel
					m_dialogBoxes[7].SetMode(0);
					break;
			}

			break;

		case 14://
		case 15://
		case 16://
		case 17://
		case 21://
		case 22://
			switch (onButton)
			{
				case 1: // OK
					m_dialogBoxes[7].SetMode(0);
					break;
			}
			break;
	}
	if (onButton) PlaySound('E', 14, 5);
}

void helbreath::DlgBoxClick_Guild()
{
	CDialogBox & dlg = m_dialogBoxes[DIALOG_GUILD];
	char cTemp[21];
	char txt[200];
	int iAdjX, iAdjY;
	int maxLines, line;
	MemberList::iterator it;
	uint32_t view;
	uint32_t diff;

	short szX = dlg.sSizeX;
	char onButton = dlg.OnButton();

	iAdjX = -13;
	iAdjY = 30;

	switch (dlg.GetMode())
	{
		case 0:
			switch (onButton)
			{
				case 1: // see online members
					dlg.SetMode(1);
					break;

				case 2: // give gold
					m_dialogBoxes[58].m_X = m_stMCursor.sX - 140;
					m_dialogBoxes[58].m_Y = m_stMCursor.sY - 70;
					if (m_dialogBoxes[58].m_Y < 0)
						m_dialogBoxes[58].m_Y = 0;
					EnableDialogBox(58, 0);
					break;

				case 3: // give maj
					m_dialogBoxes[58].m_X = m_stMCursor.sX - 140;
					m_dialogBoxes[58].m_Y = m_stMCursor.sY - 70;
					if (m_dialogBoxes[58].m_Y < 0)
						m_dialogBoxes[58].m_Y = 0;
					EnableDialogBox(58, 1);
					break;

				case 4: // give cont
					m_dialogBoxes[58].m_X = m_stMCursor.sX - 140;
					m_dialogBoxes[58].m_Y = m_stMCursor.sY - 70;
					if (m_dialogBoxes[58].m_Y < 0)
						m_dialogBoxes[58].m_Y = 0;
					EnableDialogBox(58, 2);
					break;

				case 5: // upgrades
					dlg.SetMode(2);
					break;

				case 6: // message board
					bSendCommand(MSGID_REQ_GUILDBOARD);
					dlg.SetMode(8);
					dlg.sView = 0;
					break;
			}
			if (onButton)
				PlaySound('E', 14, 5);
			break;

		case 1:
			maxLines = 16;
			if (gldRankPerm[m_iGuildRank].canSummon)
				maxLines--;

			if (gldRankPerm[m_iGuildRank].canPromote)
				maxLines--;

			if (onButton == 1) // back
			{
				dlg.SetMode(0);
				PlaySound('E', 14, 5);
			}

			if (!gldRankPerm[m_iGuildRank].canSummon && !gldRankPerm[m_iGuildRank].canPromote)
				return;

			view = dlg.sView;
			it = m_guild.m_onlineList.begin();

			while (view > 0 && it != m_guild.m_onlineList.end())
			{
				++it;
				view--;
			}

			for (int i = 0; i < maxLines; i++, ++it)
			{
				if (it == m_guild.m_onlineList.end())
					break;
				if (i + dlg.sView < m_guild.m_onlineList.size())
				{
					// member name
					if (onButton == i + 2)
					{
						if (!gldRankPerm[m_iGuildRank].canSummon)
							return;

						diff = time(0) - (*it).second.summonTime;
						if (diff < MINUTE(5))
						{
							fmt::format_to(txt, DLGBOX_CLICK_GUILD7, (MINUTE(5) - diff) / 60, (MINUTE(5) - diff) % 60);
							AddEventList(txt, 10);
							fmt::format_to(txt, DLGBOX_CLICK_GUILD8, (*it).first.c_str());
							AddEventList(txt, 10);
							return;
						}

						if (unixtime() - m_dwDamagedTime < 10 * 1000)
						{
							AddEventList(DLGBOXCLICK_GUILDSUMMONS1, CHAT_GM);
							return;
						}

						switch (m_guild.CanSummon(m_cMapName))
						{
							case CANSUMMON_OK:
								(*it).second.summonTime = time(0);
								fmt::format_to(txt, DLGBOX_CLICK_GUILD6, (*it).first.c_str());
								AddEventList(txt, 10);
								bSendCommand(MSGID_REQGUILDSUMMONS, 0, 0, 0, 0, 0, (*it).first.c_str());
								break;
							case CANSUMMON_LV1:
								AddEventList(DLGBOX_CLICK_GUILD2, 10);
								break;
							case CANSUMMON_LV2:
								AddEventList(DLGBOX_CLICK_GUILD3, 10);
								break;
							case CANSUMMON_LV3:
								AddEventList(DLGBOX_CLICK_GUILD2, 10);
								AddEventList(DLGBOX_CLICK_GUILD4, 10);
								break;
							case CANSUMMON_LV4:
								AddEventList(DLGBOX_CLICK_GUILD2, 10);
								AddEventList(DLGBOX_CLICK_GUILD5, 10);
								break;
							case CANSUMMON_NONE:
								AddEventList(DLGBOX_CLICK_GUILD1, 10);
								break;
							case CANSUMMON_GOLD:
								AddEventList(DLGBOX_CLICK_GUILD9, 10);
								break;
						}
					}

					//rank
					if (onButton == i + 18)
					{
						if (!gldRankPerm[m_iGuildRank].canPromote || (*it).second.rank < m_iGuildRank)
							return;

						m_dialogBoxes[44].m_X = m_stMCursor.sX - 125;
						m_dialogBoxes[44].m_Y = m_stMCursor.sY - 50;
						if (m_dialogBoxes[44].m_Y < 0)
							m_dialogBoxes[44].m_Y = 0;
						EnableDialogBox(44, 0, (*it).second.rank, 0, (*it).first.c_str());
					}
				}
			}
			break;

		case 2:
			switch (onButton)
			{
				case 1: // warehouse upgrade
					dlg.SetMode(3);
					break;

				case 2:// teleport upgrade
					dlg.SetMode(4);
					break;

				case 3:// captaincy upgrade
					dlg.SetMode(5);
					break;

				case 4:// raidmasters upgrade
					dlg.SetMode(6);
					break;

				case 5:// huntmasters upgrade
					dlg.SetMode(7);
					break;

				case 7: // back
					dlg.SetMode(0);
					break;
			}

			if (onButton)
				PlaySound('E', 14, 5);
			break;

		case 3: // warehouse upgrade
			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER && onButton == 1)
			{
				if (m_guild.m_upgrades[GU_WAREHOUSE] >= gldUps[GU_WAREHOUSE].maxLvl)
				{
					AddEventList(DLGBOX_CLICK_GUILD14, CHAT_GM);
					return;
				}

				if (m_guild.m_gold < gldUps[GU_WAREHOUSE].costGold[m_guild.m_upgrades[GU_WAREHOUSE] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD11, CHAT_GM);
					return;
				}

				if (m_guild.m_maj < gldUps[GU_WAREHOUSE].costMaj[m_guild.m_upgrades[GU_WAREHOUSE] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD12, CHAT_GM);
					return;
				}

				if (m_guild.m_cont < gldUps[GU_WAREHOUSE].costCont[m_guild.m_upgrades[GU_WAREHOUSE] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD13, CHAT_GM);
					return;
				}

				bSendCommand(MSGID_GUILDUPGRADE, 0, 0, GU_WAREHOUSE, 0, 0, 0);
			}

			// back
			else if (onButton == 2)
			{
				dlg.SetMode(2);
				PlaySound('E', 14, 5);
			}

			break;

		case 4: // teleport upgrade
			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER && onButton == 1)
			{
				if (m_guild.m_upgrades[GU_SUMMONS] >= gldUps[GU_SUMMONS].maxLvl)
				{
					AddEventList(DLGBOX_CLICK_GUILD14, CHAT_GM);
					return;
				}

				if (m_guild.m_gold < gldUps[GU_SUMMONS].costGold[m_guild.m_upgrades[GU_SUMMONS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD11, CHAT_GM);
					return;
				}

				if (m_guild.m_maj < gldUps[GU_SUMMONS].costMaj[m_guild.m_upgrades[GU_SUMMONS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD12, CHAT_GM);
					return;
				}

				if (m_guild.m_cont < gldUps[GU_SUMMONS].costCont[m_guild.m_upgrades[GU_SUMMONS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD13, CHAT_GM);
					return;
				}

				bSendCommand(MSGID_GUILDUPGRADE, 0, 0, GU_SUMMONS, 0, 0, 0);
			}

			// back
			else if (onButton == 2)
			{
				dlg.SetMode(2);
				PlaySound('E', 14, 5);
			}

			break;

		case 5: // Captain upgrade
			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER && onButton == 1)
			{
				if (m_guild.m_upgrades[GU_CAPTAINCY] >= gldUps[GU_CAPTAINCY].maxLvl)
				{
					AddEventList(DLGBOX_CLICK_GUILD14, CHAT_GM);
					return;
				}

				if (m_guild.m_gold < gldUps[GU_CAPTAINCY].costGold[m_guild.m_upgrades[GU_CAPTAINCY] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD11, CHAT_GM);
					return;
				}

				if (m_guild.m_maj < gldUps[GU_CAPTAINCY].costMaj[m_guild.m_upgrades[GU_CAPTAINCY] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD12, CHAT_GM);
					return;
				}

				if (m_guild.m_cont < gldUps[GU_CAPTAINCY].costCont[m_guild.m_upgrades[GU_CAPTAINCY] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD13, CHAT_GM);
					return;
				}

				bSendCommand(MSGID_GUILDUPGRADE, 0, 0, GU_CAPTAINCY, 0, 0, 0);
			}

			// back
			else if (onButton == 2)
			{
				dlg.SetMode(2);
				PlaySound('E', 14, 5);
			}

			break;

		case 6: // raidmaster upgrade
			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER && onButton == 1)
			{
				if (m_guild.m_upgrades[GU_RAIDMASTERS] >= gldUps[GU_RAIDMASTERS].maxLvl)
				{
					AddEventList(DLGBOX_CLICK_GUILD14, CHAT_GM);
					return;
				}

				if (m_guild.m_gold < gldUps[GU_RAIDMASTERS].costGold[m_guild.m_upgrades[GU_RAIDMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD11, CHAT_GM);
					return;
				}

				if (m_guild.m_maj < gldUps[GU_RAIDMASTERS].costMaj[m_guild.m_upgrades[GU_RAIDMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD12, CHAT_GM);
					return;
				}

				if (m_guild.m_cont < gldUps[GU_RAIDMASTERS].costCont[m_guild.m_upgrades[GU_RAIDMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD13, CHAT_GM);
					return;
				}

				bSendCommand(MSGID_GUILDUPGRADE, 0, 0, GU_RAIDMASTERS, 0, 0, 0);
			}

			// back
			else if (onButton == 2)
			{
				dlg.SetMode(2);
				PlaySound('E', 14, 5);
			}

			break;

		case 7: // huntmaster upgrade
			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER && onButton == 1)
			{
				if (m_guild.m_upgrades[GU_HUNTMASTERS] >= gldUps[GU_HUNTMASTERS].maxLvl)
				{
					AddEventList(DLGBOX_CLICK_GUILD14, CHAT_GM);
					return;
				}

				if (m_guild.m_gold < gldUps[GU_HUNTMASTERS].costGold[m_guild.m_upgrades[GU_HUNTMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD11, CHAT_GM);
					return;
				}

				if (m_guild.m_maj < gldUps[GU_HUNTMASTERS].costMaj[m_guild.m_upgrades[GU_HUNTMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD12, CHAT_GM);
					return;
				}

				if (m_guild.m_cont < gldUps[GU_HUNTMASTERS].costCont[m_guild.m_upgrades[GU_HUNTMASTERS] + 1])
				{
					AddEventList(DLGBOX_CLICK_GUILD13, CHAT_GM);
					return;
				}

				bSendCommand(MSGID_GUILDUPGRADE, 0, 0, GU_HUNTMASTERS, 0, 0, 0);
			}

			// back
			else if (onButton == 2)
			{
				dlg.SetMode(2);
				PlaySound('E', 14, 5);
			}

			break;

		case 8: // guild message board
			if (onButton == 1)
			{
				// Post
				if (GetItemCount("Gold") < GUILDBOARD_POST_COST)
				{
					AddEventList(NOTIFY_MSG_HANDLER84, CHAT_GM);
					break;
				}

				ZeroMemory(dlg.cStr2, sizeof(dlg.cStr2)); // title
				ZeroMemory(dlg.txt, sizeof(dlg.txt)); // msg
				dlg.sV1 = -1;
				dlg.bFlag = false;
				dlg.SetMode(10);

				m_stMCursor.sX = dlg.GetButton(1).left + 1;
				m_stMCursor.sY = dlg.GetButton(1).top + 1;
				DlgBoxClick_Guild();
			}
			if (onButton == 3)
			{
				dlg.SetMode(0);
			}
			else if (onButton >= 4 && onButton < 4 + 15)
			{
				uint32_t listHit = onButton - 4 + dlg.sView;

				if (listHit >= m_gldBoard.size())
					break;

				if (!m_gldBoard[m_gldBoard.size() - 1 - listHit]->msg)
					bSendCommand(MSGID_REQ_GUILDPOSTDATA, 0, 0, m_gldBoard[m_gldBoard.size() - 1 - listHit]->id);

				dlg.sV1 = m_gldBoard.size() - 1 - listHit;
				dlg.SetMode(9);
			}
			break;

		case 9: // post view
			switch (onButton)
			{
				case 4: // delete
					if (m_iGuildRank != GUILDRANK_MASTER && m_iGuildRank != GUILDRANK_CAPTAIN)
						break;

					EnableDialogBox(DIALOG_YESNO, 2);
					break;

				case 5: // back
					dlg.sV1 = -1;
					dlg.SetMode(8);
					break;
			}
			break;

		case 10:
			EndInputString();

			switch (onButton)
			{
				case 1: // title:
					StartInputString(dlg.GetButton(1).left + 30, dlg.GetButton(1).top - 1, 31, dlg.cStr2);
					break;

				case 2: // msg:
					StartInputString(dlg.GetButton(2).left, dlg.GetButton(2).top + 15, sizeof(dlg.txt), dlg.txt, false, dlg.GetButton(2).right);
					break;

				case 3: // send
					if (!dlg.bFlag)
					{
						bSendCommand(MSGID_REQ_POSTGUILDBOARD);
						dlg.bFlag = true;
					}
					break;

				case 4: // cancel
					dlg.SetMode(8);
					break;
			}
			break;
	}
}

void helbreath::CreateNewGuildResponseHandler(char * pData)
{
	uint16_t * wpResult;
	wpResult = (uint16_t *)(pData + INDEX2_MSGTYPE);

	switch (*wpResult)
	{
		case MSGTYPE_CONFIRM:
			m_iGuildRank = GUILDRANK_MASTER;
			m_dialogBoxes[7].SetMode(3);
			m_dialogBoxes[7].SetMode(3);
			break;
		case MSGTYPE_REJECT:
			m_iGuildRank = GUILDRANK_NONE;
			m_dialogBoxes[7].SetMode(4);
			break;
	}
}

void helbreath::InitPlayerCharacteristics(char * pData)
{
	int * ip;
	char * cp;
	uint16_t * wp;

	for (int i = 0; i < 6; i++)
		m_angelStat[i] = 0;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	ip = (int *)cp;
	m_iHP = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iMP = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iSP = *ip;
	cp += 4;

	/*ip   = (int *)cp;
	m_iAC = *ip;
	cp += 4;*/

	ip = (int *)cp;
	m_iDefenseRatio = *ip; // Defense Display in Action Bar xRisenx
	cp += 4;

	ip = (int *)cp;
	m_iTHAC0 = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iLevel = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_STR] = m_stat[STAT_STR] = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_INT] = m_stat[STAT_INT] = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_VIT] = m_stat[STAT_VIT] = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_DEX] = m_stat[STAT_DEX] = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_MAG] = m_stat[STAT_MAG] = *ip;
	cp += 4;

	ip = (int *)cp;
	m_createStat[STAT_CHR] = m_stat[STAT_CHR] = *ip;
	cp += 4;

	wp = (uint16_t *)cp;
	m_iLU_Point = (*wp - 3); // Comment out - 3 ? xRisenx
	cp += 2; // Change to 7? xRisenx

	ip = (int *)cp;
	m_iExp = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iEnemyKillCount = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iPKCount = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iRewardGold = *ip;
	cp += 4;

	memcpy(m_cLocation, cp, 10);
	cp += 10;

	if (memcmp(m_cLocation, "are", 3) == 0)
		m_side = ARESDEN;
	else if (memcmp(m_cLocation, "elv", 3) == 0)
		m_side = ELVINE;
	else if (memcmp(m_cLocation, "ist", 3) == 0)
		m_side = ISTRIA;
	else
		m_side = NEUTRAL;

	cp = (char *)cp;
	memcpy(m_cGuildName, cp, 20);
	cp += 20;

	if (strcmp(m_cGuildName, "NONE") == 0)
		ZeroMemory(m_cGuildName, sizeof(m_cGuildName));

	m_Misc.ReplaceString(m_cGuildName, '_', ' ');

	ip = (int *)cp;
	m_iGuildRank = (GuildRank)*ip;
	cp += 4;

	m_iSuperAttackLeft = (int)*cp;
	cp++;

	ip = (int *)cp;
	m_iFightzoneNumber = *ip;
	cp += 4;

	ip = (int *)cp;
	m_iEnemyKillTotalCount = *ip;
	cp += 4;
}

void helbreath::DisbandGuildResponseHandler(char * pData)
{
	uint16_t * wpResult;
	wpResult = (uint16_t *)(pData + INDEX2_MSGTYPE);

	switch (*wpResult)
	{
		case MSGTYPE_CONFIRM:
			ZeroMemory(m_cGuildName, sizeof(m_cGuildName));
			m_iGuildRank = GUILDRANK_NONE;
			m_guild.Reset();
			DisableDialogBox(57);
			m_dialogBoxes[7].SetMode(7);
			break;
		case MSGTYPE_REJECT:
			m_dialogBoxes[7].SetMode(8);
			break;
	}
}

void helbreath::_PutGuildOperationList(char * pName, char cOpMode)
{
	int i;
	for (i = 0; i < 100; i++)
		if (m_stGuildOpList[i].cOpMode == 0)
		{
			m_stGuildOpList[i].cOpMode = cOpMode;
			ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
			memcpy(m_stGuildOpList[i].cName, pName, 20);
			return;
		}
}

void helbreath::_ShiftGuildOperationList()
{
	int i;
	ZeroMemory(m_stGuildOpList[0].cName, sizeof(m_stGuildOpList[0].cName));
	m_stGuildOpList[0].cOpMode = 0;

	for (i = 1; i < 100; i++)
		if ((m_stGuildOpList[i - 1].cOpMode == 0) && (m_stGuildOpList[i].cOpMode != 0))
		{
			m_stGuildOpList[i - 1].cOpMode = m_stGuildOpList[i].cOpMode;
			ZeroMemory(m_stGuildOpList[i - 1].cName, sizeof(m_stGuildOpList[i - 1].cName));
			memcpy(m_stGuildOpList[i - 1].cName, m_stGuildOpList[i].cName, 20);

			ZeroMemory(m_stGuildOpList[i].cName, sizeof(m_stGuildOpList[i].cName));
			m_stGuildOpList[i].cOpMode = 0;
		}
}



void helbreath::SetItemCount(const char * pItemName, uint32_t dwCount)
{
	char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (int i = 0; i < MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cTmpName, 20) == 0))
		{
			m_pItemList[i]->m_dwCount = dwCount;
			return;
		}
	}
}

uint32_t helbreath::GetItemCount(const char * pItemName)
{
	char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (int i = 0; i < MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (memcmp(m_pItemList[i]->m_cName, cTmpName, 20) == 0))
		{
			return m_pItemList[i]->m_dwCount;
		}
	}

	return 0;
}


void helbreath::AddEventList(char const * const pTxt, char cColor, bool bDupAllow)
{
	int i;
	if ((bDupAllow == false) && (strcmp(m_stEventHistory[5].cTxt, pTxt) == 0)) return;
	if (cColor == 10)
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory2[i - 1].cTxt, m_stEventHistory2[i].cTxt);
			m_stEventHistory2[i - 1].cColor = m_stEventHistory2[i].cColor;
			m_stEventHistory2[i - 1].dwTime = m_stEventHistory2[i].dwTime;
		}
		ZeroMemory(m_stEventHistory2[5].cTxt, sizeof(m_stEventHistory2[5].cTxt));
		strcpy(m_stEventHistory2[5].cTxt, pTxt);
		m_stEventHistory2[5].cColor = cColor;
		m_stEventHistory2[5].dwTime = m_dwCurTime;
	}
	else
	{
		for (i = 1; i < 6; i++)
		{
			strcpy(m_stEventHistory[i - 1].cTxt, m_stEventHistory[i].cTxt);
			m_stEventHistory[i - 1].cColor = m_stEventHistory[i].cColor;
			m_stEventHistory[i - 1].dwTime = m_stEventHistory[i].dwTime;
		}
		ZeroMemory(m_stEventHistory[5].cTxt, sizeof(m_stEventHistory[5].cTxt));
		strcpy(m_stEventHistory[5].cTxt, pTxt);
		m_stEventHistory[5].cColor = cColor;
		m_stEventHistory[5].dwTime = m_dwCurTime;
	}
}

int _iAttackerHeight[] = { 0, 35, 35,35,35,35,35, 0,0,0,
5,  // Slime
35, // Skeleton
40, // Stone-Golem
45, // Cyclops
35,// OrcMage
35,// ShopKeeper
5, // GiantAnt
8, // Scorpion
35,// Zombie
35,// Gandalf
35,// Howard
35,// Guard
10,// Amphis
38,// Clay-Golem
35,// Tom
35,// William
35,// Kennedy
35,// Hellhound
50,// Troll
45,// Orge
55,// Liche
65,// Demon
46,// Unicorn
49,// WereWolf
55,// Dummy
35,// Energysphere
75,// Arrow Guard Tower
75,// Cannon Guard Tower
50,// Mana Collector
50,// Detector
50,// Energy Shield Generator
50,// Grand Magic Generator
50,// ManaStone 42
40,// Light War Beetle
35,// GHK
40,// GHKABS
35,// TK
60,// BG
40,// Stalker
70,// HellClaw
85,// Tigerworm
50,// Catapult
85,// Gargoyle
70,// Beholder
40,// Dark-Elf
20,// Bunny
20,// Cat
40,// Giant-Frog
80,// Mountain-Giant
85,// Ettin
50,// Cannibal-Plant
50, // Rudolph 61 //Snoopy....
80, // Direboar 62
90, // Frost 63
40, // Crops 64
80, // IceGolem 65
190, // Wyvern 66
35, // npc 67
35, // npc 68
35, // npc 69
100, // Dragon 70
90, // Centaur 71
75, // ClawTurtle 72
200, // FireWyvern 73
80, // GiantCrayfish 74
120, // Gi Lizard 75
100, // Gi Tree 76
100, // Master Orc 77
80, // Minaus 78
100, // Nizie 79
25,  // Tentocle 80
200, // Abaddon	 81
60, // Sorceress 82
60, // ATK 83
70, // MasterElf 84
60, // DSK 85
50, // HBT 86
60, // CT 87
60, // Barbarian 88
60, // AGC 89
35, // ncp 90 Gail
35,  // Gate 91
50 // Check xRisenx
};

void helbreath::bAddNewEffect(short sType, int sX, int sY, int dX, int dY, char cStartFrame, int iV1)
{
	int i;
	short sAbsX, sAbsY, sDist;
	long lPan;
	int  iV2 = 0;
	if (m_cDetailLevel == 0) // Detail Level Low
	{
		switch (sType)
		{
			case 11:
			case 15:
				return;
		}
	}
	if (m_bIsProgramActive == false) return;
	//sAbsX = abs(((m_sViewPointX / 32) + 10) - dX);
	//sAbsY = abs(((m_sViewPointY / 32) + 7) - dY);
	sAbsX = abs(((m_sViewPointX / 32) + 12) - dX); // 800x600 Resolution xRisenx Center Char xRisenx
	sAbsY = abs(((m_sViewPointY / 32) + 9) - dY); // 800x600 Resolution xRisenx Center Char xRisenx
	if (sAbsX > sAbsY) sDist = sAbsX;
	else sDist = sAbsY;

	for (i = 0; i < MAXEFFECTS; i++)
		if (m_pEffectList[i] == 0)
		{
			m_pEffectList[i] = new class CEffect;
			m_pEffectList[i]->m_sType = sType;
			m_pEffectList[i]->m_sX = sX;
			m_pEffectList[i]->m_sY = sY;
			m_pEffectList[i]->m_dX = dX;
			m_pEffectList[i]->m_dY = dY;
			m_pEffectList[i]->m_iV1 = iV1;
			m_pEffectList[i]->m_cFrame = cStartFrame;
			m_pEffectList[i]->m_dwTime = m_dwCurTime;

			switch (sType)
			{
				case 1: // coup normal
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - _iAttackerHeight[iV1];
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 2:	// Flche qui vole
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - _iAttackerHeight[iV1];
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 10;
					m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
					PlaySound('C', 4, sDist);
					break;

				case 4: // Gold
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 100;
					//sAbsX = abs(((m_sViewPointX / 32) + 10) - sX);
					//sAbsY = abs(((m_sViewPointY / 32) + 7)  - sY);
					sAbsX = abs(((m_sViewPointX / 32) + 12) - sX); // 800x600 Resolution xRisenx Center Char xRisenx
					sAbsY = abs(((m_sViewPointY / 32) + 9) - sY); // 800x600 Resolution xRisenx Center Char xRisenx
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 12, sDist, lPan);
					break;

				case 5: // FireBall Fire Explosion
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 11;
					m_pEffectList[i]->m_dwFrameTime = 10;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist);
					break;

				case 6:	 // Energy Bolt
				case 10: // Lightning Arrow
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 10;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 2, sDist, lPan);
					SetCameraShakingEffect(sDist);
					break;

				case 7: // Magic Missile Explosion
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 5;
					m_pEffectList[i]->m_dwFrameTime = 50;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 3, sDist, lPan);
					break;

				case 8: // Burst
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 4;
					m_pEffectList[i]->m_dwFrameTime = 30;
					break;

				case 9: // Burst
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_rX = 6 - (rand() % 12);
					m_pEffectList[i]->m_rY = -8 - (rand() % 6);
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 30;
					break;

				case 11:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_rX = 6 - (rand() % 12);
					if (iV2 == 0)
						m_pEffectList[i]->m_rY = -2 - (rand() % 4);
					else m_pEffectList[i]->m_rY = -2 - (rand() % 10);
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 30;
					break;

				case 12: // Burst
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_rX = 8 - (rand() % 16);
					m_pEffectList[i]->m_rY = 4 - (rand() % 12);
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 30;
					break;

				case 13: // Bulles druncncity
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 18;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 14: // Traces de pas ou Tremor (pas en low detail)
					m_pEffectList[i]->m_mX = sX;
					if (m_pEffectList[i]->m_iV1 > 0) // Case if hit by an arrow
					{
						m_pEffectList[i]->m_mY = sY - (_iAttackerHeight[m_pEffectList[i]->m_iV1] / 4 + rand() % (_iAttackerHeight[m_pEffectList[i]->m_iV1] / 2));
						m_pEffectList[i]->m_mX = sX + (rand() % 5) - 2;
					}
					else m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 4;
					m_pEffectList[i]->m_dwFrameTime = 100;
					m_pEffectList[i]->m_iV1 = iV1;
					break;

				case 15: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 16: //
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 17:
					m_pEffectList[i]->m_mX = sX + (rand() % 20) - 40;
					m_pEffectList[i]->m_mY = sY + (rand() % 20) - 40;
					m_pEffectList[i]->m_rX = 8 - (rand() % 16);
					m_pEffectList[i]->m_rY = 4 - (rand() % 12);
					m_pEffectList[i]->m_mX3 = sX;
					m_pEffectList[i]->m_mY3 = sY;
					m_pEffectList[i]->m_iV1 = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 18:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 50;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

				case 20:
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27: // Critical strike with a weapon
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 10;
					m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
					break;

				case 30: // Mass-Fire-Strike (called 1 time)
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 9;
					m_pEffectList[i]->m_dwFrameTime = 40;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist * 2);
					break;

				case 31: // Mass-Fire-Strike (called 3 times)
				case 252: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 40;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist);
					break;

				case 32: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 4;
					m_pEffectList[i]->m_dwFrameTime = 100;
					break;

				case 33: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 34: //
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

				case 35: // Snoopy: rajout (pour Mass Magic-Missile)
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 18;
					m_pEffectList[i]->m_dwFrameTime = 40;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist * 2);
					break;

				case 36: // Snoopy: Rajout (pour Mass Magic-Missile)
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 40;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(320 - (sX - m_sViewPointX)) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist);
					break;

				case 40: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 45, sDist, lPan);
					break;

				case 41: // Large Type 1, 2, 3, 4
				case 42:
				case 43:
				case 44:
				case 45: // Small Type 1, 2
				case 46:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY - 220;
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 20;
					m_pEffectList[i]->m_iV1 = 20;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 46, sDist, lPan);
					break;

				case 47: // Blizzard
				case 48: // Blizzard
				case 49: // Blizzard
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY - 220;
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 20;
					m_pEffectList[i]->m_iV1 = 20;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 46, sDist, lPan);
					break;

				case 50: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 50;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					if ((rand() % 4) == 1) SetCameraShakingEffect(sDist);
					PlaySound('E', 47, sDist, lPan);
					break;

				case 51:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 9; //15;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 52: // Protect ring
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 80;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 53: // Hold twist
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 80;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 54: // star twingkling (effect armes brillantes)
				case 55: // Unused
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 15;
					break;

				case 56: //  Mass-Chill-Wind
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					PlaySound('E', 45, sDist, lPan);
					break;

				case 57: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 60: //
					m_pEffectList[i]->m_mX = sX + 300;
					m_pEffectList[i]->m_mY = sY - 460;
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 50;
					break;

				case 61: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 10;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist, 2);
					break;

				case 62: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 6;
					m_pEffectList[i]->m_dwFrameTime = 100;
					break;

				case 63: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 64: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 65: // Crusade's MS
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 66: // Crusade MS explosion
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist, 2);
					break;

				case 67: // Crusade's MS fire + smoke ?
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 27;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 68: // worm-bite
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 17;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					m_pEffectList[i]->m_iV1 = sDist;
					//SetCameraShakingEffect(sDist, 2);
					break;

				case 69: // identique au cas 70
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 11;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - (sX / 32)) * 1000;
					PlaySound('E', 42, sDist, lPan);
					break;

				case 70: // identtique au cas 69
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 11;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - (sX / 32)) * 1000;
					PlaySound('E', 42, sDist, lPan);
					break;

				case 71: //
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

				case 72: // Blizzard
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 20;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = ((sX - m_sViewPointX) - 320) * 30;
					if ((rand() % 4) == 1) SetCameraShakingEffect(sDist);
					PlaySound('E', 47, sDist, lPan);
					break;

				case 73:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 60;
					break;

				case 74:
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 19;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 75: //ice golem
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_dX = dX;
					m_pEffectList[i]->m_dY = dY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 76: //ice golem
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_dX = dX;
					m_pEffectList[i]->m_dY = dY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 77: //ice golem
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_dX = dX;
					m_pEffectList[i]->m_dY = dY;
					m_pEffectList[i]->m_cMaxFrame = 16;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 80: // Snoopy: rajou, implment en dernier ds la v351
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_iV1 = 20;
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

				case 81: //  Snoopy: Rajout (StormBlade)
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 27;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 82: //  Snoopy: Rajout (Gate Apocalypse)
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 100: // MagicMissile is Flying
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 101: // Heal
				case 111: // Staminar-Drain
				case 121: // Great Heal
				case 123: // Staminar-Recovery
				case 128: // Great-Staminar-Recovery
					m_pEffectList[i]->m_cMaxFrame = 14;
					m_pEffectList[i]->m_dwFrameTime = 80;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 102: // CreateFood
				case 122: // Recall
				case 126: // Possession
				case 127: // Poison
				case 134: // DetectInvi
				case 136: // Cure
				case 142: // Confuse language
				case 152: // Polymorph
				case 153: // Mass-Poison
				case 162: // Confusion
				case 171: // Mass-Confusion
					m_pEffectList[i]->m_cMaxFrame = 13;
					m_pEffectList[i]->m_dwFrameTime = 120;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 110: // Energy-Bolt
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 112: // Recall
				case 131: // Summon
				case 132: // Invi
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 80;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 113: // Defense-Shield
				case 144: // Great-Defense-Shield
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 120;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 114: // Celebrating Light
					bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -12);
					bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -9);
					bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -6);
					bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, -3);
					bAddNewEffect(69 + (rand() % 2), dX * 32 + 20 - (rand() % 40), dY * 32 + 20 - (rand() % 40), 0, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 120: // Fire Ball
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 124: // Protect form N.M
				case 133: // Protection from Magic
					bAddNewEffect(52, dX * 32, dY * 32, 0, 0, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 125: // Hold Person
				case 135: // Paralyze
					bAddNewEffect(53, dX * 32, dY * 32, 0, 0, 0, 0);
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;

				case 130: // Fire Strike
				case 137: // Lightning Arrow
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 138: // Tremor.
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					SetCameraShakingEffect(sDist, 2);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);

					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 143: // Lightning
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 50;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
					m_pEffectList[i]->m_cMaxFrame = 7;
					m_pEffectList[i]->m_dwFrameTime = 10;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 40, sDist, lPan);
					break;

				case 145: // ChillWind
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 147: // Triple-Energy-Bolt
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					break;

				case 150: // Berserk : Cirlcle 6 magic
				case 177: // Illusion-Movement
				case 180: // Illusion
				case 183: // Inhibition-Casting
				case 190: // Mass-Illusion
				case 195: // Mass-Illusion-Movement
					m_pEffectList[i]->m_cMaxFrame = 11;
					m_pEffectList[i]->m_dwFrameTime = 100;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 151: // LightningBolt
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 50;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_rX = 5 - (rand() % 10);
					m_pEffectList[i]->m_rY = 5 - (rand() % 10);
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 10;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 40, sDist, lPan);
					break;

				case 156: // Mass-Ligtning-Arrow
					m_pEffectList[i]->m_cMaxFrame = 3;
					m_pEffectList[i]->m_dwFrameTime = 130;
					break;

				case 157: // Ice-Strike
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 160: // Energy-Strike
					m_pEffectList[i]->m_cMaxFrame = 7;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 161: // Mass-Fire-Strike
				case 251: //
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 163: // Mass-Chill-Wind
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 164: // worm-bite
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);

					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					bAddNewEffect(14, dX * 32 + (rand() % 120) - 60, dY * 32 + (rand() % 80) - 40, 0, 0, 0, 0);
					m_pEffectList[i]->m_cMaxFrame = 1;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 165: // Absolute-Magic-Protection
					m_pEffectList[i]->m_cMaxFrame = 21;
					m_pEffectList[i]->m_dwFrameTime = 70;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 166: // Armor Break
					m_pEffectList[i]->m_cMaxFrame = 13;
					m_pEffectList[i]->m_dwFrameTime = 80;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 170: // Bloody-Shock-Wave
					m_pEffectList[i]->m_cMaxFrame = 7;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

				case 172: // Mass-Ice-Strike
					m_pEffectList[i]->m_cMaxFrame = 2;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 174: // Lightning-Strike
					m_pEffectList[i]->m_cMaxFrame = 5;
					m_pEffectList[i]->m_dwFrameTime = 120;
					break;

				case 176: // Snoopy: Ajout Cancellation
					m_pEffectList[i]->m_cMaxFrame = 23;
					m_pEffectList[i]->m_dwFrameTime = 60;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 181: // MS
					m_pEffectList[i]->m_mX = dX * 32 + 300;
					m_pEffectList[i]->m_mY = dY * 32 - 460;
					m_pEffectList[i]->m_cMaxFrame = 10;
					m_pEffectList[i]->m_dwFrameTime = 25;
					break;

				case 182: // Snoopy: Ajout Mass-Magic-Missile
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 20;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 1, sDist, lPan);
					break;

				case 244: // Snoopy: dplac pour nvx sorts: Aura du casteur de Mass MagicMissile
				//case 184: // effet sur le caster pour MassMM
					m_pEffectList[i]->m_cMaxFrame = 29;
					m_pEffectList[i]->m_dwFrameTime = 80;
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					break;

				case 191: // Blizzard
					m_pEffectList[i]->m_cMaxFrame = 7;
					m_pEffectList[i]->m_dwFrameTime = 80;
					break;

					//case 192: // Hero set Effect
				case 242: // Hero set Effect
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

					//case 193: // Hero set Effect
				case 243: // Hero set Effect
					m_pEffectList[i]->m_cMaxFrame = 19;
					m_pEffectList[i]->m_dwFrameTime = 18;
					break;

				case 194: // Resurrection
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 40;
					break;

				case 196: // Snoopy: Ajout de Earth-Shock-Wave
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 30;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;
				case 200: //
				case 201: //
				case 202: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 25;
					break;

				case 203: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 18;
					m_pEffectList[i]->m_dwFrameTime = 70;
					break;

				case 204: //
				case 205: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 12;
					m_pEffectList[i]->m_dwFrameTime = 70;
					break;

				case 206: //
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 3;
					m_pEffectList[i]->m_dwFrameTime = 70;
					break;

				case 250: //
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32 - 40;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 0;
					m_pEffectList[i]->m_dwFrameTime = 10;
					break;

				case 197: //Fiery-Shock-Wave xRisenx
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

				case 198: //Mass-Blizzard xRisenx
					m_pEffectList[i]->m_cMaxFrame = 15;
					m_pEffectList[i]->m_dwFrameTime = 100;
					break;

				case 192: //Call-Of-The-Gods xRisenx
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					break;

				case 149:
				case 187: //Strike-Of-The-Ghosts xRisenx
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					break;

				case 245: //Ghosts 1 xRisenx
					m_pEffectList[i]->m_mX = sX;
					m_pEffectList[i]->m_mY = sY;
					m_pEffectList[i]->m_cMaxFrame = 17;
					m_pEffectList[i]->m_dwFrameTime = 30;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					lPan = -(((m_sViewPointX / 32) + 10) - sX) * 1000;
					PlaySound('E', 4, sDist, lPan);
					m_pEffectList[i]->m_iV1 = sDist;
					break;

				case 193: //Hurricane-Blast xRisenx

					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 8;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					break;

				case 184: //Magic-Shield xRisenx
					m_pEffectList[i]->m_cMaxFrame = 21;
					m_pEffectList[i]->m_dwFrameTime = 70;
					lPan = -(((m_sViewPointX / 32) + 10) - dX) * 1000;
					PlaySound('E', 5, sDist, lPan);
					break;

				case 188: // Lightning-Storm xRisenx
					m_pEffectList[i]->m_mX = sX * 32;
					m_pEffectList[i]->m_mY = sY * 32;
					m_pEffectList[i]->m_iErr = 0;
					m_pEffectList[i]->m_cMaxFrame = 20;
					m_pEffectList[i]->m_dwFrameTime = 25;
					sAbsX = abs(400 - (sX - m_sViewPointX));
					sAbsY = abs(300 - (sY - m_sViewPointY));
					if (sAbsX > sAbsY) sDist = sAbsX;
					else sDist = sAbsY;
					sDist = sDist / 32;
					SetCameraShakingEffect(sDist);
					break;

					//case 104: // Thunder Storm xRisenx
					//	m_pEffectList[i]->m_mX     = sX*32;
					//	m_pEffectList[i]->m_mY     = sY*32;
					//	m_pEffectList[i]->m_iErr   = 0;
					//	m_pEffectList[i]->m_cMaxFrame   = 30;
					//	m_pEffectList[i]->m_dwFrameTime = 25;
					//	sAbsX = abs(320 - (sX - m_sViewPointX));
					//	sAbsY = abs(240 - (sY - m_sViewPointY));

					//	if (sAbsX > sAbsY) sDist = sAbsX;
					//	else sDist = sAbsY;

					//	sDist = sDist / 32;
					//	SetCameraShakingEffect(sDist);
					//	break;

					//case 105: // Inferno xRisenx
					//	m_pEffectList[i]->m_mX  = sX*32;
			  //          m_pEffectList[i]->m_mY  = sY*32;
					//	m_pEffectList[i]->m_iErr   = 0;
					//	m_pEffectList[i]->m_cMaxFrame   = 20;
					//	m_pEffectList[i]->m_dwFrameTime = 25;
					//	sAbsX = abs(320 - (sX - m_sViewPointX));
					//	sAbsY = abs(240 - (sY - m_sViewPointY));

					//	if (sAbsX > sAbsY) sDist = sAbsX;
					//	else sDist = sAbsY;

					//	sDist = sDist / 32;
					//	SetCameraShakingEffect(sDist);
					//	break;
					//	// This is where u set Coords and Max Time / Frames on spell animation
					//case 106: // Hell-Fire xRisenx
					//	m_pEffectList[i]->m_mX    = dX*32 +300;
					//	m_pEffectList[i]->m_mY    = dY*32 -460;
					//	m_pEffectList[i]->m_cMaxFrame   = 10;
					//	m_pEffectList[i]->m_dwFrameTime = 25;
					//	/*m_pEffectList[i]->m_mX     = sX*32;
					//	m_pEffectList[i]->m_mY     = sY*32 - 40;
					//	m_pEffectList[i]->m_iErr   = 0;
					//	m_pEffectList[i]->m_cMaxFrame   = NULL;
					//	m_pEffectList[i]->m_dwFrameTime = 20;
					//	m_pEffectList[i]->m_cDir = m_Misc.cCalcDirection(sX, sY, dX, dY);*/

					//	lPan = -(((m_sViewPointX / 32) + 10) - dX)*1000;
					//	PlaySound('E', 1, sDist, lPan);
					//	break;

				default:
					delete m_pEffectList[i];
					m_pEffectList[i] = 0;
					break;
			}
			if (m_pEffectList[i] != 0)
			{
				m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
				m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
			}
			return;
		}
}

void helbreath::DrawEffects()
{
	int i, dX, dY, iDvalue, tX, tY, rX, rY, rX2, rY2, rX3, rY3, rX4, rY4, rX5, rY5, iErr;
	char  cTempFrame;
	uint64_t dwTime = m_dwCurTime;

	for (i = 0; i < MAXEFFECTS; i++)
		if ((m_pEffectList[i] != 0) && (m_pEffectList[i]->m_cFrame >= 0))
		{
			switch (m_pEffectList[i]->m_sType)
			{
				case 1: // Normal hit
					if (m_pEffectList[i]->m_cFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 2: // Arrow flying
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 2;
					if (cTempFrame < 0) break;
					m_pEffectSpr[7]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
					break;

				case 4: // gold
					/* 1.5
					if (m_pEffectList[i]->m_cFrame < 9) break;
					cTempFrame = m_pEffectList[i]->m_cFrame - 9;
					dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					m_pEffectSpr[1]->PutSpriteFast(dX, dY-40, cTempFrame, dwTime);
					*/
					break;

				case 5: // FireBall Fire Explosion
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (cTempFrame - 8) * (-5);
					if (cTempFrame < 7)
						m_pEffectSpr[3]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					else m_pEffectSpr[3]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
					break;

				case 6:	 // Energy Bolt
				case 10: // Lightning Arrow
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (cTempFrame - 7) * (-6);
					if (cTempFrame < 6)
						m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 7: // Magic Missile Explosion
					cTempFrame = m_pEffectList[i]->m_cFrame;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = (cTempFrame - 4) * (-3);
					if (cTempFrame < 4)
						m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					else m_pEffectSpr[6]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 8: // Burst
					cTempFrame = m_pEffectList[i]->m_cFrame;
					cTempFrame = 4 - cTempFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 9: // Burst
					cTempFrame = (rand() % 5);
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 11: // pt grenat
					cTempFrame = (rand() % 5) + 5;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite2(dX, dY, cTempFrame, dwTime);
					break;

				case 12: // Burst
					cTempFrame = (rand() % 6) + 10;
					if (cTempFrame < 0) break;
					iDvalue = (m_pEffectList[i]->m_cFrame - 4) * (-3);
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					if (cTempFrame < 4)
						m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					else //m_pEffectSpr[11]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					//
						m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					break;

				case 13:
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					if (cTempFrame < 13)
					{
						m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, 25 + (cTempFrame / 5), dwTime);
					}
					else
					{
						m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, (8 + cTempFrame), dwTime);
					}
					break;

				case 14: // Traces de pas (terrain sec)
					if (m_pEffectList[i]->m_cFrame < 0) break;
					dX = m_pEffectList[i]->m_mX - m_sViewPointX;
					dY = m_pEffectList[i]->m_mY - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (28 + m_pEffectList[i]->m_cFrame), dwTime);
					break;

				case 15: // petits nuages rouges
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = m_pEffectList[i]->m_mX - m_sViewPointX;
					dY = m_pEffectList[i]->m_mY - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, (33 + cTempFrame), dwTime);
					break;

				case 16: //
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 0, dwTime);
					break;

				case 17: //test
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = 39 + (rand() % 3) * 3 + (rand() % 3);
					if (cTempFrame < 0) break;
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					dX = (m_pEffectList[i]->m_mX2) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY2) - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 18: //
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					m_pEffectSpr[18]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 20: // critical hit
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27: // Critical strike with a weapon
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[8]->PutTransSprite_NoColorKey(dX, dY, 1, dwTime);
					break;

				case 30: // Mass-Fire-Strike
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					m_pEffectSpr[14]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 31: // Mass-Fire-Strike
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					m_pEffectSpr[15]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 32: // Trace de pas  (raining weather)
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame + 20;
					if (cTempFrame < 0) break;
					m_pEffectSpr[11]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 33: //
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					iDvalue = 0;
					m_pEffectSpr[19]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 34: // absent (220 et 351)
					break;

				case 35: // Snoopy: Ajout
					if (m_pEffectList[i]->m_cFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					m_pEffectSpr[6]->PutTransSprite_NoColorKey(dX - 30, dY - 18, cTempFrame, dwTime);
					break;

				case 36: // Snoopy: Ajout
					if (m_pEffectList[i]->m_cFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					m_pEffectSpr[97]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 40:
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[20]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime); // 20
					break;

				case 41: // Large Type 1, 2, 3, 4
				case 42:
				case 43:
				case 44:
				case 45: // Small Type 1, 2
				case 46:
					dX = (m_pEffectList[i]->m_sX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_sY) - m_sViewPointY;
					m_pEffectSpr[21]->PutFadeSprite(dX, dY, 48, dwTime);
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					if ((8 * (m_pEffectList[i]->m_sType - 41) + cTempFrame) < (8 * (m_pEffectList[i]->m_sType - 41) + 7))
					{
						iDvalue = -8 * (6 - cTempFrame);
						m_pEffectSpr[21]->PutTransSpriteRGB(dX, dY, 8 * (m_pEffectList[i]->m_sType - 41) + cTempFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					}
					else
					{
						if ((cTempFrame - 5) >= 8) cTempFrame = ((cTempFrame - 5) - 8) + 5;
						m_pEffectSpr[21]->PutSpriteFast(dX, dY, 8 * (m_pEffectList[i]->m_sType - 41) + (cTempFrame - 5), dwTime);
					}
					break;

				case 47:
				case 48:
				case 49: // Blizzard
					dX = (m_pEffectList[i]->m_sX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_sY) - m_sViewPointY;
					m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutRevTransSprite(dX, dY, 0, dwTime);
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					//PutString(dX, dY, "*",Color(255,255,255,255));
					if (cTempFrame < 7)
					{
						iDvalue = -8 * (6 - cTempFrame);
						m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutTransSpriteRGB(dX, dY, cTempFrame + 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					else
					{
						if (cTempFrame >= 8) cTempFrame = cTempFrame % 8;
						m_pEffectSpr[m_pEffectList[i]->m_sType - 1]->PutSpriteFast(dX, dY, cTempFrame + 1, dwTime);
					}
					break;

				case 50:
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;

					if (cTempFrame <= 6)
					{
						iDvalue = 0;
						m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
					}
					else
					{
						iDvalue = -5 * (cTempFrame - 6);
						m_pEffectSpr[22]->PutTransSpriteRGB(dX, dY, 6, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					}
					break;

				case 51: //
					cTempFrame = m_pEffectList[i]->m_cFrame + 11; //15
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[28]->PutTransSprite25(dX, dY, cTempFrame, dwTime); //20
					break;


				case 52: // Protection Ring commente par siementec, a voir
				/*			cTempFrame = m_pEffectList[i]->m_cFrame;
					dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					m_pEffectSpr[24]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				*/
					break;


				case 53: // Hold Twist
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					if (cTempFrame < 0) cTempFrame = 0;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[25]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime); //25
					break;

				case 54: //  star twingkling (effect armes brillantes)
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) cTempFrame = 0;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[28]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					break;

				case 55: //
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) cTempFrame = 0;
					dX = (m_pEffectList[i]->m_mX);
					dY = (m_pEffectList[i]->m_mY);
					m_pEffectSpr[28]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 56: // Mass-Chill-Wind
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) cTempFrame = 0;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[29]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 57:  // absent (220 et 351)
					break;

				case 60:  //
				case 181: // MS
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					if (cTempFrame > 4)
					{
						cTempFrame = cTempFrame / 4;
					}
					if (cTempFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						m_pEffectSpr[31]->PutSpriteFast(dX, dY, 15 + cTempFrame, dwTime);
						m_pEffectSpr[31]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					}
					break;

				case 61: // Fire aura on ground (crueffect1, 1)
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[32]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 62: // MS strike
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					if (cTempFrame > 0)
					{
						cTempFrame = cTempFrame - 1;
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame / 3);
					}
					break;

				case 63: // Fire explosion (crueffect1, 2)
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[33]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 64: // effet halo blancchatre
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[34]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 65: // MS from crusade striking
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					cTempFrame = cTempFrame / 6;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[31]->PutRevTransSprite(dX, dY, 20 + cTempFrame, dwTime, cTempFrame >> 2);
					break;

				case 66: // MS explodes on the ground
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[39]->PutRevTransSprite(dX, dY, cTempFrame, dwTime);
					m_pEffectSpr[39]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 67: // MS fire with smoke
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					switch (rand() % 3)
					{
						case 0: m_pEffectSpr[0]->PutTransSprite25_NoColorKey(dX, dY + 20, 1, dwTime); break;
						case 1: m_pEffectSpr[0]->PutTransSprite50_NoColorKey(dX, dY + 20, 1, dwTime); break;
						case 2: m_pEffectSpr[0]->PutTransSprite70_NoColorKey(dX, dY + 20, 1, dwTime); break;
					}
					m_pEffectSpr[35]->PutTransSprite70_NoColorKey(dX, dY, cTempFrame / 3, dwTime);
					break;

				case 68: // worm-bite
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					if (cTempFrame <= 11)
					{
						m_pEffectSpr[40]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
						m_pEffectSpr[41]->PutTransSprite50_NoColorKey(dX, dY, cTempFrame, dwTime);
						m_pEffectSpr[44]->PutRevTransSprite(dX - 2, dY - 3, cTempFrame, dwTime);
						m_pEffectSpr[44]->PutTransSprite_NoColorKey(dX - 4, dY - 3, cTempFrame, dwTime);
					}
					else
					{
						switch (cTempFrame)
						{
							case 12:
							case 13:
							case 14: m_pEffectSpr[40]->PutSpriteFast(dX, dY, 11, dwTime); break;
							case 15: m_pEffectSpr[40]->PutTransSprite70_NoColorKey(dX, dY, 11, dwTime); break;
							case 16: m_pEffectSpr[40]->PutTransSprite50_NoColorKey(dX, dY, 11, dwTime); break;
							case 17: m_pEffectSpr[40]->PutTransSprite25_NoColorKey(dX, dY, 11, dwTime); break;
						}
					}
					break;

				case 69: // identique au cas 70
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[42]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 70: // identique au cas 69
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[43]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 71: // absent v220 et v351
					break;

				case 72: // Blizzard
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					if (cTempFrame <= 8)
					{
						iDvalue = 0;
						m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, cTempFrame, iDvalue, iDvalue, iDvalue, dwTime);
					}
					else
					{
						iDvalue = -1 * (cTempFrame - 8);
						m_pEffectSpr[51]->PutTransSpriteRGB(dX, dY, 8, iDvalue, iDvalue, iDvalue, dwTime);	// RGB2
					}
					break;

				case 73: // absent v220 et v351
				case 74: // absent v220 et v351
				case 75: // absent v220 et v351
				case 76: // absent v220 et v351
				case 77: // absent v220 et v351
					break;

				case 80:
				case 196: // Earth-Shock-Wave
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[91]->PutSpriteFast(dX, dY, cTempFrame, dwTime); //Nbe d'arguments modifis ds la 351....
					m_pEffectSpr[92]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					break;

				case 81: // Snoopy: Ajout StormBlade
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = m_pEffectList[i]->m_cFrame;
					m_pEffectSpr[100]->PutTransSprite_NoColorKey(dX + 70, dY + 70, cTempFrame, dwTime);
					break;

				case 82: // Gate (apocalypse)
					cTempFrame = m_pEffectList[i]->m_cFrame;
					//m_pEffectSpr[101]->PutTransSprite_NoColorKey(320, 480, cTempFrame, dwTime);
					m_pEffectSpr[101]->PutTransSprite_NoColorKey(GetWidth() / 2, GetHeight(), cTempFrame, dwTime); // 800x600 xRisenx
					break;

				case 100: // Magic Missile
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 3, dwTime);
					break;

				case 101: // Heal
				case 121: // Great-Heal
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					m_pEffectSpr[50]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 102: // Create Food
				case 124: // Protection from N.M
				case 125: // Hold-Person
				case 126: // Possession
				case 127: // Poison
				case 133: // Protect-From-Magic
				case 134: // Detect-Invisibility
				case 135: // Paralyze
				case 136: // Cure
				case 142: // Confuse Language
				case 152: // Polymorph
				case 153: // Mass-Poison
				case 162: // Confusion
				case 171: // Mass-Confusion
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					if (cTempFrame < 5)
						m_pEffectSpr[4]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[4]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 110: // Energy-Bolt
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY, 2 + (rand() % 4), dwTime);
					break;

				case 111: // Staminar Drain
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					m_pEffectSpr[49]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 112: // Recall
				case 131: // Summon-Creature
				case 132: // Invisibility
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					m_pEffectSpr[52]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

					//case 132: // Invisibility
					//	cTempFrame = m_pEffectList[i]->m_cFrame;
					//	if (cTempFrame < 0) break;
					//	dX  = (m_pEffectList[i]->m_dX*32)  - m_sViewPointX;
					//	dY  = (m_pEffectList[i]->m_dY*32)  - m_sViewPointY;
					//	iDvalue = (cTempFrame - 5)*(-5);
					//	m_pEffectSpr[172]->PutTransSprite_NoColorKey(dX-10, dY-100, m_pEffectList[i]->m_cFrame, dwTime);
					//	break;

				case 113: // Defense Shield
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					if (cTempFrame < 6)
						m_pEffectSpr[62]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[62]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 120: // Fire Ball
				case 130: // Fire Strike
				case 161: // Mass-Fire-Strike
				case 251: //
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					break;

				case 122: // Absent v220 et 351
					break;

				case 123: // Staminar-Recovery
				case 128: // Great-Staminar-Recovery
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					m_pEffectSpr[56]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 137: // Lightning Arrow
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					tX = (m_pEffectList[i]->m_mX2) - m_sViewPointX;
					tY = (m_pEffectList[i]->m_mY2) - m_sViewPointY;
					iErr = 0;
					m_Misc.GetPoint(dX, dY, tX, tY, &rX, &rY, &iErr, 15);
					m_Misc.GetPoint(dX, dY, tX, tY, &rX2, &rY2, &iErr, 30);
					m_Misc.GetPoint(dX, dY, tX, tY, &rX3, &rY3, &iErr, 45);
					m_Misc.GetPoint(dX, dY, tX, tY, &rX4, &rY4, &iErr, 60);
					m_Misc.GetPoint(dX, dY, tX, tY, &rX5, &rY5, &iErr, 75);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX5, rY5, cTempFrame, dwTime);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite25_NoColorKey(rX4, rY4, cTempFrame, dwTime);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX3, rY3, cTempFrame, dwTime);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite50_NoColorKey(rX2, rY2, cTempFrame, dwTime);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite70_NoColorKey(rX, rY, cTempFrame, dwTime);
					cTempFrame = (m_pEffectList[i]->m_cDir - 1) * 4 + (rand() % 4);
					if (cTempFrame < 0) break;
					m_pEffectSpr[10]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					break;

				case 143: // Lightning
					_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - GetWidth(),
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);
					_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - GetWidth(),
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX + 4, m_pEffectList[i]->m_rY + 2, 2);
					_DrawThunderEffect(m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY - GetWidth(),
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX - 2, m_pEffectList[i]->m_rY - 2, 2);
					break;

				case 144: // Great-Defense-Shield
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-5);
					if (cTempFrame < 9)
						m_pEffectSpr[63]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[63]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 151: // Lightning Bolt
					_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX, m_pEffectList[i]->m_rY, 1);

					_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX + 2, m_pEffectList[i]->m_rY - 2, 2);

					_DrawThunderEffect(m_pEffectList[i]->m_mX - m_sViewPointX, m_pEffectList[i]->m_mY - m_sViewPointY,
						m_pEffectList[i]->m_dX * 32 - m_sViewPointX, m_pEffectList[i]->m_dY * 32 - m_sViewPointY,
						m_pEffectList[i]->m_rX - 2, m_pEffectList[i]->m_rY - 2, 2);
					break;

				case 165: // Absolute-Magic-Protect
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY; // 53 = APFM buble
					m_pEffectSpr[53]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 166: // Armor-Break
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[55]->PutRevTransSprite(dX, dY + 35, m_pEffectList[i]->m_cFrame, dwTime);
					m_pEffectSpr[54]->PutTransSprite50(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 176: // Cancellation
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[90]->PutTransSprite_NoColorKey(dX + 50, dY + 85, cTempFrame, dwTime);
					break;

				case 177: // Illusion-Movement
				case 180: // Illusion
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-3);
					if (cTempFrame < 9)	m_pEffectSpr[60]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[60]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

				case 182: //Mass-Magic-Missile
					cTempFrame = m_pEffectList[i]->m_cFrame;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[98]->PutTransSprite(dX, dY, cTempFrame, dwTime, 0);
					break;

				case 183: // Inhibition-Casting
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-3);
					if (cTempFrame < 9) m_pEffectSpr[94]->PutTransSprite_NoColorKey(dX, dY + 40, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[94]->PutTransSpriteRGB(dX, dY + 40, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime);
					break;

				case 184: //Magic-Shield xRisenx
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY; // 53 = APFM buble
					m_pEffectSpr[53]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 245: // Strike-Of-The-Ghosts
				case 187:
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;

					m_pEffectSpr[158]->PutTransSprite70(dX, dY, cTempFrame, dwTime);
					m_pEffectSpr[154]->PutTransSprite70(dX, dY, cTempFrame, dwTime);

					break;

				case 188: // Lightning Storm xRisenx
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					/*m_pEffectSpr[91]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
					m_pEffectSpr[92]->PutTransSprite(dX, dY, cTempFrame, dwTime);*/
					break;

					//case 104: // Thunder Storm xRisenx
					//	cTempFrame = m_pEffectList[i]->m_cFrame;
					//	if (cTempFrame < 0) break;
					//	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					//	dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					//	m_pEffectSpr[169]->PutSpriteFast(dX, dY, cTempFrame, dwTime); //effect11.pak [2]
					//	m_pEffectSpr[177]->PutTransSprite(dX, dY, cTempFrame, dwTime); //effect11.pak [3]
					//	break;

					//case 105: // Inferno xRisenx
					//	cTempFrame = m_pEffectList[i]->m_cFrame;
					//	if (cTempFrame < 0) break;
					//	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					//	dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					//	/*m_pEffectSpr[91]->PutSpriteFast(dX, dY, cTempFrame, dwTime);
					//	m_pEffectSpr[92]->PutTransSprite(dX, dY, cTempFrame, dwTime);*/
					//	break;

					// From what i understand this is where you make the spell animation when its in the air.

					//case 106: // Hell-Fire xRisenx
					//	cTempFrame = m_pEffectList[i]->m_cFrame;
					//	if (cTempFrame < 0) break;
					//	if (cTempFrame > 4)
					//	{	cTempFrame = cTempFrame / 4;
					//	}
					//	if (cTempFrame >= 0)
					//	{	dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					//		dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					//		m_pEffectSpr[135]->PutSpriteFast(dX, dY, 15 + cTempFrame, dwTime);
					//		m_pEffectSpr[135]->PutSpriteFast(dX, dY+65, 15 + cTempFrame, dwTime);
					//		m_pEffectSpr[135]->PutSpriteFast(dX, dY-65, 15 + cTempFrame, dwTime);
					//		//m_pEffectSpr[31]->PutSpriteFast(dX+65, dY+65, 15 + cTempFrame, dwTime);
					//		m_pEffectSpr[135]->PutTransSprite(dX, dY, cTempFrame, dwTime);
					//		m_pEffectSpr[135]->PutTransSprite(dX, dY+65, cTempFrame, dwTime);
					//		m_pEffectSpr[135]->PutTransSprite(dX, dY-65, cTempFrame, dwTime);
					//		//m_pEffectSpr[31]->PutTransSprite(dX+65, dY+65, cTempFrame, dwTime);
					//		m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					//	}
					//	//dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
					//	//dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
					//	//cTempFrame = (m_pEffectList[i]->m_cDir-1)*4 + (rand() % 4);

					//	//if (cTempFrame < 0) break;
					//	//m_pEffectSpr[5]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					//	break;

				case 244: // Snoopy: dplac pour nvx sorts: Aura du casteur de Mass MagicMissile
				//case 184: // Aura du casteur de Mass MagicMissile
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = m_pEffectList[i]->m_mX - m_sViewPointX;
					dY = m_pEffectList[i]->m_mY - m_sViewPointY;
					m_pEffectSpr[96]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
					break;

				case 190: // Mass-Illusion
				case 195: // Mass-Illusion-Movement
					cTempFrame = m_pEffectList[i]->m_cFrame;
					if (cTempFrame < 0) break;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					iDvalue = (cTempFrame - 5) * (-3);
					if (cTempFrame < 9) m_pEffectSpr[61]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					else m_pEffectSpr[61]->PutTransSpriteRGB(dX, dY, m_pEffectList[i]->m_cFrame, iDvalue, iDvalue, iDvalue, dwTime); // RGB2
					break;

					//case 192: // Mage Hero set effect
				case 242:
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[87]->PutTransSprite_NoColorKey(dX + 50, dY + 57, m_pEffectList[i]->m_cFrame, dwTime);
					break;

					//case 193: // War Hero set effect
				case 243:
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[88]->PutTransSprite_NoColorKey(dX + 65, dY + 80, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 194: // Resurrection
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[99]->PutTransSprite(dX, dY, m_pEffectList[i]->m_cFrame, dwTime, 0);
					break;

				case 200: // shotstar fall on ground
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[133]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
					break;

				case 201: // shotstar fall on ground
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[134]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
					break;

				case 202: // shotstar fall on ground
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[135]->PutTransSprite_NoColorKey(dX, dY, (rand() % 15), dwTime);
					break;

				case 203: // explosion feu apoc
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[136]->PutTransSprite_NoColorKey(dX, dY, (rand() % 18), dwTime);
					break;

				case 204: // Faille oblique
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[137]->PutTransSprite_NoColorKey(dX, dY, (rand() % 12), dwTime);
					break;

				case 205: // Faille horizontale
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[138]->PutTransSprite_NoColorKey(dX, dY, (rand() % 12), dwTime);
					break;

				case 206: // steams
					dX = m_pEffectList[i]->m_mX;
					dY = m_pEffectList[i]->m_mY;
					m_pEffectSpr[139]->PutTransSprite_NoColorKey(dX, dY, (rand() % 20), dwTime);
					break;

				case 250: // Gate (round one)
					dX = m_pEffectList[i]->m_mX - m_sViewPointX;
					dY = m_pEffectList[i]->m_mY - m_sViewPointY;
					m_pEffectSpr[103]->PutTransSprite_NoColorKey(dX, dY, (rand() % 3), dwTime);
					break;

				case 252: // burst (lisgt salmon color)
					dX = m_pEffectList[i]->m_mX - m_sViewPointX;
					dY = m_pEffectList[i]->m_mY - m_sViewPointY;
					m_pEffectSpr[104]->PutTransSprite_NoColorKey(dX, dY, (rand() % 3), dwTime);
					break;
			}
		}
}


void helbreath::DrawEffectLights()
{
	int i, dX, dY, iDvalue;
	uint64_t dwTime = m_dwCurTime;
	char  cTempFrame;

	for (i = 0; i < MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0)
		{
			switch (m_pEffectList[i]->m_sType)
			{
				case 1:
					break;

				case 2:
					break;

				case 4:
					break;

				case 5:	// Fire Explosion
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						iDvalue = (m_pEffectList[i]->m_cFrame - 7) * (-1);
						if (m_pEffectList[i]->m_cFrame < 6)
							m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
						else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					break;

				case 6:	 // Energy Bolt
				case 10: // Lightning Arrow
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						iDvalue = (m_pEffectList[i]->m_cFrame - 9) * (-1);
						if (m_pEffectList[i]->m_cFrame < 8)
							m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
						else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					break;
				case 7: // Magic Missile Explosion
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						iDvalue = (m_pEffectList[i]->m_cFrame - 2) * (-1);
						if (m_pEffectList[i]->m_cFrame < 2)
							m_pEffectSpr[0]->PutTransSprite_NoColorKey(dX, dY + 30, 1, dwTime);
						else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					break;

				case 16:
				case 61:
				case 66:
				case 100:
				case 110:
				case 120:
				case 130:
				case 137: // Lightning arrow
				//case 165: // APFM fixed green light
					// Light on ground below the flying effect
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					iDvalue = -5;
					m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY + 30, 1, iDvalue, iDvalue, iDvalue, dwTime);
					break;

				case 69:
				case 70:
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[0]->PutTransSprite25(dX, dY + 30, 1, dwTime);
					break;

				case 33: //
					/*
					if (m_pEffectList[i]->m_cFrame >= 0) {
						dX  = (m_pEffectList[i]->m_mX)  - m_sViewPointX;
						dY  = (m_pEffectList[i]->m_mY)  - m_sViewPointY;
						iDvalue = (m_pEffectList[i]->m_cFrame - 9)*(-1);
						if (m_pEffectList[i]->m_cFrame < 8)
							 m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
						else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					*/
					break;

				case 40: //
				case 56:
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						iDvalue = (m_pEffectList[i]->m_cFrame - 7) * (-1);
						if (m_pEffectList[i]->m_cFrame < 6)
							m_pEffectSpr[0]->PutTransSprite(dX, dY, 1, dwTime);
						else m_pEffectSpr[0]->PutTransSpriteRGB(dX, dY, 1, iDvalue, iDvalue, iDvalue, dwTime);
					}
					break;

				case 52: // Protection Ring
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						m_pEffectSpr[24]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					}
					break;

				case 57: // Spell Load Animation xRisenx
					if (m_pEffectList[i]->m_cFrame >= 0)
					{
						dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
						dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
						m_pEffectSpr[30]->PutTransSprite_NoColorKey(dX - 35, dY - 52, m_pEffectList[i]->m_cFrame, dwTime);
					}
					break;

				case 73:
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[74]->PutTransSprite(dX, dY - 34, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 74:
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[75]->PutTransSprite(dX, dY + 35, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 75: // Icegolem
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[76]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 76:// Icegolem
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[77]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 77:// Icegolem
					dX = (m_pEffectList[i]->m_mX) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_mY) - m_sViewPointY;
					m_pEffectSpr[78]->PutTransSprite25(dX + m_pEffectList[i]->m_dX * m_pEffectList[i]->m_cFrame, dY + m_pEffectList[i]->m_dY * m_pEffectList[i]->m_cFrame, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 150: // Berserk : Cirlcle 6 magic
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[58]->PutTransSprite_NoColorKey(dX, dY, m_pEffectList[i]->m_cFrame, dwTime);
					break;

				case 180: // Ilusion
				case 190: // Mass Illusion
					cTempFrame = m_pEffectList[i]->m_cFrame;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[59]->PutTransSprite_NoColorKey(dX, dY, cTempFrame, dwTime);
					//if( cTempFrame < 9 ) m_pEffectSpr[59]->PutTransSprite_NoColorKey( dX, dY, cTempFrame, dwTime );
					//else m_pEffectSpr[59]->PutSpriteFast( dX, dY, cTempFrame, dwTime );
					break;

				case 177: // Illusion mvt
				case 195: // Mass Illusion mvt
					cTempFrame = m_pEffectList[i]->m_cFrame;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[102]->PutTransSprite_NoColorKey(dX, dY + 30, cTempFrame, dwTime);
					break;

				case 183: // Inhibition casting
					cTempFrame = m_pEffectList[i]->m_cFrame;
					dX = (m_pEffectList[i]->m_dX * 32) - m_sViewPointX;
					dY = (m_pEffectList[i]->m_dY * 32) - m_sViewPointY;
					m_pEffectSpr[95]->PutTransSprite_NoColorKey(dX, dY + 40, cTempFrame, dwTime);
					break;
			}
		}
}


void helbreath::_LoadShopMenuContents(char cType)
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE * pFile;
	uint32_t  dwFileSize;
	char * pBuffer;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));
	fmt::format_to(cTemp, "contents%d", cType);
	strcat(cFileName, "data\\shops");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, "Shop");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFileA(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else
	{
		pBuffer = new char[dwFileSize + 1];
		ZeroMemory(pBuffer, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);

		__bDecodeContentsAndBuildItemForSaleList(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
}

bool helbreath::__bDecodeContentsAndBuildItemForSaleList(char * pBuffer)
{
	char * pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemForSaleListIndex = 0;
	class CStrTok * pStrTok;

	pContents = pBuffer;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			//
			switch (cReadModeA)
			{
				case 1:
					switch (cReadModeB)
					{
						case 1:
							ZeroMemory(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, sizeof(m_pItemForSaleList[iItemForSaleListIndex]->m_cName));
							memcpy(m_pItemForSaleList[iItemForSaleListIndex]->m_cName, token, strlen(token));
							cReadModeB = 2;
							break;
						case 2:	// m_cItemType
							m_pItemForSaleList[iItemForSaleListIndex]->m_cItemType = atoi(token);
							cReadModeB = 3;
							break;
						case 3: // m_cEquipPos
							m_pItemForSaleList[iItemForSaleListIndex]->m_cEquipPos = atoi(token);
							cReadModeB = 4;
							break;
						case 4: // m_sItemEffectType
							//m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectType = atoi(token);
							cReadModeB = 5;
							break;
						case 5:	// m_sItemEffectValue1
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue1 = atoi(token);
							cReadModeB = 6;
							break;
						case 6: // m_sItemEffectValue2
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue2 = atoi(token);
							cReadModeB = 7;
							break;
						case 7: // m_sItemEffectValue3
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue3 = atoi(token);
							cReadModeB = 8;
							break;
						case 8: // m_sItemEffectValue4
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue4 = atoi(token);
							cReadModeB = 9;
							break;
						case 9: // m_sItemEffectValue5
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue5 = atoi(token);
							cReadModeB = 10;
							break;
						case 10: // m_sItemEffectValue6
							m_pItemForSaleList[iItemForSaleListIndex]->m_sItemEffectValue6 = atoi(token);
							cReadModeB = 11;
							break;
						case 11: // m_wMaxLifeSpan
							m_pItemForSaleList[iItemForSaleListIndex]->m_wMaxLifeSpan = (uint16_t)atoi(token);
							cReadModeB = 12;
							break;
						case 12: // m_sMaxFixCount
							//m_pItemForSaleList[iItemForSaleListIndex]->m_sMaxFixCount = atoi(token);
							cReadModeB = 13;
							break;
						case 13: // m_sSprite
							m_pItemForSaleList[iItemForSaleListIndex]->m_sSprite = atoi(token);
							cReadModeB = 14;
							break;
						case 14: // m_sSpriteFrame
							m_pItemForSaleList[iItemForSaleListIndex]->m_sSpriteFrame = atoi(token);
							cReadModeB = 15;
							break;
						case 15: // m_wPrice
							m_pItemForSaleList[iItemForSaleListIndex]->m_wPrice = atoi(token);
							cReadModeB = 16;
							break;
						case 16: // m_wWeight
							m_pItemForSaleList[iItemForSaleListIndex]->m_wWeight = atoi(token);
							cReadModeB = 17;
							break;
						case 17: // Appr Value
							//m_pItemForSaleList[iItemForSaleListIndex]->m_cApprValue = atoi(token);
							cReadModeB = 18;
							break;
						case 18: // m_cSpeed
							m_pItemForSaleList[iItemForSaleListIndex]->m_cSpeed = atoi(token);
							cReadModeB = 19;
							break;
						case 19: // Level Limit
							m_pItemForSaleList[iItemForSaleListIndex]->m_sLevelLimit = atoi(token);
							m_pItemForSaleList[iItemForSaleListIndex]->m_dwCount = 1;
							cReadModeA = 0;
							cReadModeB = 0;
							iItemForSaleListIndex++;
							break;
					}
					break;

				default:
					break;
			}
		}
		else
		{
			if (memcmp(token, "ItemForSale", 4) == 0)
			{
				if (iItemForSaleListIndex >= MAXMENUITEMS)
				{
					delete pStrTok;
					return false;
				}
				cReadModeA = 1;
				cReadModeB = 1;
				m_pItemForSaleList[iItemForSaleListIndex] = new class CItem;
			}
		}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}

bool helbreath::CreateRenderer(bool fs)
{
    fullscreen = fs;

    fmt::format_to(winName, "Helbreath Xtreme {}.{}.{} Renderer: {}", UPPER_VERSION, LOWER_VERSION, PATCH_VERSION, _renderer);

    sf::ContextSettings context;
    // context.antialiasingLevel = 16;

    window.create(sf::VideoMode(screenwidth, screenheight), winName, (fullscreen ? sf::Style::Fullscreen : (sf::Style::Close)), context);

    handle = window.getSystemHandle();

    if (vsync)
        window.setVerticalSyncEnabled(true);
    else
        window.setVerticalSyncEnabled(false);

	frame_limit = 0;

    visible.create(screenwidth_v, screenheight_v);
    bg.create(screenwidth_v + 300, screenheight_v + 300);
    charselect.create(256, 256);

    sf::Font s;
    s.loadFromFile(workingdirectory + "fonts/Arya-Regular.ttf");
    _font.insert(std::pair<std::string, sf::Font>("arya", s));

    s.loadFromFile(workingdirectory + "fonts/OpenSans-Regular.ttf");
    _font.insert(std::pair<std::string, sf::Font>("default", s));

    s.loadFromFile(workingdirectory + "fonts/PoetsenOne-Regular.ttf");
    _font.insert(std::pair<std::string, sf::Font>("test", s));

    sf::Image img;
    img.create(screenwidth_v, screenheight_v);
//     _html_tex.loadFromImage(img);
//     _html_spr.setTexture(_html_tex);

    create_load_list();

    _text.setFont(_font.at("arya"));

    return true;
}

bool helbreath::bInitMagicCfgList()
{
	char cFn[255], cTemp[255];
	char * pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicCfgListIndex = 0;
	class CStrTok * pStrTok;
	HANDLE hFile;
	FILE * pFile;
	uint32_t  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	// CLEROTH - MAGIC CFG
	strcpy(cTemp, "magiccfg.txt");

	strcat(cFn, "data\\shops");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFileA(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else
	{
		pContents = new char[dwFileSize + 1];
		ZeroMemory(pContents, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			switch (cReadModeA)
			{
				case 1:
					switch (cReadModeB)
					{
						case 1:
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							if (m_pMagicCfgList[atoi(token)] != 0)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pMagicCfgList[atoi(token)] = new class CMagic;
							iMagicCfgListIndex = atoi(token);

							cReadModeB = 2;
							break;

						case 2:
							ZeroMemory(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, sizeof(m_pMagicCfgList[iMagicCfgListIndex]->m_cName));
							memcpy(m_pMagicCfgList[iMagicCfgListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;

						case 3: // m_sValue1
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pMagicCfgList[iMagicCfgListIndex]->m_sValue1 = atoi(token);
							cReadModeB = 4;
							break;

						case 4: // m_sValue2	// INT
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pMagicCfgList[iMagicCfgListIndex]->m_sValue2 = atoi(token);
							cReadModeB = 5;
							break;

						case 5: // m_sValue3	// COST
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pMagicCfgList[iMagicCfgListIndex]->m_sValue3 = atoi(token);
							cReadModeB = 6;
							break;

							// CLEROTH MAGIC CFG
						case 6: // m_sValue4	// STR
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pMagicCfgList[iMagicCfgListIndex]->m_sValue4 = atoi(token);
							cReadModeB = 7;
							break;

						case 7: // m_sValue5
							cReadModeB = 8;
							break;

						case 8: // m_sValue6
							cReadModeB = 9;
							break;

						case 9: // m_bIsVisible
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							if (atoi(token) == 0) m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = false;
							else m_pMagicCfgList[iMagicCfgListIndex]->m_bIsVisible = true;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		}
		else
		{
			if (memcmp(token, "magic", 5) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0))
	{
		return false;
	}

	return true;
}

bool helbreath::bCheckImportantFile()
{
	HANDLE hFile;

	hFile = CreateFileA("SPRITES\\TREES1.PAK", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	// FileSize : 1846406.... Anti Tree1.pak hack....inutile ca peut se modifier sans changer la taille!
	if (GetFileSize(hFile, 0) != 2945524)//2,949,120 (2,945,524 b
	{
		CloseHandle(hFile);
		return false;
	}

	CloseHandle(hFile);
	return true;
}

bool helbreath::bInitSkillCfgList()
{
	char cFn[255], cTemp[255];
	char * pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillCfgListIndex = 0;
	class CStrTok * pStrTok;
	HANDLE hFile;
	FILE * pFile;
	uint32_t  dwFileSize;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFn, sizeof(cFn));

	strcpy(cTemp, "Skillcfg.txt");
	strcat(cFn, "data\\shops");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, cTemp);

	hFile = CreateFileA(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) return false;
	else
	{
		pContents = new char[dwFileSize + 1];
		ZeroMemory(pContents, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			switch (cReadModeA)
			{
				case 1:
					switch (cReadModeB)
					{
						case 1:
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							if (m_pSkillCfgList[atoi(token)] != 0)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pSkillCfgList[atoi(token)] = new class CSkill;
							iSkillCfgListIndex = atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							ZeroMemory(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, sizeof(m_pSkillCfgList[iSkillCfgListIndex]->m_cName));
							memcpy(m_pSkillCfgList[iSkillCfgListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;

						case 3: // m_bIsUseable
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pSkillCfgList[iSkillCfgListIndex]->m_bIsUseable = (bool)atoi(token);
							cReadModeB = 4;
							break;

						case 4: // m_cUseMethod
							if (_bGetIsStringIsNumber(token) == false)
							{
								delete[] pContents;
								delete pStrTok;
								return false;
							}
							m_pSkillCfgList[iSkillCfgListIndex]->m_cUseMethod = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		}
		else
		{
			if (memcmp(token, "skill", 5) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0))
	{
		return false;
	}

	return true;
}

bool helbreath::_bGetIsStringIsNumber(char * pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}

void helbreath::RequestFullObjectData(uint64_t wObjectID)
{
    char cMsg[256];
    int iRet = 0;
    uint32_t * dwp;
    uint64_t * wp;

    ZeroMemory(cMsg, sizeof(cMsg));

    dwp = (uint32_t *)(cMsg + INDEX4_MSGID);
    *dwp = MSGID_REQUEST_FULLOBJECTDATA;
    wp = (uint64_t *)(cMsg + INDEX2_MSGTYPE);
    *wp = wObjectID;

    write(cMsg, 10);
}

void helbreath::_ReadMapData(short sPivotX, short sPivotY, char * pData)
{
    int i;
    char * cp, ucHeader, cDir, cItemColor;
    std::string cName;
    short * sp, sTotal, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sSprite, sSpriteFrame, sItemSpr, sItemSprFrame, sDynamicObjectType, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue; // Re-Coding Sprite xRisenx
    int iStatus;
    int * ip, iApprColor;
    uint16_t wObjectID;
    uint16_t * wp, wDynamicObjectID;

    cp = pData;
    m_sVDL_X = sPivotX;
    m_sVDL_Y = sPivotY;
    sp = (short *)cp;
    sTotal = *sp;
    cp += 2;
    for (i = 1; i <= sTotal; i++)
    {
        sp = (short *)cp;
        sX = *sp;
        cp += 2;
        sp = (short *)cp;
        sY = *sp;
        cp += 2;
        ucHeader = *cp;
        cp++;
        if (ucHeader & 0x01) // object ID
        {
            wp = (uint16_t *)cp;
            wObjectID = *wp;
            cp += 2;
            sp = (short *)cp;
            sType = *sp; // object type
            cp += 2;
            // dir
            cDir = *cp;
            cp++;
            if (wObjectID < 10000)
            {
                sp = (short *)cp;
                sAppr1 = *sp; // Appearance1
                cp += 2;
                sp = (short *)cp;
                sAppr2 = *sp; // Appearance2
                cp += 2;
                sp = (short *)cp;
                sAppr3 = *sp; // Appearance3
                cp += 2;
                sp = (short *)cp;
                sAppr4 = *sp; // Appearance4
                cp += 2;
                ip = (int *)cp;
                iApprColor = *ip;
                cp += 4;
                sp = (short *)cp;
                sHeadApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sBodyApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sArmApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sLegApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                ip = (int *)cp;
                iStatus = *ip;
                cp += 4;
                // Name
                cName.append(cp, 10);
                cp += 10;
            }
            else // NPC
            {
                //sAppr1 = sAppr3 = sAppr4 = 0;
                sAppr1 = sAppr3 = sAppr4 = sHeadApprValue = sBodyApprValue = sArmApprValue = sLegApprValue = 0; // Re-Coding Sprite xRisenx
                sp = (short *)cp;
                sAppr2 = *sp; // Appearance2
                cp += 2;
                ip = (int *)cp;
                iStatus = *ip;
                cp += 4;
                cName = fmt::format("npc%d", wObjectID - 10000);
            }
            m_pMapData->bSetOwner(wObjectID, /*sPivotX + */ sX, /*sPivotY + */ sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, iStatus, cName, OBJECTSTOP, 0, 0, 0);
        }
        if (ucHeader & 0x02) // object ID
        {
            wp = (uint16_t *)cp;
            wObjectID = *wp;
            cp += 2;
            sp = (short *)cp;
            sType = *sp; // object type
            cp += 2;
            cDir = *cp; // dir
            cp++;
            if (wObjectID < 10000)
            {
                sp = (short *)cp;
                sAppr1 = *sp; // Appearance1
                cp += 2;
                sp = (short *)cp;
                sAppr2 = *sp; // Appearance2
                cp += 2;
                sp = (short *)cp;
                sAppr3 = *sp; // Appearance3
                cp += 2;
                sp = (short *)cp;
                sAppr4 = *sp; // Appearance4
                cp += 2;
                ip = (int *)cp;
                iApprColor = *ip;
                cp += 4;
                sp = (short *)cp;
                sHeadApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sBodyApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sArmApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                sp = (short *)cp;
                sLegApprValue = *sp; // Re-Coding Sprite xRisenx
                cp += 2;
                // CLEROTH - CRASH BUG ( STATUS )
                // Status
                ip = (int *)cp;
                iStatus = *ip;
                cp += 4;
                // Name
                cName.append(cp, 10);
                cp += 10;
            }
            else // NPC
            {
                //sAppr1 = sAppr3 = sAppr4 = 0;
                sAppr1 = sAppr3 = sAppr4 = sHeadApprValue = sBodyApprValue = sArmApprValue = sLegApprValue = 0; // Re-Coding Sprite xRisenx
                sp = (short *)cp;
                sAppr2 = *sp; // Appearance2
                cp += 2;
                ip = (int *)cp;
                iStatus = *ip; // Status
                cp += 4;
                cName = fmt::format("npc%d", wObjectID - 10000);
            }
            m_pMapData->bSetDeadOwner(wObjectID, /*sPivotX + */ sX, /*sPivotY + */ sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, iStatus, cName);
        }
        if (ucHeader & 0x04)
        {
            sp = (short *)cp;
            sItemSpr = *sp;
            cp += 2;
            sp = (short *)cp;
            sItemSprFrame = *sp;
            cp += 2;
            ip = (int *)cp;
            cItemColor = *ip;
            cp += 4;
            m_pMapData->bSetItem(/*sPivotX + */ sX, /*sPivotY + */ sY, sItemSpr, sItemSprFrame, cItemColor, false);
        }
        if (ucHeader & 0x08) // Dynamic object
        {
            wp = (uint16_t *)cp;
            wDynamicObjectID = *wp;
            cp += 2;
            sp = (short *)cp;
            sDynamicObjectType = *sp;
            cp += 2;
            m_pMapData->bSetDynamicObject(/*sPivotX + */ sX, /*sPivotY + */ sY, wDynamicObjectID, sDynamicObjectType, false);
        }
    }
}

void helbreath::LogResponseHandler(char * pData, uint32_t size)
{
    StreamRead sr(pData, size);

    uint16_t wResponse;
    uint16_t wServerUpperVersion, wServerLowerVersion, wServerPatchVersion;
    string charname;

    uint32_t unused = sr.ReadInt();
    wResponse = sr.ReadShort();

	if (GameRecvMsgHandler(pData, size)) return;

    switch (wResponse)
    {
        case LOGRESMSGTYPE_CHARACTERDELETED:
            m_iAccountStatus = (int)sr.ReadByte();
            m_iTotalChar = (int)sr.ReadByte();
            m_pCharList.clear();

            if (m_iTotalChar > 10) //error
            {
                m_iTotalChar = 10; //
            }

            for (int i = 0; i < m_iTotalChar; i++)
            {
                shared_ptr<CCharInfo> character = make_shared<CCharInfo>();
                character->m_cName = sr.ReadString(10);
                if (sr.ReadByte() == 0)
                {
                    character->m_sSex = 0;
                    sr.position += 39;
                }
                else
                {
                    character->id = sr.ReadInt64();
                    character->m_sAppr1 = sr.ReadShort();
                    character->m_sAppr2 = sr.ReadShort();
                    character->m_sAppr3 = sr.ReadShort();
                    character->m_sAppr4 = sr.ReadShort();
                    character->m_sHeadApprValue = sr.ReadShort();
                    character->m_sBodyApprValue = sr.ReadShort();
                    character->m_sArmApprValue = sr.ReadShort();
                    character->m_sLegApprValue = sr.ReadShort();
                    character->m_sSex = sr.ReadShort();
                    character->m_sSkinCol = sr.ReadShort();
                    character->m_sLevel = sr.ReadShort();
                    character->m_iExp = sr.ReadInt64();
                    character->m_sStr = sr.ReadShort();
                    character->m_sVit = sr.ReadShort();
                    character->m_sDex = sr.ReadShort();
                    character->m_sInt = sr.ReadShort();
                    character->m_sMag = sr.ReadShort();
                    character->m_sChr = sr.ReadShort();
                    character->m_iApprColor = sr.ReadInt();
                    character->m_iYear = sr.ReadShort();
                    character->m_iMonth = sr.ReadShort();
                    character->m_iDay = sr.ReadShort();
                    character->m_iHour = sr.ReadShort();
                    character->m_iMinute = sr.ReadShort();
                    character->m_cMapName = sr.ReadString(10);
                }
                m_pCharList.push_back(character);
            }
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "3A");
            break;

        case LOGRESMSGTYPE_CONFIRM:
            loggedin = true;
            wServerUpperVersion = sr.ReadShort();
            wServerLowerVersion = sr.ReadShort();
            wServerPatchVersion = sr.ReadShort();
            m_iAccountStatus = (int)sr.ReadByte();
            m_iAccntYear = sr.ReadShort();
            m_iAccntMonth = sr.ReadShort();
            m_iAccntDay = sr.ReadShort();
            m_iIpYear = sr.ReadShort();
            m_iIpMonth = sr.ReadShort();
            m_iIpDay = sr.ReadShort();
            m_iTotalChar = (int)sr.ReadByte();
            m_pCharList.clear();

            if (m_iTotalChar > 10) //error
            {
                m_iTotalChar = 10; //
            }

            for (int i = 0; i < m_iTotalChar; i++)
            {
                shared_ptr<CCharInfo> character = make_shared<CCharInfo>();
                character->m_cName = sr.ReadString(10);
                if (sr.ReadByte() == 0)
                {
                    character->m_sSex = 0;
                    sr.position += 39;
                }
                else
                {
                    character->id = sr.ReadInt64();
                    character->m_sAppr1 = sr.ReadShort();
                    character->m_sAppr2 = sr.ReadShort();
                    character->m_sAppr3 = sr.ReadShort();
                    character->m_sAppr4 = sr.ReadShort();
                    character->m_sHeadApprValue = sr.ReadShort();
                    character->m_sBodyApprValue = sr.ReadShort();
                    character->m_sArmApprValue = sr.ReadShort();
                    character->m_sLegApprValue = sr.ReadShort();
                    character->m_sSex = sr.ReadShort();
                    character->m_sSkinCol = sr.ReadShort();
                    character->m_sLevel = sr.ReadShort();
                    character->m_iExp = sr.ReadInt64();
                    character->m_sStr = sr.ReadShort();
                    character->m_sVit = sr.ReadShort();
                    character->m_sDex = sr.ReadShort();
                    character->m_sInt = sr.ReadShort();
                    character->m_sMag = sr.ReadShort();
                    character->m_sChr = sr.ReadShort();
                    character->m_iApprColor = sr.ReadInt();
                    character->m_iYear = sr.ReadShort();
                    character->m_iMonth = sr.ReadShort();
                    character->m_iDay = sr.ReadShort();
                    character->m_iHour = sr.ReadShort();
                    character->m_iMinute = sr.ReadShort();
                    character->m_cMapName = sr.ReadString(10);
                }
                m_pCharList.push_back(character);
            }
            m_iTimeLeftSecAccount = sr.ReadInt();
            m_iTimeLeftSecIP = sr.ReadInt();
            for (unsigned char & i : key)
                i = sr.ReadByte();
            has_key = true;
            ChangeGameMode(GAMEMODE_ONSELECTCHARACTER);
            ClearContents_OnSelectCharacter();

#ifndef _DEBUG
            if (wServerUpperVersion != UPPER_VERSION || wServerLowerVersion != LOWER_VERSION || wServerPatchVersion != PATCH_VERSION)
                ChangeGameMode(GAMEMODE_ONVERSIONNOTMATCH);
#endif
            break;

        case LOGRESMSGTYPE_REJECT:
        {
            std::string rcv_string = sr.ReadString();
//             m_iBlockYear = sr.ReadInt();
//             m_iBlockMonth = sr.ReadInt();
//             m_iBlockDay = sr.ReadInt();
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "7H");
            break;
        }

        case LOGRESMSGTYPE_NOTENOUGHPOINT:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "7I");
            break;

        case LOGRESMSGTYPE_ACCOUNTLOCKED:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "7K");
            break;

        case LOGRESMSGTYPE_SERVICENOTAVAILABLE:
            break;
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "7");
            break;

        case LOGRESMSGTYPE_PASSWORDCHANGESUCCESS:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "6B");
            break;

        case LOGRESMSGTYPE_PASSWORDCHANGEFAIL:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "6C");
            break;

        case LOGRESMSGTYPE_PASSWORDMISMATCH:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "11");
            break;

        case LOGRESMSGTYPE_NOTEXISTINGACCOUNT:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "12");
            break;

        case LOGRESMSGTYPE_NEWACCOUNTCREATED:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "54");
            break;

        case LOGRESMSGTYPE_NEWACCOUNTFAILED:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "05");
            break;

        case LOGRESMSGTYPE_ALREADYEXISTINGACCOUNT:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "06");
            break;

        case LOGRESMSGTYPE_NOTEXISTINGCHARACTER:
            ChangeGameMode(GAMEMODE_ONMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "Not existing character!");
            break;

        case LOGRESMSGTYPE_NEWCHARACTERCREATED:
        {
            string cCharName = sr.ReadString(10);

            m_iTotalChar = (int)sr.ReadByte();
            m_pCharList.clear();

            if (m_iTotalChar > 10) //error
            {
                m_iTotalChar = 10; //
            }

            for (int i = 0; i < m_iTotalChar; i++)
            {
                shared_ptr<CCharInfo> character = make_shared<CCharInfo>();
                character->m_cName = sr.ReadString(10);
                if (sr.ReadByte() == 0)
                {
                    character->m_sSex = 0;
                    sr.position += 39;
                }
                else
                {
                    character->id = sr.ReadInt64();
                    character->m_sAppr1 = sr.ReadShort();
                    character->m_sAppr2 = sr.ReadShort();
                    character->m_sAppr3 = sr.ReadShort();
                    character->m_sAppr4 = sr.ReadShort();
                    character->m_sHeadApprValue = sr.ReadShort();
                    character->m_sBodyApprValue = sr.ReadShort();
                    character->m_sArmApprValue = sr.ReadShort();
                    character->m_sLegApprValue = sr.ReadShort();
                    character->m_sSex = sr.ReadShort();
                    character->m_sSkinCol = sr.ReadShort();
                    character->m_sLevel = sr.ReadShort();
                    character->m_iExp = sr.ReadInt64();
                    character->m_sStr = sr.ReadShort();
                    character->m_sVit = sr.ReadShort();
                    character->m_sDex = sr.ReadShort();
                    character->m_sInt = sr.ReadShort();
                    character->m_sMag = sr.ReadShort();
                    character->m_sChr = sr.ReadShort();
                    character->m_iApprColor = sr.ReadInt();
                    character->m_iYear = sr.ReadShort();
                    character->m_iMonth = sr.ReadShort();
                    character->m_iDay = sr.ReadShort();
                    character->m_iHour = sr.ReadShort();
                    character->m_iMinute = sr.ReadShort();
                    character->m_cMapName = sr.ReadString(10);
                }
                m_pCharList.push_back(character);
            }
            break;

            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "47");
            break;
        }

        case LOGRESMSGTYPE_NEWCHARACTERFAILED:
            break;
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "28");
            break;

        case LOGRESMSGTYPE_ALREADYEXISTINGCHARACTER:
            break;
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "29");
            break;

        case ENTERGAMERESTYPE_PLAYING:
            ChangeGameMode(GAMEMODE_ONQUERYFORCELOGIN);
            break;

        case ENTERGAMERESTYPE_CONFIRM:
        {
            socketmode(1);
            printf("ENTERGAMERESTYPE_CONFIRM\n");
            ConnectionEstablishHandler(SERVERTYPE_GAME);
        }
        break;

        case ENTERGAMERESTYPE_REJECT:
        {
			response = sr.ReadString();
            m_iBlockYear = sr.ReadInt();
            m_iBlockMonth = sr.ReadInt();
            m_iBlockDay = sr.ReadInt();
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
        }
        break;

        case ENTERGAMERESTYPE_FORCEDISCONN:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "3X");
            break;

        case LOGRESMSGTYPE_NOTEXISTINGWORLDSERVER:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "1Y");
            break;

        case LOGRESMSGTYPE_INPUTKEYCODE:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            sr.position += 6;
            switch (sr.ReadByte())
            {
                case 1:
                    strcpy(m_cMsg, "8U");
                    break; //MainMenu, Keycode registration success
                case 2:
                    strcpy(m_cMsg, "82");
                    break; //MainMenu, Not existing Account
                case 3:
                    strcpy(m_cMsg, "81");
                    break; //MainMenu, Password wrong
                case 4:
                    strcpy(m_cMsg, "8V");
                    break; //MainMenu, Invalid Keycode
                case 5:
                    strcpy(m_cMsg, "8W");
                    break; //MainMenu, Already Used Keycode
            }
            break;

        case LOGRESMSGTYPE_FORCECHANGEPASSWORD:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "6M");
            break;

        case LOGRESMSGTYPE_INVALIDKOREANSSN:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "1a");
            break;

        case LOGRESMSGTYPE_LESSTHENFIFTEEN:
            ChangeGameMode(GAMEMODE_ONLOGRESMSG);
            ZeroMemory(m_cMsg, sizeof(m_cMsg));
            strcpy(m_cMsg, "1b");
            break;
    }
    // 	delete m_pLSock;
    // 	gamemode = 0;
    // 	m_pGSock = m_pLSock = NULL;
}

void helbreath::_InitOnCreateNewCharacter()
{
	m_cGender = rand() % 2 + 1;
	m_cSkinCol = rand() % 3 + 1;
	m_cHairStyle = rand() % 8;
	m_cHairCol = rand() % 16;
	m_cUnderCol = rand() % 8;
	m_createStat[STAT_STR] = 10;
	m_createStat[STAT_VIT] = 10;
	m_createStat[STAT_DEX] = 10;
	m_createStat[STAT_INT] = 10;
	m_createStat[STAT_MAG] = 10;
	m_createStat[STAT_CHR] = 10;
}

void helbreath::ChangeGameMode(char cMode)
{
    std::unique_lock<std::mutex> l(gamemode_m);
    if (m_cGameMode == cMode)
    {
        // gamemode already set to this
        std::cout << "Duplicate game mode being set to [" << get_game_mode(cMode) << "]\n";
        return;
    }
    std::cout << "Changing game mode: " << get_game_mode(cMode) << "\n";
    if (m_cGameMode == GAMEMODE_ONLOADING)
        window.setFramerateLimit(frame_limit);
    m_cGameMode = cMode;
    m_cGameModeCount = 0;
    m_dwTime = G_dwGlobalTime;
    //update_ui_game_mode();
    if (cMode <= GAMEMODE_ONMAINMENU)
        close(1000, "gamemodechange");

    if (cMode == GAMEMODE_ONSELECTCHARACTER)
    {
        G_cSpriteAlphaDegree = 1;
        InitGameSettings();
    }

#ifndef SELECTSERVER
    if (cMode == GAMEMODE_ONSELECTSERVER)
    {
        ZeroMemory(m_cWorldServerName, sizeof(m_cWorldServerName));
        strcpy(m_cWorldServerName, NAME_WORLDNAME1);
        m_cGameMode = GAMEMODE_ONLOGIN;
    }
#endif
    }

bool helbreath::bReadIp()
{
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, SERVER_IP);
	m_iLogServerPort = SERVER_PORT;
	return true;
}

bool helbreath::bReadLoginConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char * cp, * token, cReadMode;
	char seps[] = "= ,\t\n";
	cReadMode = 0;
	// Get file size only
	hFile = CreateFileA(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFn, "rt");
	if (pFile == 0) goto DEFAULT_IP;
	cp = new char[dwFileSize + 2];
	ZeroMemory(cp, dwFileSize + 2);
	fread(cp, dwFileSize, 1, pFile);
	token = strtok(cp, seps);

	while (token != 0)
	{
		if (cReadMode != 0)
		{
			switch (cReadMode)
			{
				case 1: // log-server-address
					if (strlen(token) > 15)
					{
						delete[] cp;
						if (pFile != 0) fclose(pFile);
						goto DEFAULT_IP;
					}
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					strcpy(m_cLogServerAddr, token);
					cReadMode = 0;
					break;
				case 2: // log-server-port
					m_iLogServerPort = atoi(token);
					if (m_iLogServerPort == 0)
					{
						delete[] cp;
						if (pFile != 0) fclose(pFile);
						goto DEFAULT_IP;
					}
					cReadMode = 0;
					break;
				case 3: // game-server-mode
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{
						m_iGameServerMode = 1;  // Will no connect multi-hoster HB
											// but will connect from LAN even with bad router
					}
					if ((memcmp(token, "internet", 8) == 0) || (memcmp(token, "INTERNET", 8) == 0))
					{
						m_iGameServerMode = 2; // Default HB mode
					}
					cReadMode = 0;
					break;
			}
		}
		else
		{
			if (memcmp(token, "log-server-address", 18) == 0) cReadMode = 1;
			if (memcmp(token, "log-server-port", 15) == 0)    cReadMode = 2;
			if (memcmp(token, "game-server-mode", 16) == 0)   cReadMode = 3;
		}
		token = strtok(0, seps);
	}
	delete[] cp;
	if (pFile != 0) fclose(pFile);
	return true;
	DEFAULT_IP:
	ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
	strcpy(m_cLogServerAddr, SERVER_IP);
	m_iLogServerPort = SERVER_PORT;
	return true;
}

void helbreath::ReleaseUnusedSprites()
{
	int i;
	for (i = 0; i < MAXSPRITES; i++)
		if (m_pSprite[i] != 0)
		{
			if ((m_pSprite[i]->m_bIsSurfaceEmpty == false) && (m_pSprite[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pSprite[i]->m_dwRefTime) > 60000) m_pSprite[i]->_iCloseSprite();

			}
		}
	for (i = 0; i < MAXTILES; i++)
		if (m_pTileSpr[i] != 0)
		{
			if ((m_pTileSpr[i]->m_bIsSurfaceEmpty == false) && (m_pTileSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pTileSpr[i]->m_dwRefTime) > 60000) m_pTileSpr[i]->_iCloseSprite();
			}
		}
	for (i = 0; i < MAXEFFECTSPR; i++)
		if (m_pEffectSpr[i] != 0)
		{
			if ((m_pEffectSpr[i]->m_bIsSurfaceEmpty == false) && (m_pEffectSpr[i]->m_bOnCriticalSection == false))
			{
				if ((G_dwGlobalTime - m_pEffectSpr[i]->m_dwRefTime) > 60000) m_pEffectSpr[i]->_iCloseSprite();
			}
		}

	// 	for (i = 0; i < MAXSOUNDEFFECTS; i++)
	// 	{	if (m_pCSound[i] != NULL)
	// 		{	if (((G_dwGlobalTime - m_pCSound[i]->m_dwTime) > 30000) && (m_pCSound[i]->m_bIsLooping == FALSE)) m_pCSound[i]->_ReleaseSoundBuffer();
	// 		}
	// 		if (m_pMSound[i] != NULL)
	// 		{	if (((G_dwGlobalTime - m_pMSound[i]->m_dwTime) > 30000) && (m_pMSound[i]->m_bIsLooping == FALSE)) m_pMSound[i]->_ReleaseSoundBuffer();
	// 		}
	// 		if (m_pESound[i] != NULL)
	// 		{	if (((G_dwGlobalTime - m_pESound[i]->m_dwTime) > 30000) && (m_pESound[i]->m_bIsLooping == FALSE)) m_pESound[i]->_ReleaseSoundBuffer();
	// 	}	}//DIRECTX
}

void helbreath::PutChatScrollList(char * txt, char cType)
{
	CMsg * msg = new CMsg(1, txt, cType);

	m_chatMsgs[cType].push_back(msg);

	if (m_chatToggle[cType])
		m_chatDisplay->push_back(msg);

	if (m_chatDisplay->size() >= MAXCHATSCROLLMSGS + MAXCHATSCROLLMSGS / 20)
	{
		m_chatDisplay->erase(m_chatDisplay->begin(), m_chatDisplay->begin() + MAXCHATSCROLLMSGS / 20);
	}

	if (m_chatMsgs[cType].size() >= MAXCHATSCROLLMSGS + MAXCHATSCROLLMSGS / 20)
	{
		m_chatMsgs[cType].erase(m_chatMsgs[cType].begin(), m_chatMsgs[cType].begin() + MAXCHATSCROLLMSGS / 20);
	}

	if (m_tabbedNotification && !m_bIsProgramActive)
	{
#if defined(WIN32)
		if (strstr(txt, player_name.c_str()))
			FlashWindow(*(HWND *)m_hWnd, true);
#endif
	}
}

void helbreath::ChatMsgHandler(char * pData)
{
	int i, iObjectID, iLoc;
	short * sp, sX, sY;
	char * cp, cMsgType, cName[21], cTemp[100], cMsg[100], cTxt1[100], cTxt2[100];
	uint64_t dwTime;
	uint16_t * wp;
	bool bFlag;

	dwTime = m_dwCurTime;

	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	ZeroMemory(cMsg, sizeof(cMsg));

	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	iObjectID = (int)*wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, (char *)cp, 10);
	cp += 10;

	cMsgType = *cp;
	cp++;

	ZeroMemory(cTemp, sizeof(cTemp));
	strcpy(cTemp, cp);

	if ((m_MuteList.find(std::string(cName)) != m_MuteList.end()) ||
		(!m_bWhisper && cMsgType == CHAT_WHISPER) ||
		(!m_bShout && (cMsgType == CHAT_SHOUT || cMsgType == CHAT_NATIONSHOUT)) ||
		((cMsgType == 0 || cMsgType == 2 || cMsgType == 3) && !m_Misc.bCheckIMEString(cTemp)))
	{
		return;
	}

	//if (cMsgType == 2) { // GM Helper Chat - determine if the player speaking in global is a GM Helper
	//	if(strcmp(cName, "GM1lole") == 0 )
	//	{
	//		cMsgType = 36;
	//	}
	//}

	//if (cMsgType == 2) { // ViP Chat - determine if the player speaking in global is a VIP Player
	//	if(strcmp(cName, "VipPlayer") == 0 )
	//	{
	//		cMsgType = 37;
	//	}
	//}

	//if (cMsgType == 2) { // Alpha Tester Chat - determine if the player speaking in global is a Alpha Tester
	//	if(strcmp(cName, "Alpha") == 0 || strcmp(cName, "Alpha1") == 0 || strcmp(cName, "Alpha2") == 0 )
	//	{
	//		cMsgType = 38;
	//	}
	//}

	char timeStamp[50];
	TimeStamp(timeStamp);

	ZeroMemory(cMsg, sizeof(cMsg));
	if (cMsgType == CHAT_WHISPER && (player_name == cName))
	{
		if (m_showTimeStamp)
			fmt::format_to(cMsg, "[%s](%s) %s: %s", timeStamp, m_cWhisperName, cName, cTemp);
		else
			fmt::format_to(cMsg, "(%s) %s: %s", m_cWhisperName, cName, cTemp);
	}
	else
	{
		if (m_showTimeStamp)
			fmt::format_to(cMsg, "[%s] %s: %s", timeStamp, cName, cTemp);
		else
			fmt::format_to(cMsg, "%s: %s", cName, cTemp);
	}

	//DIRECTX m_DDraw._GetBackBufferDC();
	bFlag = false;
	short sCheckByte = 0;
	while (bFlag == false)
	{
		//DIRECTX iLoc = m_Misc.iGetTextLengthLoc(m_DDraw.m_hDC, cMsg, 305);
		iLoc = 0;
		for (int i = 0; i < iLoc; i++)
			if (cMsg[i] < 0) sCheckByte++;
		if (iLoc == 0)
		{
			PutChatScrollList(cMsg, cMsgType);
			bFlag = true;
		}
		else
		{
			if ((sCheckByte % 2) == 0)
			{
				ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc);
				PutChatScrollList(cTemp, cMsgType);
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc);
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
			else
			{
				ZeroMemory(cTemp, sizeof(cTemp));
				memcpy(cTemp, cMsg, iLoc + 1);
				PutChatScrollList(cTemp, cMsgType);
				ZeroMemory(cTemp, sizeof(cTemp));
				strcpy(cTemp, cMsg + iLoc + 1);
				ZeroMemory(cMsg, sizeof(cMsg));
				strcpy(cMsg, " ");
				strcat(cMsg, cTemp);
			}
		}
	}

	//DIRECTX m_DDraw._ReleaseBackBufferDC();

	_RemoveChatMsgListByObjectID(iObjectID);

	for (i = 1; i < MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] == 0)
		{
			m_pChatMsgList[i] = new class CMsg(1, (char *)(cp), dwTime);
			m_pChatMsgList[i]->m_iObjectID = iObjectID;

			if (m_pMapData->bSetChatMsgOwner(iObjectID, sX, sY, i) == false)
			{
				delete m_pChatMsgList[i];
				m_pChatMsgList[i] = 0;
			}

			char cHeadMsg[200];

			if (cMsgType != 0 && (!m_bIsDialogEnabled[10] || !m_chatToggle[cMsgType]))
			{
				ZeroMemory(cHeadMsg, sizeof(cHeadMsg));
				if (cMsgType == CHAT_WHISPER && (player_name == cName))
				{
					if (m_showTimeStamp)
						fmt::format_to(cHeadMsg, "[%s](%s) %s: %s", timeStamp, m_cWhisperName, cName, cp);
					else
						fmt::format_to(cHeadMsg, "(%s) %s: %s", m_cWhisperName, cName, cp);
				}
				else
				{
					if (m_showTimeStamp)
						fmt::format_to(cHeadMsg, "[%s] %s: %s", timeStamp, cName, cp);
					else
						fmt::format_to(cHeadMsg, "%s: %s", cName, cp);
				}
				AddEventList(cHeadMsg, cMsgType);
			}
			return;
		}
}

void helbreath::ReleaseTimeoverChatMsg()
{
	int i;
	uint64_t dwTime;

	dwTime = G_dwGlobalTime;
	for (i = 1; i < MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
		{

			if ((m_pChatMsgList[i]->m_cType >= 1) && (m_pChatMsgList[i]->m_cType <= 20))
			{
				if ((dwTime - m_pChatMsgList[i]->m_dwTime) > CHATTIMEOUT_A)
				{
					delete m_pChatMsgList[i];
					m_pChatMsgList[i] = 0;
				}
			}
			else
				if ((m_pChatMsgList[i]->m_cType >= 21) && (m_pChatMsgList[i]->m_cType <= 40))
				{
					if ((dwTime - m_pChatMsgList[i]->m_dwTime) > CHATTIMEOUT_B)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
				}
				else
					if ((m_pChatMsgList[i]->m_cType >= 41) && (m_pChatMsgList[i]->m_cType <= 60))
					{
						if ((dwTime - m_pChatMsgList[i]->m_dwTime) > CHATTIMEOUT_C)
						{
							delete m_pChatMsgList[i];
							m_pChatMsgList[i] = 0;
						}
					}
					else if ((dwTime - m_pChatMsgList[i]->m_dwTime) > CHATTIMEOUT_A)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
		}
}

void helbreath::DrawBackground(short sDivX, short sModX, short sDivY, short sModY)
{
    int indexX, indexY, ix, iy, iyMax;
    short sSpr, sSprFrame;

	// dynamic resolution
    iyMax = m_bIsObserverMode ? GetHeight() + 48 : GetHeight() - 3;
    if ((m_bIsRedrawPDBGS == true) || (m_iPDBGSdivX != sDivX) || (m_iPDBGSdivY != sDivY))
    {
        // Pre-Draw Background Surface
        m_bIsRedrawPDBGS = false;
        m_iPDBGSdivX = sDivX;
        m_iPDBGSdivY = sDivY;
        indexY = sDivY + m_pMapData->m_sPivotY;
        setRenderTarget(DS_BG, true, Color(0, 0, 0, 0));
        for (iy = -sModY; iy < GetHeight() + 100; iy += 32)
        {
            indexX = sDivX + m_pMapData->m_sPivotX;
            for (ix = -sModX; ix < GetWidth() + 100; ix += 32)
            {
                if (indexX >= 0 && indexY >= 0)
                {
                    sSpr = m_pMapData->m_tile[indexX][indexY].m_sTileSprite;
                    sSprFrame = m_pMapData->m_tile[indexX][indexY].m_sTileSpriteFrame;
                    if (m_pTileSpr[sSpr])
                        //m_pTileSpr[sSpr]->PutSpriteFastNoColorKeyDst((LPDIRECTDRAWSURFACE7)0, ix - 16 +sModX, iy - 16 +sModY, sSprFrame, m_dwCurTime);
                    {
// 						if ((indexY % 2) + (indexX % 2) == 1)
// 							m_pTileSpr[sSpr]->PutSpriteRGB(ix - 16 + sModX, iy - 16 + sModY, sSprFrame, (uint32_t)irr::video::SColor(255, 200, 0, 0).color, m_dwCurTime);//color ground
// 						else
                        m_pTileSpr[sSpr]->DrawSpriteNCK(ix - 16 + sModX, iy - 16 + sModY, sSprFrame, m_dwCurTime);
                    }
                }
                indexX++;
            }
            indexY++;
        }

        if (m_showGrid)
        {
            indexY = sDivY + m_pMapData->m_sPivotY;
            for (iy = -sModY; iy < GetHeight() + 32; iy += 32)
            {
                indexX = sDivX + m_pMapData->m_sPivotX;
                for (ix = -sModX; ix < GetWidth() + 32; ix += 32)
                {
                    {
                        sf::Vertex line[] = {
                            sf::Vertex(sf::Vector2f((float)ix - 16, (float)iy - 16), Color(127, 127, 0, 127)),
                            sf::Vertex(sf::Vector2f((float)ix - 16, (float)iy + 16), Color(127, 127, 0, 127)) };
                        bg.draw(line, 2, sf::Lines);
                    }
                    {
                        sf::Vertex line[] = {
                            sf::Vertex(sf::Vector2f((float)ix - 16, (float)iy - 16), Color(127, 127, 0, 127)),
                            sf::Vertex(sf::Vector2f((float)ix + 16, (float)iy - 16), Color(127, 127, 0, 127)) };
                        bg.draw(line, 2, sf::Lines);
                    }

                    char text[20];
                    fmt::format_to(text, "(%d,%d)", (m_sViewPointX + ix) / 32, (m_sViewPointY + iy) / 32);

                    _text.setFont(_font.at("test"));
                    _text.setString(text);
                    _text.setFillColor(Color(255, 255, 255, 128));
                    _text.setPosition((float)ix - 16, (float)iy);
                    _text.setCharacterSize(8);
                    bg.draw(_text);
                    indexX++;
                }
                indexY++;
            }
        }
        setRenderTarget(DS_VISIBLE);
    }
    //RECT rcRect;
    //SetRect(&rcRect, sModX, sModY, GetWidth()+sModX, GetHeight()+sModY); // 800x600 Resolution xRisenx

    if (m_bIsCrusadeMode)
    {
// 		if(m_iConstructLocX != -1) DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, m_iConstructLocX*32 - m_sViewPointX, m_iConstructLocY*32 - m_sViewPointY, 41);
// 		if( m_iTeleportLocX != -1) DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, m_iTeleportLocX*32 - m_sViewPointX, m_iTeleportLocY*32 - m_sViewPointY, 42);
    }
}


bool helbreath::bEffectFrameCounter()
{
	int i, x;
	uint64_t dwTime;
	bool bRet = false;
	short sAbsX, sAbsY, sDist;
	char  cDir;
	long lPan;
	dwTime = m_dwCurTime;
	dwTime += m_pMapData->m_dwFrameAdjustTime;
	for (i = 0; i < MAXEFFECTS; i++)
		if (m_pEffectList[i] != 0)
		{
			if ((dwTime - m_pEffectList[i]->m_dwTime) > m_pEffectList[i]->m_dwFrameTime)
			{
				m_pEffectList[i]->m_dwTime = dwTime;
				m_pEffectList[i]->m_cFrame++;
				bRet = true;
				m_pEffectList[i]->m_mX2 = m_pEffectList[i]->m_mX;
				m_pEffectList[i]->m_mY2 = m_pEffectList[i]->m_mY;
				switch (m_pEffectList[i]->m_sType)
				{
					case 1: // coup normal
						if (m_pEffectList[i]->m_cFrame == 1)
						{
							for (int j = 1; j <= m_pEffectList[i]->m_iV1; j++) bAddNewEffect(11, m_pEffectList[i]->m_mX + 15 - (rand() % 30), m_pEffectList[i]->m_mY + 15 - (rand() % 30), 0, 0, -1 * (rand() % 2));
						}
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 2:	// (Arrow missing target ?)
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32 - 40,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 70);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
						{	//bAddNewEffect(14, m_pEffectList[i]->m_mX +(rand() % 5) - 2, m_pEffectList[i]->m_mY +(rand() % 5) - 2, NULL, NULL, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 4: // Gold Drop ,33,69,70
					case 33: //
					case 69:
					case 70:
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 5:
					case 30:
					case 31: // Fire Explosion
					case 252:
						if (m_pEffectList[i]->m_cFrame == 1)
						{
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						}
						if (m_pEffectList[i]->m_cFrame == 7)
						{
							bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
							bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
							bAddNewEffect(15, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, 0);
						}
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 6: // Lightning Bolt Burst
						if (m_pEffectList[i]->m_cFrame == 1)
						{
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						}
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 7: // Magic Missile Burst
						if (m_pEffectList[i]->m_cFrame == 1)
						{
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
						}
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 9:  // Burst Type 2
					case 11: // Burst Type 3
						m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
						m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
						m_pEffectList[i]->m_rY++;
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 10: // Lightning Arrow Burst
						if (m_pEffectList[i]->m_cFrame == 1)
						{
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
						}
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 12: // Burst Type 4
						m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
						m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 13: // Bulles druncncity
						if (m_pEffectList[i]->m_cFrame < 15)
						{
							if ((rand() % 2) == 0)
								m_pEffectList[i]->m_mX++;
							else m_pEffectList[i]->m_mX--;
							m_pEffectList[i]->m_mY--;
						}
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 16: //
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 40);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
						{
							bAddNewEffect(18, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0, 0, 0); // testcode 0111 18
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(9, m_pEffectList[i]->m_mX + 20 - (rand() % 40), m_pEffectList[i]->m_mY + 20 - (rand() % 40), 0, 0, -1 * (rand() % 2));
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 17: // Ice-Storm
						cDir = m_Misc.cGetNextMoveDir(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, m_pEffectList[i]->m_mX3, m_pEffectList[i]->m_mY3);
						switch (cDir)
						{
							case 1:
								m_pEffectList[i]->m_rY -= 2;
								break;
							case 2:
								m_pEffectList[i]->m_rY -= 2;
								m_pEffectList[i]->m_rX += 2;
								break;
							case 3:
								m_pEffectList[i]->m_rX += 2;
								break;
							case 4:
								m_pEffectList[i]->m_rX += 2;
								m_pEffectList[i]->m_rY += 2;
								break;
							case 5:
								m_pEffectList[i]->m_rY += 2;
								break;
							case 6:
								m_pEffectList[i]->m_rX -= 2;
								m_pEffectList[i]->m_rY += 2;
								break;
							case 7:
								m_pEffectList[i]->m_rX -= 2;
								break;
							case 8:
								m_pEffectList[i]->m_rX -= 2;
								m_pEffectList[i]->m_rY -= 2;
								break;
						}
						if (m_pEffectList[i]->m_rX < -10) m_pEffectList[i]->m_rX = -10;
						if (m_pEffectList[i]->m_rX > 10) m_pEffectList[i]->m_rX = 10;
						if (m_pEffectList[i]->m_rY < -10) m_pEffectList[i]->m_rY = -10;
						if (m_pEffectList[i]->m_rY > 10) m_pEffectList[i]->m_rY = 10;
						m_pEffectList[i]->m_mX += m_pEffectList[i]->m_rX;
						m_pEffectList[i]->m_mY += m_pEffectList[i]->m_rY;
						m_pEffectList[i]->m_mY3--;
						if (m_pEffectList[i]->m_cFrame > 10)
						{
							m_pEffectList[i]->m_cFrame = 0;
							if (abs(m_pEffectList[i]->m_sY - m_pEffectList[i]->m_mY3) > 100)
							{
								delete m_pEffectList[i];
								m_pEffectList[i] = 0;
							}
						}
						break;

					case 20: // Critical strike with a weapon
					case 21:
					case 22:
					case 23:
					case 24:
					case 25:
					case 26:
					case 27: // Critical strike with a weapon
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32 - 40,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + 10 - (rand() % 20), m_pEffectList[i]->m_mY + 10 - (rand() % 20), 0, 0, 0);//-1*(rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2) &&
							(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 34: //
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(33, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, -1 * (rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
							(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
						{
							bAddNewEffect(33, m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0, 0, 0); //7
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;


					case 40:
					case 56:
						if (m_pEffectList[i]->m_cFrame == 9)
						{
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
							bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 100) - 50), m_pEffectList[i]->m_mY + ((rand() % 70) - 35), 0, 0, 0, 0);
						}
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 41: //Large Type 1, 2, 3, 4
					case 42:
					case 43:
					case 44:
					case 45: // Small Type 1, 2
					case 46:
						if (m_pEffectList[i]->m_cFrame >= 7)
						{
							m_pEffectList[i]->m_mX--;
							m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
							m_pEffectList[i]->m_iV1++;
						}

						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							if ((m_pEffectList[i]->m_sType != 45) && (m_pEffectList[i]->m_sType != 46))
							{
								bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
								bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
								bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
								bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
								if (m_cDetailLevel != 0)
								{
									bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
									bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
								}
							}
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 47: // Blizzard
					case 48:
					case 49:
						if (m_pEffectList[i]->m_cFrame >= 7)
						{
							m_pEffectList[i]->m_mX--;
							m_pEffectList[i]->m_mY += m_pEffectList[i]->m_iV1;
							m_pEffectList[i]->m_iV1 += 4;
						}
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							if (m_pEffectList[i]->m_sType == 49)
								bAddNewEffect(72, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
							else bAddNewEffect(50, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							bAddNewEffect(14, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							if (m_cDetailLevel != 0)
							{
								bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
								bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
							}
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 60: //
					case 181: // Meteor-Strike
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
							bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), 0, 0, -1 * (rand() % 2));
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else if (m_pEffectList[i]->m_cFrame >= 0)
						{
							m_pEffectList[i]->m_mX -= 30;
							m_pEffectList[i]->m_mY += 46;
							bAddNewEffect(62, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, 0, 0, 0, 0);
						}
						break;

					case 62:
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else if (m_pEffectList[i]->m_cFrame >= 0)
						{
							m_pEffectList[i]->m_mX += (rand() % 3) - 1;
							m_pEffectList[i]->m_mY += (rand() % 3) - 1;
						}
						break;

					case 65: // Building fire after MS (crusade) 65 & 67
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else if (m_pEffectList[i]->m_cFrame >= 0)
						{
							m_pEffectList[i]->m_mX += (rand() % 3) - 1;
							m_pEffectList[i]->m_mY -= 4 + (rand() % 2);
						}
						break;

					case 66:
					case 203:
					case 204:
					case 205:
					case 206:
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 68:
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else if (m_pEffectList[i]->m_cFrame == 11)
						{
							SetCameraShakingEffect(m_pEffectList[i]->m_iV1, 2);
						}
						break;

					case 71:
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(48, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0);
						if (m_cDetailLevel != 0) bAddNewEffect(51, m_pEffectList[i]->m_mX + ((rand() % 20) - 10), m_pEffectList[i]->m_mY + ((rand() % 20) - 10), 0, 0, 0, 0);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX) <= 2) &&
							(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY)) <= 2))
						{
							bAddNewEffect(49, m_pEffectList[i]->m_mX/* + (rand() % 30) - 15*/, m_pEffectList[i]->m_mY/* + (rand() % 30) - 15*/, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 81: // Snoopy: Ajout StromBlade
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 10);
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 100: // Magic Missile
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));

						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2) &&
							(abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32/* - 40*/)) <= 2))
						{
							bAddNewEffect(7, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 110: // Enegy-Bolt
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{
							bAddNewEffect(6, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0); // 6 testcode 0111
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 120: // Fire Ball
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{
							bAddNewEffect(5, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 130: // Fire Strike
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{
							bAddNewEffect(5, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7);
							bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5);
							bAddNewEffect(5, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 137: // Lightning Arrow
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{
							bAddNewEffect(10, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 143: // Lightning
					case 151: // Lightning-Bolt
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							bAddNewEffect(10, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							m_pEffectList[i]->m_rX = 5 - (rand() % 10);
							m_pEffectList[i]->m_rY = 5 - (rand() % 10);
						}
						break;

					case 145: // Chill-Wind
						bAddNewEffect(40, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -10);
						bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -6);
						bAddNewEffect(40, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
						break;

					case 147:  // Triple-Energy-Bolt
						bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX - 1, m_pEffectList[i]->m_dY - 1, 0);
						bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + 1, m_pEffectList[i]->m_dY - 1, 0);
						bAddNewEffect(110, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + 1, m_pEffectList[i]->m_dY + 1, 0);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
						//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
						sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
						sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
						if (sAbsX > sAbsY) sDist = sAbsX;
						else sDist = sAbsY;
						lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX) * 1000;
						PlaySound('E', 1, sDist, lPan);
						bAddNewEffect(7, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
						break;

					case 156: // Mass-Lightning-Arrow
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(137, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX, m_pEffectList[i]->m_dY, 0);
							//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX) * 1000;
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 157: // Ice-Strike
						bAddNewEffect(41, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						for (x = 0; x < 14; x++)
						{
							bAddNewEffect(41 + (rand() % 3), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1);
						}
						for (x = 0; x < 6; x++)
						{
							bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1 - 10);
						}
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
						break;

					case 160: // Energy-Strike
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(16, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX * 32 + 50 - (rand() % 100), m_pEffectList[i]->m_dY * 32 + 50 - (rand() % 100), 0);
							//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 161: // Mass-Fire-Strike
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY,
							m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32/* - 40*/,
							&m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY,
							&m_pEffectList[i]->m_iErr, 50);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{
							bAddNewEffect(30, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
							bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7);
							bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5);
							bAddNewEffect(31, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 163: // Mass-Chill-Wind Chill-Wind
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -10);
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -6);
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3);
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
						bAddNewEffect(56, m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50, m_pEffectList[i]->m_dY * 32 + (rand() % 70) - 35, 0, 0, -1 * (rand() % 10));
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
						break;

					case 164: // worm-bite
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							bAddNewEffect(68, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0); // testcode 0111 18
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 170: // Bloody-Shock-Wave
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else if ((m_pEffectList[i]->m_cFrame % 2) == 0)
						{
							bAddNewEffect(34, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX * 32 + 30 - (rand() % 60), m_pEffectList[i]->m_dY * 32 + 30 - (rand() % 60), 0);
							//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 172: // Mass-Ice-Strike
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0);
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * (rand() % 3));
						for (x = 0; x < 16; x++)
						{
							bAddNewEffect(44, m_pEffectList[i]->m_dX * 32 + (rand() % 110) - 55 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 100) - 50, 0, 0, -1 * x - 1);
						}
						for (x = 0; x < 8; x++)
						{
							bAddNewEffect(45 + (rand() % 2), m_pEffectList[i]->m_dX * 32 + (rand() % 100) - 50 + 10, m_pEffectList[i]->m_dY * 32 + (rand() % 90) - 45, 0, 0, -1 * x - 1 - 10);
						}
						delete m_pEffectList[i];
						m_pEffectList[i] = 0;
						break;

					case 174: // Lightning-Strike
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX + (rand() % 3) - 1, m_pEffectList[i]->m_dY + (rand() % 3) - 1, 0);
							//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 182: // Mass-Magic-Missile
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 50);
						bAddNewEffect(8, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, -1 * (rand() % 4));
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - m_pEffectList[i]->m_dY * 32) <= 2))
						{	// JLE 0043132A
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(35, m_pEffectList[i]->m_dX * 32 + 22, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7, 1);
							bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 - 22, m_pEffectList[i]->m_dY * 32 - 7, 0, 0, -7, 1);
							bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 + 30, m_pEffectList[i]->m_dY * 32 - 22, 0, 0, -5, 1);
							bAddNewEffect(36, m_pEffectList[i]->m_dX * 32 + 12, m_pEffectList[i]->m_dY * 32 + 22, 0, 0, -3, 1);
						}
						break;

					case 191: // Blizzard
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else /*if (m_pEffectList[i]->m_cFrame == 1)*/
						{
							bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX * 32 + (rand() % 120) - 60, m_pEffectList[i]->m_dY * 32 + (rand() % 120) - 60, 0);
							//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 196: // Earth-Shock-Wave
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);
						bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0, 1);
						bAddNewEffect(80, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, 0, 0);
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{	//sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							//sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // 800x600 Resolution xRisenx Center Char xRisenx
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // 800x600 Resolution xRisenx Center Char xRisenx
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 193: //Hurricane-Blast xRisenx
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);
						// 30 - looks ok, good fps, bit amaturish
						// 31 - looks good, good fps
						// 67 - looks pants, best fps tho
						// 66 - very FPS intensive
						// 5 - looks ok, bit gappy
						// 18 - ENERGY SHOCK WAVE-looking sprite :P
						bAddNewEffect(10, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, 0, 0);
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 198: // xRisenx - Mass-Blizzard
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else /*if (m_pEffectList[i]->m_cFrame == 1)*/
						{
							bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
								m_pEffectList[i]->m_dX * 32 + (rand() % 120) - 60, m_pEffectList[i]->m_dY * 32 + (rand() % 120) - 60, 0);
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX;
							else sDist = sAbsY;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 197: // xRisenx - Fiery-Shock-Wave
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);
						// 30 - looks ok, good fps, bit amaturish
						// 31 - looks good, good fps
						// 67 - looks pants, best fps tho
						// 66 - very FPS intensive
						// 5 - looks ok, bit gappy
						// 18 - ENERGY SHOCK WAVE-looking sprite :P
						bAddNewEffect(66, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, 0, 0, 0, 0);
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 192: // xRisenx - Call-Of-The-Gods
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);
						if (m_pEffectList[i]->m_cFrame % 2 == 0)
							bAddNewEffect(68, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0, 1);

						//bAddNewEffect(44, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, 0, 0);*/
						//bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
										  //m_pEffectList[i]->m_dX*32 +(rand()%120)-60, m_pEffectList[i]->m_dY*32 +(rand()%120)-60, 0);
						bAddNewEffect(71, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX * 32 + (rand() % 120) - 60, m_pEffectList[i]->m_dY * 32 + (rand() % 120) - 60, 0);
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}

						break;

					case 187: // xRisenx - Strike-Of-The-Ghosts
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);

						bAddNewEffect(245, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, 0, 0, 0, 1);

						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}

						break;

					case 188: // Lightning Storm xRisenx 
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 40);

						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 5) - 1, m_pEffectList[i]->m_dY + (rand() % 5) - 1, 0);
						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 5) - 1, m_pEffectList[i]->m_dY + (rand() % 5) - 1, 0);
						sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX); // Resolution ? 10 to 12? xRisenx Changed everyone in this function
						sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY); // Resolution ? 7 to 9? xRisenx Changed everyone in this function
						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 5) - 1, m_pEffectList[i]->m_dY + (rand() % 5) - 1, 0);
						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 5) - 1, m_pEffectList[i]->m_dY + (rand() % 5) - 1, 0);
						sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
						sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);

						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 12) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 9) - m_pEffectList[i]->m_dY);
							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;
							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX); // Is this linked to Resolution? Change +10 to +12?
							PlaySound('E', 1, sDist, lPan);
						}
						break;

					case 104: // Thunder Storm xRisenx
						m_Misc.GetPoint(m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX, &m_pEffectList[i]->m_mY, &m_pEffectList[i]->m_iErr, 40);

						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 7) - 6, m_pEffectList[i]->m_dY + (rand() % 7) - 6, 0);

						bAddNewEffect(151, m_pEffectList[i]->m_sX, m_pEffectList[i]->m_sY,
							m_pEffectList[i]->m_dX + (rand() % 10) - 6, m_pEffectList[i]->m_dY + (rand() % 10) - 6, 0);

						//bAddNewEffect(6, m_pEffectList[i]->m_mX + (rand() % 20) - 10, m_pEffectList[i]->m_mY + (rand() % 20) - 10, NULL, NULL, 0, 0);

						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							sAbsY = abs(((m_sViewPointY / 32) + 7) - m_pEffectList[i]->m_dY);

							if (sAbsX > sAbsY) sDist = sAbsX - 10;
							else sDist = sAbsY - 10;

							lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
							PlaySound('E', 1, sDist, lPan);
						}
						break;

						//case 105: // Inferno xRisenx
						//	m_Misc.GetPoint(m_pEffectList[i]->m_mX
						//		, m_pEffectList[i]->m_mY
						//		, m_pEffectList[i]->m_dX*32
						//		, m_pEffectList[i]->m_dY*32
						//		, &m_pEffectList[i]->m_mX
						//		, &m_pEffectList[i]->m_mY
						//		, &m_pEffectList[i]->m_iErr
						//		, 40);

						//	
						//	bAddNewEffect(66, m_pEffectList[i]->m_mX + (rand() % 30) - 15, m_pEffectList[i]->m_mY + (rand() % 30) - 15, NULL, NULL, 0, 1);
						//	
						//	if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						//	{	
						//		delete m_pEffectList[i];
						//		m_pEffectList[i] = NULL;
						//	}
						//	else
						//	{	
						//		sAbsX = abs(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
						//		sAbsY = abs(((m_sViewPointY / 32) + 7)  - m_pEffectList[i]->m_dY);
						//		if (sAbsX > sAbsY) sDist = sAbsX -10;
						//		else sDist = sAbsY -10;
						//		lPan = -(((m_sViewPointX / 32) + 10) - m_pEffectList[i]->m_dX);
						//		PlaySound('E', 1, sDist, lPan);
						//	}
						//	break;
						//	// From what i understand this is where you make the animation for the spell when it hits the ground.
						//case 106: // Hell-Fire xRisenx
						//	if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						//	{	bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		//bAddNewEffect(62, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);

						//		bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY+65, NULL, NULL, 0, 0);
						//		bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY+65, NULL, NULL, 0, 0);
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 +65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 +65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 +65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 +65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 +65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));

						//		bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY-65, NULL, NULL, 0, 0);
						//		bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY-65, NULL, NULL, 0, 0);
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 -65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 -65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 -65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 -65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 -65 - (rand() % 10), NULL, NULL, -1*(rand() % 2));

						//		bAddNewEffect(62, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
						//	/*bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//	for (x = 0; x < 16; x++)
						//	{
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*x-1);
						//	}
						//	for (x = 0; x < 8; x++)
						//	{
						//	bAddNewEffect(62 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);		}
						//	for (x = 0; x < 8; x++)
						//	{
						//	bAddNewEffect(62 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 60 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);
						//	}*/
						//		delete m_pEffectList[i];
						//		m_pEffectList[i] = NULL;
						//	}else if (m_pEffectList[i]->m_cFrame >= 0)
						//	{	m_pEffectList[i]->m_mX -= 30;
						//		m_pEffectList[i]->m_mY += 46;
						//		bAddNewEffect(62, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//	}		
						//	/*bAddNewEffect(62, m_pEffectList[i]->m_dX*32, m_pEffectList[i]->m_dY*32, NULL, NULL, 0);
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*(rand() % 3));
						//	bAddNewEffect(61, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(63, m_pEffectList[i]->m_mX, m_pEffectList[i]->m_mY, NULL, NULL, 0, 0);
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//		bAddNewEffect(12, m_pEffectList[i]->m_mX + 5 - (rand() % 10), m_pEffectList[i]->m_mY + 5 - (rand() % 10), NULL, NULL, -1*(rand() % 2));
						//	for (x = 0; x < 16; x++)
						//	{
						//	bAddNewEffect(62, m_pEffectList[i]->m_dX*32 +(rand() % 110) - 55 +10, m_pEffectList[i]->m_dY*32 + (rand() % 100) - 50, NULL, NULL, -1*x-1);
						//	}
						//	for (x = 0; x < 8; x++)
						//	{
						//	bAddNewEffect(62 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 50 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);		}
						//	for (x = 0; x < 8; x++)
						//	{
						//	bAddNewEffect(62 + (rand() % 2), m_pEffectList[i]->m_dX*32 +(rand() % 100) - 60 +10, m_pEffectList[i]->m_dY*32 + (rand() % 90) - 45, NULL, NULL, -1*x-1 -10);
						//	}

						//	delete m_pEffectList[i];
						//	m_pEffectList[i] = NULL;*/
						//				
						//	break;

					case 200:
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(203, m_pEffectList[i]->m_sX + 40, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
							bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
							bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
							bAddNewEffect(206, m_pEffectList[i]->m_sX - 7, m_pEffectList[i]->m_sY + 27, 0, 0, 0, 0);
							//bAddNewEffect(201, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
							//bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
							bAddNewEffect(201, (rand() % 160) + 400, (rand() % 120) + 300, 0, 0, 0, 1);
							bAddNewEffect(202, (rand() % 160) + 400, (rand() % 120) + 300, 0, 0, 0, 1);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 201:
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(203, m_pEffectList[i]->m_sX + 110, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
							bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
							bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
							//bAddNewEffect(202, (rand() % 160) + 320, (rand() % 120) + 240, NULL, NULL, 0, 1);
							bAddNewEffect(202, (rand() % 160) + 400, (rand() % 120) + 300, 0, 0, 0, 1);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 202:
						if (m_pEffectList[i]->m_cFrame >= m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(203, m_pEffectList[i]->m_sX + 65, m_pEffectList[i]->m_sY + 120, 0, 0, 0, 0);
							bAddNewEffect(204, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 70, 0, 0, 0, 0);
							bAddNewEffect(205, m_pEffectList[i]->m_sX - 10, m_pEffectList[i]->m_sY + 75, 0, 0, 0, 0);
							bAddNewEffect(206, m_pEffectList[i]->m_sX - 7, m_pEffectList[i]->m_sY + 27, 0, 0, 0, 0);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 250: // Gate round
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32 - 40
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 10);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 251: // Salmon burst (effect11s)
						m_Misc.GetPoint(m_pEffectList[i]->m_mX
							, m_pEffectList[i]->m_mY
							, m_pEffectList[i]->m_dX * 32
							, m_pEffectList[i]->m_dY * 32
							, &m_pEffectList[i]->m_mX
							, &m_pEffectList[i]->m_mY
							, &m_pEffectList[i]->m_iErr
							, 50);
						if ((abs(m_pEffectList[i]->m_mX - m_pEffectList[i]->m_dX * 32) <= 2)
							&& (abs(m_pEffectList[i]->m_mY - (m_pEffectList[i]->m_dY * 32 - 40)) <= 2))
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						else
						{
							bAddNewEffect(252, m_pEffectList[i]->m_dX * 32, m_pEffectList[i]->m_dY * 32, 0, 0, 0, 1);
							bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 - 30, m_pEffectList[i]->m_dY * 32 - 15, 0, 0, -7, 1);
							bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 - 35, m_pEffectList[i]->m_dY * 32 - 30, 0, 0, -5, 1);
							bAddNewEffect(252, m_pEffectList[i]->m_dX * 32 + 20, m_pEffectList[i]->m_dY * 32 + 30, 0, 0, -3, 1);
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;

					case 8:
					case 14:
					case 15:
					case 18:
					case 32:
					case 35: //
					case 36: //
					case 50:
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 57:
					case 61:
					case 63:
					case 64:
					case 67:
					case 72:
					case 73:
					case 74:
					case 75:
					case 76:
					case 77:
					case 80: //
					case 82: //

					case 101:
					case 102:
					case 111:
					case 112:
					case 113:
					case 121:
					case 122:
					case 123: // Stamina Rec
					case 124:
					case 125:
					case 126:
					case 127:
					case 128: // Gr Stamina Rec
					case 131:
					case 132:
					case 133:
					case 134:
					case 135:
					case 136:
					case 142:
					case 144:
					case 150: // Berserk : Cirlcle 6 magic
					case 152: // Polymorph
					case 153:
					case 162:
					case 165:
					case 166:
					case 171:
					case 176: //
					case 177: //

					case 180:
					case 183: //
					//case 184: // EP's Magic Drain
					case 184: // xRisenx - Magic Shield
					case 185: // xRisenx - Mass Heal
					case 245: // Ghosts 1
					case 190:
						//case 192:
						//case 193:
					case 194:
					case 195:
					case 242: // Mage hero effect
					case 243: // War hero effect
					case 244: // Snoopy: dplac pour nvx sorts: Aura du casteur de Mass MagicMissile
						if (m_pEffectList[i]->m_cFrame > m_pEffectList[i]->m_cMaxFrame)
						{
							delete m_pEffectList[i];
							m_pEffectList[i] = 0;
						}
						break;
				}
			}
		}
	return bRet;
}


void helbreath::GetPlayerTurn()
{
	char cDir;
	short sX, sY, sCnt1, sCnt2;
	int   iError;

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt1 = 0;
	m_cPlayerTurn = 0;
	iError = 0;
	while (1)
	{
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir)
		{
			case 1: sY--;       break;
			case 2: sX++; sY--; break;
			case 3: sX++;       break;
			case 4: sX++; sY++; break;
			case 5: sY++;       break;
			case 6: sX--; sY++; break;
			case 7: sX--;       break;
			case 8: sX--; sY--; break;
		}
		sCnt1++;
		if (sCnt1 > 30) break;
	}

	sX = m_sPlayerX;
	sY = m_sPlayerY;
	sCnt2 = 0;
	m_cPlayerTurn = 1;
	iError = 0;
	while (1)
	{
		cDir = cGetNextMoveDir(sX, sY, m_sCommX, m_sCommY);
		if (cDir == 0) break;
		switch (cDir)
		{
			case 1: sY--;       break;
			case 2: sX++; sY--; break;
			case 3: sX++;       break;
			case 4: sX++; sY++; break;
			case 5: sY++;       break;
			case 6: sX--; sY++; break;
			case 7: sX--;       break;
			case 8: sX--; sY--; break;
		}
		sCnt2++;
		if (sCnt2 > 30) break;
	}

	if (sCnt1 > sCnt2)
		m_cPlayerTurn = 0;
	else m_cPlayerTurn = 1;
}


int helbreath::_iCheckDlgBoxFocus(char cButtonSide)
{
	int i;
	char         cDlgID;
	short        sX, sY;
	short msX = m_stMCursor.sX;
	short msY = m_stMCursor.sY;
	uint32_t		  dwTime = m_dwCurTime;
	cDlgID = MouseOverDialog();

	if (cDlgID == 0) return 0;

	if (cButtonSide == 1)
	{
		EnableDialogBox(cDlgID, 0, 0, 0);

		m_stMCursor.sPrevX = msX;
		m_stMCursor.sPrevY = msY;
		m_stMCursor.sDistX = msX - m_dialogBoxes[cDlgID].m_X;
		m_stMCursor.sDistY = msY - m_dialogBoxes[cDlgID].m_Y;

		switch (cDlgID)
		{
			case 1:
				if (DlgBoxPress_Character() == false)
				{
					m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID = cDlgID;
				}
				break;

			case 2:	// (Sell Item)
				if (DlgBoxPress_Inventory() == false)
				{
					m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID = cDlgID;
				}
				break;

			case 26:
				if (DlgBoxPress_SkillDlg() == false)
				{
					m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID = cDlgID;
				}
				break;

			default:
				if (m_dialogBoxes[cDlgID].IsScrollable())
				{
					if (m_dialogBoxes[cDlgID].IsOnScrollBar())
					{
						m_dialogBoxes[cDlgID].bIsScrollSelected = true;
					}

					if (m_dialogBoxes[cDlgID].bIsScrollSelected)
					{
						return -1;
					}
					else
					{
						m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_DLGBOX;
						m_stMCursor.sSelectedObjectID = cDlgID;
					}
				}
				else
				{
					m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_DLGBOX;
					m_stMCursor.sSelectedObjectID = cDlgID;
				}
		}
	}
	else if (cButtonSide == 2)
	{
		if ((dwTime - m_dwDialogCloseTime) < 300) return 0;

		char mode = m_dialogBoxes[cDlgID].GetMode();


		if (cDlgID == DIALOG_GUIDEMAP && m_altPressed)
		{
			Point p = GetGuideMapPos(m_stMCursor.sX, m_stMCursor.sY);
			AddMapPing(MapPing(p.x, p.y));
			bSendCommand(MSGID_PINGMAP, PINGMAP_PARTY | PINGMAP_GUILD, 0, p.x, p.y);
		}
		else if (cDlgID != 5 && cDlgID != 6 && cDlgID != 8 && cDlgID != 12 &&
			(cDlgID != 23 || mode < 3) &&
			cDlgID != 24 && cDlgID != 27 && cDlgID != 34 && cDlgID != 33 &&
			!(cDlgID == 32 && (mode == 1 || mode == 3)) &&
			!(cDlgID == DIALOG_MAILBOX && mode == 5)
			)
		{
			DisableDialogBox(cDlgID);
		}

		m_dwDialogCloseTime = dwTime;
	}

	return 1;
}

char helbreath::MouseOverDialog()
{
	int i;
	int onDialog = 0;
	for (i = MAXDIALOGBOX - 1; i >= 0; i--)
	{
		if (m_cDialogBoxOrder[i] != 0 &&
			m_dialogBoxes[m_cDialogBoxOrder[i]].OnDialogBox())
		{
			onDialog = m_cDialogBoxOrder[i];
			break;
		}
	}
	return onDialog;
}


void helbreath::InitItemList(char * pData)
{
	char    cTotalItems;
	int     i, iAngelValue;
	short * sp;
	uint32_t * dwp;
	uint16_t * wp;
	char * cp;

	m_weight = 0;

	for (i = 0; i < MAXITEMS; i++)
		m_cItemOrder[i] = -1;

	for (i = 0; i < MAXITEMEQUIPPOS; i++)
		m_sItemEquipmentStatus[i] = -1;

	for (i = 0; i < MAXITEMS; i++)
		m_bIsItemDisabled[i] = false;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	cTotalItems = *cp;
	cp++;

	for (i = 0; i < MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			delete m_pItemList[i];
			m_pItemList[i] = 0;
		}

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	for (i = 0; i < cTotalItems; i++)
	{
		m_pItemList[i] = new class CItem;
		memcpy(m_pItemList[i]->m_cName, cp, 20);
		cp += 20;
		dwp = (uint32_t *)cp;
		m_pItemList[i]->m_dwCount = *dwp;
		m_pItemList[i]->m_sX = 40;
		m_pItemList[i]->m_sY = 30;
		cp += 4;
		m_pItemList[i]->m_cItemType = *cp;
		cp++;
		m_pItemList[i]->m_cEquipPos = *cp;
		cp++;
		if (*cp == 0) m_bIsItemEquipped[i] = false;
		else m_bIsItemEquipped[i] = true;
		cp++;
		if (m_bIsItemEquipped[i] == true)
		{
			m_sItemEquipmentStatus[m_pItemList[i]->m_cEquipPos] = i;
		}
		sp = (short *)cp;
		m_pItemList[i]->m_sLevelLimit = *sp;
		cp += 2;
		m_pItemList[i]->m_cGenderLimit = *cp;
		cp++;
		wp = (uint16_t *)cp;
		m_pItemList[i]->m_wCurLifeSpan = *wp;
		cp += 2;
		wp = (uint16_t *)cp;
		m_pItemList[i]->m_wWeight = *wp;
		cp += 2;
		sp = (short *)cp;
		m_pItemList[i]->m_sSprite = *sp;
		cp += 2;
		sp = (short *)cp;
		m_pItemList[i]->m_sSpriteFrame = *sp;
		cp += 2;
		dwp = (uint32_t *)cp;
		m_pItemList[i]->m_ItemColor = *dwp;
		cp += 4;
		m_pItemList[i]->m_sItemSpecEffectValue2 = (short)*cp;
		cp++;
		dwp = (uint32_t *)cp;
		m_pItemList[i]->m_dwAttribute = *dwp;
		cp += 4;
		for (int j = 0; j < MAXITEMSOCKETS; j++)
		{
			Pop(cp, m_pItemList[i]->m_sockets[j]);
		}
		m_cItemOrder[i] = i;
		// Snoopy: Add Angelic Stats
		if ((m_pItemList[i]->m_cItemType == 1)
			&& (m_bIsItemEquipped[i] == true)
			&& (m_pItemList[i]->m_cEquipPos >= 11))
		{
			if (memcmp(m_pItemList[i]->m_cName, "AngelicPendant(STR)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				//m_angelStat[STAT_STR] = 1 + iAngelValue;
				m_angelStat[STAT_STR] = 12 * iAngelValue; // Angel Stats xRisenx
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPendant(DEX)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				//m_angelStat[STAT_DEX] = 1 + iAngelValue;
				m_angelStat[STAT_DEX] = 12 * iAngelValue; // Angel Stats xRisenx
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPendant(INT)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				//m_angelStat[STAT_INT] = 1 + iAngelValue;
				m_angelStat[STAT_INT] = 12 * iAngelValue; // Angel Stats xRisenx
			}
			else if (memcmp(m_pItemList[i]->m_cName, "AngelicPendant(MAG)", 19) == 0)
			{
				iAngelValue = (m_pItemList[i]->m_dwAttribute & 0xF0000000) >> 28;
				//m_angelStat[STAT_MAG] = 1 + iAngelValue;
				m_angelStat[STAT_MAG] = 12 * iAngelValue; // Angel Stats xRisenx
			}
		}
	}

	cTotalItems = *cp;
	_iCalcTotalWeight();
	cp++;

	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0)
		{
			delete m_pBankList[i];
			m_pBankList[i] = 0;
		}

	for (i = 0; i < cTotalItems; i++)
	{
		m_pBankList[i] = new class CItem;
		memcpy(m_pBankList[i]->m_cName, cp, 20);
		cp += 20;

		dwp = (uint32_t *)cp;
		m_pBankList[i]->m_dwCount = *dwp;
		cp += 4;

		m_pBankList[i]->m_sX = 40;
		m_pBankList[i]->m_sY = 30;

		m_pBankList[i]->m_cItemType = *cp;
		cp++;

		m_pBankList[i]->m_cEquipPos = *cp;
		cp++;

		sp = (short *)cp;
		m_pBankList[i]->m_sLevelLimit = *sp;
		cp += 2;

		m_pBankList[i]->m_cGenderLimit = *cp;
		cp++;

		wp = (uint16_t *)cp;
		m_pBankList[i]->m_wCurLifeSpan = *wp;
		cp += 2;

		wp = (uint16_t *)cp;
		m_pBankList[i]->m_wWeight = *wp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSprite = *sp;
		cp += 2;

		sp = (short *)cp;
		m_pBankList[i]->m_sSpriteFrame = *sp;
		cp += 2;

		dwp = (uint32_t *)cp;
		m_pBankList[i]->m_ItemColor = *dwp;
		cp += 4;

		m_pBankList[i]->m_sItemSpecEffectValue2 = (short)*cp;
		cp++;

		dwp = (uint32_t *)cp;
		m_pBankList[i]->m_dwAttribute = *dwp;
		cp += 4;
		for (int j = 0; j < MAXITEMSOCKETS; j++)
		{
			Pop(cp, m_pBankList[i]->m_sockets[j]);
		}
	}

	// Magic, Skill Mastery
	for (i = 0; i < MAXMAGICTYPE; i++)
	{
		m_cMagicMastery[i] = *cp;
		cp++;
	}

	for (i = 0; i < MAXSKILLTYPE; i++)
	{
		m_cSkillMastery[i] = (unsigned char)*cp;
		if (m_pSkillCfgList[i] != 0)
			m_pSkillCfgList[i]->m_iLevel = (int)*cp;
		cp++;
	}
}

void helbreath::DrawDialogBox_GuideMap()
{
	int  m_iMaxMapIndex = SPRID_INTERFACE_GUIDEMAP + m_cMapIndex + 1;
	int  m_iMinMapIndex = SPRID_INTERFACE_GUIDEMAP;
	int  m_iMinMapSquare = m_cMapIndex;
	int  pointX, pointY;
	//telescope.pak:  frames 1..31 <=> SPRID_INTERFACE_GUIDEMAP +1...+31 <=> m_cMapIndex 0..30
	//telescope1.pak: frames 1..3  <=> SPRID_INTERFACE_GUIDEMAP +36..+38 <=> m_cMapIndex 35..37 et +
	if (m_cMapIndex < 0) return;
	if (m_cMapIndex >= 35)
	{
		m_iMaxMapIndex = SPRID_INTERFACE_GUIDEMAP + m_cMapIndex + 1;
		m_iMinMapIndex = SPRID_INTERFACE_GUIDEMAP + 35;
		m_iMinMapSquare = m_cMapIndex - 35;
	}
	short sX, sY, shX, shY, szX, szY;

	sX = m_dialogBoxes[9].m_X;
	sY = m_dialogBoxes[9].m_Y;
	szX = m_dialogBoxes[9].sSizeX;
	szY = m_dialogBoxes[9].sSizeY;

	if (sX < 20) sX = 0;
	if (sY < 20) sY = 0;
	//if( sX > 640-128-20 ) sX = 640-128;
	if (sX > GetWidth() - 128 - 20) sX = GetWidth() - 128; // 800x600 Resolution xRisenx
	//if( sY > 427-128-20 ) sY = 427-128;
	if (sY > GetHeight() - 13 - 128 - 20) sY = GetHeight() - 13 - 128; // 800x600 xRisenx
	for (shX = -2; shX < 130; shX++)
	{
		//DIRECTX m_DDraw.PutPixel( sX+shX, sY-2  , 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX+shX, sY-1  , 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX+shX, sY+128, 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX+shX, sY+129, 50,50,50);
	}
	for (shY = -2; shY < 130; shY++)
	{
		//DIRECTX m_DDraw.PutPixel( sX-2  , sY+shY, 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX-1  , sY+shY, 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX+128, sY+shY, 50,50,50);
		//DIRECTX m_DDraw.PutPixel( sX+129, sY+shY, 50,50,50);
	}
	if (m_bZoomMap)
	{
		shX = m_sPlayerX - 64;
		shY = m_sPlayerY - 64;
		if (shX < 0) shX = 0;
		if (shY < 0) shY = 0;
		if (shX > m_pMapData->m_sMapSizeX - 128) shX = m_pMapData->m_sMapSizeX - 128;
		if (shY > m_pMapData->m_sMapSizeY - 128) shY = m_pMapData->m_sMapSizeY - 128;
		if (m_bDialogTrans) m_pSprite[m_iMaxMapIndex]->PutShiftTransSprite2(sX, sY, shX, shY, 0, m_dwCurTime);
		else m_pSprite[m_iMaxMapIndex]->PutShiftSpriteFast(sX, sY, shX, shY, 0, m_dwCurTime);

		if (m_iPartyStatus && !m_iIlusionOwnerH)
		{
			for (int i = 0; i < m_stPartyMember.size(); i++)
			{
				if (m_stPartyMember[i]->sX == 0 || m_stPartyMember[i]->sY == 0)
					continue;

				if (m_stPartyMember[i]->sX >= shX && m_stPartyMember[i]->sX <= shX + 128 &&
					m_stPartyMember[i]->sY >= shY && m_stPartyMember[i]->sY <= shY + 128)
				{
					pointX = (sX - shX + m_stPartyMember[i]->sX) - 1;
					pointY = (sY - shY + m_stPartyMember[i]->sY) - 1;

					for (int pX = 0; pX < 3; pX++)
					{
						//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 60,220,60);
// 						if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 						else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 60,220,60);
						//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 60,220,60);
					}
				}
			}
		}

		if (m_mapPings.size() > 0)
		{
			std::vector<MapPing>::iterator remIt = remove_if(m_mapPings.begin(), m_mapPings.end(), MapPing::Expired);
			m_mapPings.erase(remIt, m_mapPings.end());

			foreach(ping, m_mapPings)
			{
				if (ping->pos.x == 0 || ping->pos.y == 0)
					continue;

				if (ping->pos.x < shX)
					pointX = sX;
				else if (ping->pos.x > shX + 128)
					pointX = sX + 128;
				else
					pointX = sX + ping->pos.x - shX;

				if (ping->pos.y < shY)
					pointY = sY;
				else if (ping->pos.y > shY + 128)
					pointY = sY + 128;
				else
					pointY = sY + ping->pos.y - shY;

				pointX--;
				pointY--;

				uint32_t frame = (m_dwCurTime % 700) / 140;
				m_pEffectSpr[168]->PutTransSprite_NoColorKey(pointX, pointY, frame, m_dwCurTime);
				for (int pX = 0; pX < 3; pX++)
				{
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 60,220,60);
// 					if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 					else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 60,220,60);
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 60,220,60);
				}
			}
		}

		m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX - shX + m_sPlayerX, sY - shY + m_sPlayerY, 37, m_dwCurTime);

		if (m_relicX != 0 && m_relicY != 0)
		{
			if (m_relicX >= shX && m_relicX <= shX + 128 && m_relicY >= shY && m_relicY <= shY + 128)
			{
				pointX = (sX - shX + m_relicX) - 1;
				pointY = (sY - shY + m_relicY) - 1;
				for (int pX = 0; pX < 3; pX++)
				{
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 230,60,60);
// 					if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 					else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 230,60,60);
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 230,60,60);
				}
			}
		}

		if ((m_dwCurTime - m_dwMonsterEventTime) < 30000)
		{
			if ((m_dwCurTime % 500) < 370)
			{
				if (m_sEventX >= shX && m_sEventX <= shX + 128 && m_sEventY >= shY && m_sEventY <= shY + 128)
					m_pSprite[SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + m_sEventX - shX, sY + m_sEventY - shY, m_sMonsterID, m_dwCurTime);
			}
		}
		else
		{
			m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
		}
	}
	else // Sans zoom
	{
		if (m_bDialogTrans) m_pSprite[m_iMinMapIndex]->PutTransSprite2(sX, sY, m_iMinMapSquare, m_dwCurTime);
		else m_pSprite[m_iMinMapIndex]->PutSpriteFastNoColorKey(sX, sY, m_iMinMapSquare, m_dwCurTime);

		if (m_iPartyStatus != 0 && m_iIlusionOwnerH == 0)
		{
			for (int i = 0; i < m_stPartyMember.size(); i++)
				if (m_stPartyMember[i]->sX != 0 && m_stPartyMember[i]->sY != 0)
				{
					pointX = sX + ((m_stPartyMember[i]->sX * 128) / (m_pMapData->m_sMapSizeX)) - 1;
					pointY = sY + ((m_stPartyMember[i]->sY * 128) / (m_pMapData->m_sMapSizeY)) - 1;
					for (int pX = 0; pX < 3; pX++)
					{
						//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 60,215,60);
// 						if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 						else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 60,215,60);
						//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 60,215,60);
					}
				}
		}

		if (m_mapPings.size() > 0)
		{
			std::vector<MapPing>::iterator remIt = remove_if(m_mapPings.begin(), m_mapPings.end(), MapPing::Expired);
			m_mapPings.erase(remIt, m_mapPings.end());

			foreach(ping, m_mapPings)
			{
				if (ping->pos.x == 0 || ping->pos.y == 0)
					continue;

				pointX = sX + (ping->pos.x * 128) / m_pMapData->m_sMapSizeX - 1;
				pointY = sY + (ping->pos.y * 128) / m_pMapData->m_sMapSizeY - 1;

				uint32_t frame = (m_dwCurTime % 700) / 140;
				m_pEffectSpr[168]->PutTransSprite_NoColorKey(pointX, pointY, frame, m_dwCurTime);
				for (int pX = 0; pX < 3; pX++)
				{
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 60,220,60);
// 					if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 					else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 60,220,60);
					//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 60,220,60);
				}
			}
		}

		shX = (m_sPlayerX * 128) / (m_pMapData->m_sMapSizeX);
		shY = (m_sPlayerY * 128) / (m_pMapData->m_sMapSizeY);
		m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + shX, sY + shY, 37, m_dwCurTime);

		if (m_relicX != 0 && m_relicY != 0)
		{
			pointX = sX + ((m_relicX * 128) / (m_pMapData->m_sMapSizeX)) - 1;
			pointY = sY + ((m_relicY * 128) / (m_pMapData->m_sMapSizeY)) - 1;
			for (int pX = 0; pX < 3; pX++)
			{
				//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY, 230,60,60);
// 				if(pX==1)//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 50,170,250);
// 				else //DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 1, 230,60,60);
				//DIRECTX m_DDraw.PutPixel(pointX + pX, pointY + 2, 230,60,60);
			}
		}

		if ((G_dwGlobalTime - m_dwMonsterEventTime) < 30000)
		{
			if ((m_dwCurTime % 500) < 370)
			{
				shX = (m_sEventX * 128) / (m_pMapData->m_sMapSizeX);
				shY = (m_sEventY * 128) / (m_pMapData->m_sMapSizeY);
				m_pSprite[SPRID_INTERFACE_MONSTER]->PutSpriteFast(sX + shX, sY + shY, m_sMonsterID, m_dwCurTime);
			}
		}
		else
		{
			m_dwMonsterEventTime = 0;
			m_sMonsterID = 0;
		}
	}

	if (m_stMCursor.LB != 0) return;
	if (m_stMCursor.sX >= sX && m_stMCursor.sX < sX + szY && m_stMCursor.sY >= sY && m_stMCursor.sY < sY + szY)
	{
		//if( sY > 213 ) shY = sY - 17;
		if (sY > 273) shY = sY - 17; // 800x600 Resolution xRisenx
		else shY = sY + szY + 4;
		if (m_bZoomMap) PutString(sX, shY, MSG_GUIDEMAP_MIN, Color(255, 200, 200, 120));//"(-)
		else PutString(sX, shY, MSG_GUIDEMAP_MAX, Color(255, 200, 200, 120));//"(+)

		if (m_bZoomMap)
		{
			shX = m_sPlayerX - 64;
			shY = m_sPlayerY - 64;
			if (shX < 0) shX = 0;
			if (shY < 0) shY = 0;
			if (shX > m_pMapData->m_sMapSizeX - 128) shX = m_pMapData->m_sMapSizeX - 128;
			if (shY > m_pMapData->m_sMapSizeY - 128) shY = m_pMapData->m_sMapSizeY - 128;
			shX += m_stMCursor.sX - sX;
			shY += m_stMCursor.sY - sY;
		}
		else
		{
			shX = (m_stMCursor.sX - sX) * m_pMapData->m_sMapSizeX / 128;
			shY = (m_stMCursor.sY - sY) * m_pMapData->m_sMapSizeY / 128;
		}
		fmt::format_to(G_cTxt, "%d, %d", shX, shY);
		if (m_cMapIndex == 11) // Aresden: Fixed by Snoopy for v3.51 maps
		{
			if (shX > 46 && shX < 66 && shY > 107 && shY < 127) strcpy(G_cTxt, MSG_MAPNAME_MAGICTOWER);
			else if (shX > 103 && shX < 123 && shY > 86 && shY < 116)  strcpy(G_cTxt, MSG_MAPNAME_GUILDHALL);
			else if (shX > 176 && shX < 196 && shY >  62 && shY < 82)  strcpy(G_cTxt, MSG_MAPNAME_CATH);
			//else if( shX > 135 && shX < 155 && shY > 113 && shY < 133 ) strcpy( G_cTxt, MSG_MAPNAME_CITYHALL );
			else if (shX > 135 && shX < 155 && shY > 113 && shY < 133) strcpy(G_cTxt, MSG_MAPNAME_TOWNHALL);
			else if (shX > 97 && shX < 117 && shY > 175 && shY < 195) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 223 && shX < 243 && shY > 124 && shY < 144) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 118 && shX < 138 && shY > 157 && shY < 177) strcpy(G_cTxt, MSG_MAPNAME_SHOP);
			else if (shX > 148 && shX < 178 && shY > 188 && shY < 208) strcpy(G_cTxt, MSG_MAPNAME_BLACKSMITH);
			//else if( shX > 69 && shX < 89   && shY > 199 && shY < 219 ) strcpy( G_cTxt, MSG_MAPNAME_DUNGEON );
			else if (shX > 69 && shX < 89 && shY > 199 && shY < 219) strcpy(G_cTxt, MSG_MAPNAME_CATACOMBS);
			else if (shX > 21 && shX < 41 && shY > 266 && shY < 286) strcpy(G_cTxt, MSG_MAPNAME_HUNT);
			//else if( shX > 20 && shX < 40  && shY > 13   && shY < 33 )  strcpy( G_cTxt, MSG_MAPNAME_ML );
			else if (shX > 20 && shX < 40 && shY > 13 && shY < 33)  strcpy(G_cTxt, MSG_MAPNAME_OUTLANDS);
			else if (shX > 246 && shX < 266 && shY > 16 && shY < 36)  strcpy(G_cTxt, MSG_MAPNAME_ML);
			//else if( shX > 265 && shX < 285 && shY > 195 && shY < 215 ) strcpy( G_cTxt, MSG_MAPNAME_FARM);
			else if (shX > 265 && shX < 285 && shY > 195 && shY < 215) strcpy(G_cTxt, MSG_MAPNAME_PROMISELAND);
			else if (shX > 88 && shX < 108 && shY > 150 && shY < 170) strcpy(G_cTxt, MSG_MAPNAME_CMDHALL);
		}
		else if (m_cMapIndex == 3) // Elvine: Fixed by Snoopy for v3.51 maps
		{
			if (shX > 170 && shX < 190 && shY >  65 && shY < 85)      strcpy(G_cTxt, MSG_MAPNAME_MAGICTOWER);
			else if (shX > 67 && shX < 87 && shY > 130 && shY < 150)  strcpy(G_cTxt, MSG_MAPNAME_GUILDHALL);
			else if (shX > 121 && shX < 141 && shY >  66 && shY < 86)  strcpy(G_cTxt, MSG_MAPNAME_CATH);
			//else if( shX > 135 && shX < 155 && shY > 117 && shY < 137 ) strcpy( G_cTxt, MSG_MAPNAME_CITYHALL );
			else if (shX > 135 && shX < 155 && shY > 117 && shY < 137) strcpy(G_cTxt, MSG_MAPNAME_TOWNHALL);
			else if (shX > 190 && shX < 213 && shY > 118 && shY < 138) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 73 && shX < 103 && shY > 165 && shY < 185) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 217 && shX < 237 && shY > 142 && shY < 162) strcpy(G_cTxt, MSG_MAPNAME_SHOP);
			else if (shX > 216 && shX < 256 && shY > 99 && shY < 119) strcpy(G_cTxt, MSG_MAPNAME_BLACKSMITH);
			//else if( shX > 251 && shX < 271 && shY >  73 && shY < 93 )  strcpy( G_cTxt, MSG_MAPNAME_DUNGEON );
			else if (shX > 251 && shX < 271 && shY >  73 && shY < 93)  strcpy(G_cTxt, MSG_MAPNAME_CATACOMBS);
			else if (shX > 212 && shX < 232 && shY > 13 && shY < 33)  strcpy(G_cTxt, MSG_MAPNAME_HUNT);
			//else if( shX > 16 && shX < 36   && shY > 262 && shY < 282 ) strcpy( G_cTxt, MSG_MAPNAME_ML );
			else if (shX > 16 && shX < 36 && shY > 262 && shY < 282) strcpy(G_cTxt, MSG_MAPNAME_OUTLANDS);
			else if (shX > 244 && shX < 264 && shY > 248 && shY < 268) strcpy(G_cTxt, MSG_MAPNAME_ML);
			//else if( shX > 264 && shX < 284 && shY > 177 && shY < 207 ) strcpy( G_cTxt, MSG_MAPNAME_FARM);
			else if (shX > 264 && shX < 284 && shY > 177 && shY < 207) strcpy(G_cTxt, MSG_MAPNAME_PROMISELAND);
			else if (shX > 207 && shX < 227 && shY > 79 && shY < 99)  strcpy(G_cTxt, MSG_MAPNAME_CMDHALL);
		}
		else if (m_cMapIndex == 5) // Elvine Farm: Fixed by Snoopy for v3.51 maps
		{
			if (shX > 62 && shX < 82 && shY >  187 && shY < 207) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 81 && shX < 101 && shY > 169 && shY < 189) strcpy(G_cTxt, MSG_MAPNAME_SHOP);
			else if (shX > 101 && shX < 131 && shY > 180 && shY < 200) strcpy(G_cTxt, MSG_MAPNAME_BLACKSMITH);
			else if (shX > 130 && shX < 150 && shY > 195 && shY < 215) strcpy(G_cTxt, MSG_MAPNAME_DUNGEON);
			else if (shX > 86 && shX < 106 && shY > 139 && shY < 159) strcpy(G_cTxt, MSG_MAPNAME_BARRACK);
		}
		else if (m_cMapIndex == 6) // Areden's Farm: Fixed by Snoopy for v3.51 maps
		{
			if (shX > 30 && shX < 50 && shY >  80 && shY < 100) strcpy(G_cTxt, MSG_MAPNAME_WAREHOUSE);
			else if (shX > 55 && shX < 85 && shY > 80 && shY < 100)  strcpy(G_cTxt, MSG_MAPNAME_BLACKSMITH);
			else if (shX > 52 && shX < 72 && shY > 80 && shY < 100)  strcpy(G_cTxt, MSG_MAPNAME_SHOP);
			else if (shX > 70 && shX < 90 && shY > 60 && shY < 80)   strcpy(G_cTxt, MSG_MAPNAME_DUNGEON);
			else if (shX > 45 && shX < 65 && shY > 123 && shY < 143) strcpy(G_cTxt, MSG_MAPNAME_BARRACK);
		}
		/*else if ( m_cMapIndex == 41 )
		{
			if     ( shX > 192 && shX < 212 && shY > 165 && shY < 185 ) strcpy( G_cTxt, "Warehouse");
			else if( shX > 145 && shX < 165 && shY > 190 && shY < 210 ) strcpy( G_cTxt, "BlackSmith");
			else if( shX > 136 && shX < 156 && shY > 162 && shY < 182 ) strcpy( G_cTxt, "Shop");
			else if( shX > 203 && shX < 223 && shY > 140 && shY < 160 ) strcpy( G_cTxt, "Magicshop");
			else if( shX > 80  && shX < 100 && shY > 164 && shY < 184 ) strcpy( G_cTxt, "Church" );
			else if( shX > 92  && shX < 112 && shY > 107 && shY < 127 ) strcpy( G_cTxt, "Cityhall" );
			else if( shX > 55  && shX < 75  && shY > 141 && shY < 161 ) strcpy( G_cTxt, "Warehouse");

			else if( shX > 204 && shX < 224 && shY > 18  && shY < 38  ) strcpy( G_cTxt, "Middleland");
			else if( shX > 37 && shX < 57 && shY > 30  && shY < 50  ) strcpy( G_cTxt, "Middleland");

			else if( shX > 223 && shX < 243 && shY > 28  && shY < 48  ) strcpy( G_cTxt, "Dungeon");
			else if( shX > 43  && shX < 63  && shY > 250 && shY < 270 ) strcpy( G_cTxt, "Huntzone");
			else if( shX > 245  && shX < 265  && shY > 150 && shY < 170 ) strcpy( G_cTxt, "Farm");

			else if( shX > 144  && shX < 153  && shY > 93 && shY < 111 ) strcpy( G_cTxt, "GuildHall");
			else if( shX > 185  && shX < 205  && shY > 75 && shY < 95) strcpy( G_cTxt, "Command Hall");

			else if( shX > 223 && shX < 243 && shY > 28  && shY < 48  ) strcpy( G_cTxt, "Dungeon");
		}*/

		/*else if( m_cMapIndex == 42 )
		{
			if( shX >  30 && shX < 50 && shY >  80 && shY < 100 ) strcpy( G_cTxt, "Warehouse");
			else if( shX > 55 && shX < 85 && shY > 80 && shY < 100 )  strcpy( G_cTxt, "BlackSmith");
			else if( shX > 52 && shX < 72 && shY > 80 && shY < 100 )  strcpy( G_cTxt, "Shop");
			else if( shX > 70 && shX < 90 && shY > 60 && shY < 80 )   strcpy( G_cTxt, "Dungeon");
			else if( shX > 45 && shX < 65 && shY > 123 && shY < 143 ) strcpy( G_cTxt, "Barrack");
		}*/

		else if (m_cMapIndex == 7) // New Beginner Map xRisenx
		{
			if (shX > 57 && shX < 77 && shY >  79 && shY < 99) strcpy(G_cTxt, "Safe Shop");
			else if (shX > 12 && shX < 32 && shY > 63 && shY < 83)  strcpy(G_cTxt, "Aresden");
			else if (shX > 87 && shX < 107 && shY > 16 && shY < 36)  strcpy(G_cTxt, "Elvine");
		}

		else if (m_cMapIndex == 31) // Burning Outlands xRisenx
		{
			if (shX > 125 && shX < 145 && shY > 247 && shY < 267)  strcpy(G_cTxt, "Aresden");
			else if (shX > 179 && shX < 199 && shY > 10 && shY < 30)  strcpy(G_cTxt, "Elvine");
		}

		else if (m_cMapIndex == 32) // Catacombs Of Dawn xRisenx
		{
			if (shX > 144 && shX < 164 && shY >  123 && shY < 143) strcpy(G_cTxt, "Nothing Yet!");
			else if (shX > 254 && shX < 274 && shY > 215 && shY < 235)  strcpy(G_cTxt, "Aresden");
			else if (shX > 60 && shX < 80 && shY > 20 && shY < 40)  strcpy(G_cTxt, "Elvine");
		}

		PutString(m_stMCursor.sX - 10, m_stMCursor.sY - 13, G_cTxt, Color(255, 200, 200, 120));
	}
}

void helbreath::DrawDialogBoxes()
{
	int i, k, sprite, frame;
	CDialogBox * dialog;
	bool isTrans;

	if (m_bIsObserverMode == true) return;

	int topDialog = iGetTopDialogBoxIndex();

	m_dialogBoxes[topDialog].SetTop(true);
	////DIRECTX m_dInput.m_sZ = 0;//DIRECTX

	for (i = 0; i < MAXDIALOGBOX; i++)
		if (m_cDialogBoxOrder[i] != 0)
		{
			dialog = &m_dialogBoxes[m_cDialogBoxOrder[i]];

			isTrans = dialog->GetTrans() ? m_bDialogTrans : false;

			if (dialog->HasBackground(sprite, frame))
			{
				DrawNewDialogBox(sprite, dialog->m_X, dialog->m_Y, frame, false, isTrans);
			}
			if (dialog->HasTitleText(frame))
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, dialog->m_X, dialog->m_Y, frame, false, isTrans);
			}

			dialog->Draw();

#ifdef _DEBUG
			if (m_showBtns)
			{
				std::vector<RECT> rects;
				m_dialogBoxes[m_cDialogBoxOrder[i]].GetAllButtons(&rects);
				k = 1;
				for (std::vector<RECT>::iterator j = rects.begin(); j != rects.end(); j++, k++)
				{
					DrawLine(j->left, j->top - 1, j->left, j->bottom - 1, 255, 255, 255);
					DrawLine(j->left - 1, j->top, j->right - 1, j->top, 255, 255, 255);
					DrawLine(j->left, j->bottom, j->right - 1, j->bottom, 255, 255, 255);
					DrawLine(j->right, j->top, j->right, j->bottom - 1, 255, 255, 255);
					fmt::format_to(G_cTxt, "%d", k);
					PutAlignedString(j->left, j->right, j->top - 7 + (j->bottom - j->top) / 2, G_cTxt, Color(255, 255, 255, 255));
				}
			}
#endif

		}
	m_dialogBoxes[topDialog].SetTop(false);

	if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
	{
		if (m_iSuperAttackLeft > 0) // Attack Icon Placement On Action Bar xRisenx
		{
			if (GetAsyncKeyState(VK_MENU) >> 15)
				//m_pSprite[SPRID_INTERFACE_ND_ICONPANNEL]->PutTransSprite(368+127, 439+120, 3, m_dwCurTime); // 800x600 Resolution xRisenx Right? +127 +120
				m_pSprite[SPRID_INTERFACE_ND_ICONPANNEL]->PutTransSprite(12, 557, 45, m_dwCurTime); // Fixed xRisenx
			fmt::format_to(G_cTxt, "%d", m_iSuperAttackLeft);
			//PutString_SprFont2(380+127, 454+120, G_cTxt, 220, 200, 200); // 800x600 Resolution xRisenx Right? +127 +120
			PutString_SprFont2(14, 578, G_cTxt, 220, 200, 200);	// Fixed xRisenx
		}
	}
	else
	{
		if (m_iSuperAttackLeft > 0)
		{
			fmt::format_to(G_cTxt, "%d", m_iSuperAttackLeft);
			//PutString_SprFont2(380+127, 454+120, G_cTxt, 10, 10, 10); // 800x600 Resolution xRisenx Right? +127 +120
			PutString_SprFont2(14, 578, G_cTxt, 10, 10, 10);	// Fixed xRisenx
		}
	}
}

void helbreath::_Draw_CharacterBody(short sX, short sY, short sType)
{
	uint64_t dwTime = m_dwCurTime;
	int  iR, iG, iB;

	if (sType <= 3)
	{
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX, sY, sType - 1, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);

		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
	else
	{
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX, sY, sType - 4, dwTime);
		_GetHairColorRGB(((_tmp_sAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 18 + 40]->PutSpriteRGB(sX, sY, (_tmp_sAppr1 & 0x0F00) >> 8, iR, iG, iB, dwTime);
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 19 + 40]->PutSpriteFast(sX, sY, (_tmp_sAppr1 & 0x000F), dwTime);
	}
}


int helbreath::iGetTopDialogBoxIndex()
{
	int i;

	for (i = MAXDIALOGBOX - 3; i >= 0; i--) //ignore top 2
		if (m_cDialogBoxOrder[i] != 0)
			return m_cDialogBoxOrder[i];

	return 0;
}


void helbreath::DrawChatMsgs(short sX, short sY, short dX, short dY)
{
	int i;

	for (i = 0; i < MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY))
			{

				switch (m_pChatMsgList[i]->m_cType)
				{
					case 41:
					case 42:
					case 21:
					case 22:
					case 23:
						DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, false);
						break;
				}
			}

	//DIRECTX m_DDraw._GetBackBufferDC();
	for (i = 0; i < MAXCHATMSGS; i++)
		if (m_pChatMsgList[i] != 0)
			if ((m_pChatMsgList[i]->m_sX >= sX) && (m_pChatMsgList[i]->m_sX <= dX) &&
				(m_pChatMsgList[i]->m_sY >= sY) && (m_pChatMsgList[i]->m_sY <= dY))
			{

				switch (m_pChatMsgList[i]->m_cType)
				{
					case 41:
					case 42:
					case 21:
					case 22:
					case 23:
						break;

					case 20:
					default:
						DrawChatMsgBox(m_pChatMsgList[i]->m_sX, m_pChatMsgList[i]->m_sY, i, true);
						break;
				}
			}
	//DIRECTX m_DDraw._ReleaseBackBufferDC();
}



void helbreath::_LoadTextDlgContents(int cType)
{
	char * pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	class  CStrTok * pStrTok;
	uint32_t  dwFileSize;
	HANDLE hFile;
	FILE * pFile;
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	// cType
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	fmt::format_to(cTemp, "contents%d", cType);
	strcat(cFileName, "data\\shops");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFileA(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else
	{
		pContents = new char[dwFileSize + 1];
		ZeroMemory(pContents, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		m_pMsgTextList[iIndex] = new class CMsg(0, token, 0);
		token = pStrTok->pGet();
		iIndex++;
	}
	delete pStrTok;
	delete[] pContents;
}



int helbreath::_iLoadTextDlgContents2(int iType)
{
	char * pContents, * token, cTemp[120], cFileName[120];
	char   seps[] = "\n";
	int    iIndex = 0, i;
	class  CStrTok * pStrTok;
	uint32_t  dwFileSize;
	HANDLE hFile;
	FILE * pFile;
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList2[i] != 0)
			delete m_pMsgTextList2[i];
		m_pMsgTextList2[i] = 0;
	}
	// cType
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	fmt::format_to(cTemp, "contents%d", iType);

	strcat(cFileName, "data\\shops");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");
	hFile = CreateFileA(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return -1;
	else
	{
		pContents = new char[dwFileSize + 1];
		if (pContents == 0) return -1;
		ZeroMemory(pContents, dwFileSize + 1);
		fread(pContents, dwFileSize, 1, pFile);
	}
	fclose(pFile);
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		m_pMsgTextList2[iIndex] = new class CMsg(0, token, 0);
		token = pStrTok->pGet();
		iIndex++;
	}
	delete pStrTok;
	delete[] pContents;
	return iIndex;
}

void helbreath::DlgBoxClick_Party()
{
	char onButton = m_dialogBoxes[32].OnButton();
	switch (m_dialogBoxes[32].GetMode())
	{
		case 0:
			if (m_iPartyStatus == 0)
			{
				if (onButton == 1)
				{
					m_dialogBoxes[32].SetMode(2);
					m_bIsGetPointingMode = true;
					m_iPointCommandType = 200;
					PlaySound('E', 14, 5);
				}
			}

			if (m_iPartyStatus != 0)
			{
				if (onButton == 2)
				{
					m_dialogBoxes[32].SetMode(11);
					PlaySound('E', 14, 5);
				}
			}

			if (m_iPartyStatus != 0)
			{
				if (onButton == 3)
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_JOINPARTY, 0, 2, 0, 0, m_cMCName);
					m_dialogBoxes[32].SetMode(4);
					PlaySound('E', 14, 5);
				}
			}


			if (onButton == 4)
			{
				m_partyAutoAccept = !m_partyAutoAccept;
				PlaySound('E', 14, 5);
			}

			if (onButton == 5) DisableDialogBox(32);
			break;

		case 1:
			if (onButton == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 1, 0, 0, m_dialogBoxes[32].cStr);
				DisableDialogBox(32);
				PlaySound('E', 14, 5);
			}

			if (onButton == 2)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 0, 0, 0, m_dialogBoxes[32].cStr);
				DisableDialogBox(32);
				PlaySound('E', 14, 5);
			}
			break;

		case 2:
			if (onButton == 1)
			{
				m_dialogBoxes[32].SetMode(0);
				PlaySound('E', 14, 5);
			}
			break;

		case 3:
			// cancel
			if (onButton == 1)
			{
				m_dialogBoxes[32].SetMode(0);
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_ACCEPTJOINPARTY, 0, 2, 0, 0, m_dialogBoxes[32].cStr);
				DisableDialogBox(32);
				PlaySound('E', 14, 5);
			}
			break;

		case 4:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
			if (onButton == 1)
			{
				m_dialogBoxes[32].SetMode(0);
				PlaySound('E', 14, 5);
			}
			break;

		case 11:
			if (onButton == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_JOINPARTY, 0, 0, 0, 0, m_cMCName);
				m_dialogBoxes[32].SetMode(5);
				PlaySound('E', 14, 5);
			}

			if (onButton == 2)
			{
				m_dialogBoxes[32].SetMode(0);
				PlaySound('E', 14, 5);
			}
			break;
	}
}


void helbreath::DlgBoxClick_CrusadeJob()
{
	char onButton = m_dialogBoxes[33].OnButton();

	switch (m_dialogBoxes[33].GetMode())
	{
		case 1:
			if (m_side == NEUTRAL)
			{
				DisableDialogBox(33);
				PlaySound('E', 14, 5);
			}
			else
			{
				if (onButton == 1 && m_iGuildRank != GUILDRANK_NONE && gldRankPerm[m_iGuildRank].crusadeCommander)
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, 0, 3, 0, 0, 0);
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}

				if (onButton == 2)
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, 0, 1, 0, 0, 0);
					DisableDialogBox(33);
					PlaySound('E', 14, 5);
				}

				if (m_iGuildRank != GUILDRANK_NONE)
				{
					if (onButton == 3)
					{
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_SELECTCRUSADEDUTY, 0, 2, 0, 0, 0);
						DisableDialogBox(33);
						PlaySound('E', 14, 5);
					}
				}
			}

			if (onButton == 4)
			{
				DisableDialogBox(18);
				EnableDialogBox(18, 813, 0, 0);
				PlaySound('E', 14, 5);
			}
			break;

		case 2:
			if (onButton == 1)
			{
				switch (m_iCrusadeDuty)
				{
					case 1: EnableDialogBox(18, 803, 0, 0); break;
					case 2: EnableDialogBox(18, 805, 0, 0); break;
					case 3: EnableDialogBox(18, 808, 0, 0); break;
				}
			}
			else if (onButton == 2)
			{
				DisableDialogBox(33);
				PlaySound('E', 14, 5);
			}
			break;
	}
}

void helbreath::_RequestMapStatus(const char * pMapName, int iMode)
{
	bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_MAPSTATUS, 0, iMode, 0, 0, pMapName);
}

void helbreath::AddMapStatusInfo(char * pData, bool bIsLastData)
{
	char * cp, cTotal;
	short * sp, sIndex;
	int i;

	ZeroMemory(m_cStatusMapName, sizeof(m_cStatusMapName));

	cp = (char *)(pData + 6);
	memcpy(m_cStatusMapName, cp, 10);
	cp += 10;

	sp = (short *)cp;
	sIndex = *sp;
	cp += 2;

	cTotal = *cp;
	cp++;

	for (i = 1; i <= cTotal; i++)
	{
		m_stCrusadeStructureInfo[sIndex].cType = *cp;
		cp++;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sX = *sp;
		cp += 2;
		sp = (short *)cp;
		m_stCrusadeStructureInfo[sIndex].sY = *sp;
		cp += 2;
		m_stCrusadeStructureInfo[sIndex].cSide = *cp;
		cp++;

		sIndex++;
	}

	if (bIsLastData == true)
	{
		while (sIndex < MAXCRUSADESTRUCTURES)
		{
			m_stCrusadeStructureInfo[sIndex].cType = 0;
			m_stCrusadeStructureInfo[sIndex].sX = 0;
			m_stCrusadeStructureInfo[sIndex].sY = 0;
			m_stCrusadeStructureInfo[sIndex].cSide = 0;
			sIndex++;
		}
	}
}

bool helbreath::GetText(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	int len;
	HIMC hIMC = 0;

	if (m_pInputBuffer == 0) return false;
	switch (msg)
	{
		/*case WM_IME_COMPOSITION:
			ZeroMemory(m_cEdit, sizeof(m_cEdit));
			if (lparam & GCS_RESULTSTR)
			{
				hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_RESULTSTR, NULL, 0);
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_RESULTSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len < m_inputMaxLen) strcpy(m_pInputBuffer+strlen(m_pInputBuffer),m_cEdit);
				ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}
			else if (lparam & GCS_COMPSTR)
			{
				hIMC = ImmGetContext(hWnd);
				len = ImmGetCompositionString(hIMC, GCS_COMPSTR, NULL, 0);
				if( len > 4 ) len = 4;
				ImmGetCompositionString(hIMC, GCS_COMPSTR, m_cEdit, len);
				ImmReleaseContext(hWnd, hIMC);
				len = strlen(m_pInputBuffer) + strlen(m_cEdit);
				if (len >= m_inputMaxLen) ZeroMemory(m_cEdit, sizeof(m_cEdit));
			}
			return TRUE;*/

		case WM_CHAR:
			if (wparam == 8)
			{
				if (strlen(m_pInputBuffer) > 0)
				{
					len = strlen(m_pInputBuffer);

					switch (GetCharKind(m_pInputBuffer, len - 1))
					{
						case 1:
							m_pInputBuffer[len - 1] = 0;
							break;
						case 2:
						case 3:
							m_pInputBuffer[len - 2] = 0;
							m_pInputBuffer[len - 1] = 0;
							break;
					}
					ZeroMemory(m_cEdit, sizeof(m_cEdit));
				}
			}
			else if ((wparam != 9) && (wparam != 13) && (wparam != 27))
			{
				len = strlen(m_pInputBuffer);
				if (len >= m_inputMaxLen - 1) return false;
				m_pInputBuffer[len] = wparam & 0xff;
				m_pInputBuffer[len + 1] = 0;
			}

			return true;
	}
	return false;
}



int helbreath::GetCharKind(char * str, int index)
{
	int kind = 1;
	do
	{
		if (kind == 2) kind = 3;
		else
		{
			if ((unsigned char)*str < 128) kind = 1;
			else kind = 2;
		}
		str++;
		index--;
	} while (index >= 0);
	return kind;
}

void helbreath::ShowReceivedString(bool bIsHide)
{
	ZeroMemory(G_cTxt2, sizeof(G_cTxt2));

#ifdef USING_WIN_IME
	if (G_hEditWnd != 0) GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_inputMaxLen);
	strcpy(G_cTxt2, m_pInputBuffer);
#else
	strcpy(G_cTxt2, m_pInputBuffer);
	if ((m_cEdit[0] != 0) && (strlen(m_pInputBuffer) + strlen(m_cEdit) + 1 <= m_inputMaxLen))
	{
		strcpy(G_cTxt2 + strlen(m_pInputBuffer), m_cEdit);
	}
#endif
	if (bIsHide == true)
	{
		for (unsigned char i = 0; i < strlen(G_cTxt2); i++)
			if (G_cTxt2[i] != 0) G_cTxt2[i] = '*';
	}

	if ((G_dwGlobalTime % 400) < 210)
		G_cTxt2[strlen(G_cTxt2)] = '_';

	if (m_iInputX2 == 0)
	{
		PutString(m_iInputX + 1, m_iInputY + 1, G_cTxt2, Color(255, 0, 0, 0));
		PutString(m_iInputX, m_iInputY + 1, G_cTxt2, Color(255, 0, 0, 0));
		PutString(m_iInputX + 1, m_iInputY, G_cTxt2, Color(255, 0, 0, 0));
		PutString(m_iInputX, m_iInputY, G_cTxt2, Color(255, 255, 255, 255));
	}
	else
	{
		PutAlignedString(m_iInputX + 1, m_iInputX2 + 1, m_iInputY + 1, G_cTxt2, Color(255, 0, 0, 0));
		PutAlignedString(m_iInputX, m_iInputX2, m_iInputY + 1, G_cTxt2, Color(255, 0, 0, 0));
		PutAlignedString(m_iInputX + 1, m_iInputX2 + 1, m_iInputY, G_cTxt2, Color(255, 0, 0, 0));
		PutAlignedString(m_iInputX, m_iInputX2, m_iInputY, G_cTxt2, Color(255, 255, 255, 255));
	}
}

void helbreath::ClearInputString()
{
	if (m_pInputBuffer != 0)	ZeroMemory(m_pInputBuffer, sizeof(m_pInputBuffer));
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
#ifdef USING_WIN_IME
	if (G_hEditWnd != 0)	SetWindowText(G_hEditWnd, "");
#endif
}

void helbreath::StartInputString(int left, int top, uint32_t len, char * pBuffer, bool bIsHide, int right)
{
	m_bInputStatus = true;
	m_iInputX = left;
	m_iInputY = top;
	m_iInputX2 = right;
	m_pInputBuffer = pBuffer;
	ZeroMemory(m_cEdit, sizeof(m_cEdit));
	m_inputMaxLen = len;
#ifdef USING_WIN_IME
	if (bIsHide == false) G_hEditWnd = CreateWindow(RICHEDIT_CLASS, 0, WS_POPUP | ES_SELFIME, sX - 5, sY - 1, len * 12, 16, G_hWnd, (HMENU)0, G_hInstance, 0);
	else G_hEditWnd = CreateWindow(RICHEDIT_CLASS, 0, WS_POPUP | ES_PASSWORD | ES_SELFIME, sX - 5, sY - 1, len * 12, 16, G_hWnd, (HMENU)0, G_hInstance, 0);
	SetWindowText(G_hEditWnd, m_pInputBuffer);
	SendMessage(G_hEditWnd, EM_EXLIMITTEXT, 0, len - 1);
	SendMessage(G_hEditWnd, EM_SETLANGOPTIONS, 0, ~IMF_AUTOFONT);
	COMPOSITIONFORM composform;
	composform.dwStyle = CFS_POINT;
	composform.ptCurrentPos.x = sX;
	composform.ptCurrentPos.y = sY;
	HIMC hImc = ImmGetContext(G_hWnd);
	ImmSetCompositionWindow(hImc, &composform);
	int StrLen = strlen(m_pInputBuffer);
	SendMessage(G_hEditWnd, EM_SETSEL, StrLen, StrLen);
#endif
}

void helbreath::EndInputString()
{
	m_bInputStatus = false;
#ifdef USING_WIN_IME
	if (G_hEditWnd != 0)
	{
		GetWindowText(G_hEditWnd, m_pInputBuffer, (int)m_inputMaxLen);
		CANDIDATEFORM candiform;
		SendMessage(G_hEditWnd, WM_IME_CONTROL, IMC_GETCANDIDATEPOS, (LPARAM)&candiform);
		DestroyWindow(G_hEditWnd);
		G_hEditWnd = 0;
	}
#else
	int len = strlen(m_cEdit);
	if (len > 0)
	{
		m_cEdit[len] = 0;
		strcpy(m_pInputBuffer + strlen(m_pInputBuffer), m_cEdit);
		ZeroMemory(m_cEdit, sizeof(m_cEdit));
	}
#endif
}

void helbreath::ReceiveString(char * pString)
{
	strcpy(pString, m_pInputBuffer);

#ifdef USING_WIN_IME
	if (G_hEditWnd != 0) GetWindowText(G_hEditWnd, pString, (int)m_inputMaxLen);
#endif
}

void helbreath::DrawNewDialogBox(char cType, int sX, int sY, int iFrame, bool bIsNoColorKey, bool bIsTrans)
{
	uint64_t dwTime = G_dwGlobalTime;

	if (m_pSprite[cType] == 0) return;
	if (bIsNoColorKey == false)
	{
		if (bIsTrans == true)
			m_pSprite[cType]->PutTransSprite2(sX, sY, iFrame, dwTime);
		else m_pSprite[cType]->PutSpriteFast(sX, sY, iFrame, dwTime);
	}
	else m_pSprite[cType]->PutSpriteFastNoColorKey(sX, sY, iFrame, dwTime);
}

void helbreath::DlgBoxClick_Commander() // Snoopy: Fixed for 351
{
	short  tX, tY;
	double d1, d2, d3;
	if (m_bIsCrusadeMode == false) return;

	short sX = m_dialogBoxes[36].m_X;
	short sY = m_dialogBoxes[36].m_Y;
	short msX = m_stMCursor.sX;
	short msY = m_stMCursor.sY;

	char onButton = m_dialogBoxes[36].OnButton();
	switch (m_dialogBoxes[36].GetMode())
	{
		case 0: // Main
			switch (onButton)
			{
				case 1:
					m_dialogBoxes[36].SetMode(1);
					PlaySound('E', 14, 5);
					break;

				case 2:
					if (m_iTeleportLocX == -1)
					{
						SetTopMsg(CRUSADE_MESSAGE15, 5);
					}
					else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
					{
						SetTopMsg(CRUSADE_MESSAGE16, 5);
					}
					else
					{
						m_dialogBoxes[36].SetMode(2);
						PlaySound('E', 14, 5);
					}
					break;

				case 3:
					m_dialogBoxes[36].SetMode(3);
					m_dialogBoxes[36].sV1 = 0;
					PlaySound('E', 14, 5);
					break;

				case 4:
					m_dialogBoxes[36].SetMode(4);
					PlaySound('E', 14, 5);
					break;

				case 5:
					DisableDialogBox(18);
					EnableDialogBox(18, 808, 0, 0);
					PlaySound('E', 14, 5);
					break;
			}
			break;

		case 1: // Set TP
			switch (onButton)
			{
				case 1:
					d1 = (double)(m_stMCursor.sX - (sX + 15));
					d2 = (double)(250.0f); //(752.0f);
					d3 = (d2 * d1) / 125.0f;
					tX = (int)d3;
					d1 = (double)(m_stMCursor.sY - (sY + 60));
					d2 = (double)(250.0f); //(680.0f);
					d3 = (d2 * d1) / (125.0f); //253.0f;
					tY = (int)d3;
					if (tX < 30) tX = 30;
					if (tY < 30) tY = 30;
					if (tX > 220) tX = 220;//722;
					if (tY > 220) tY = 220;//650;
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SETGUILDTELEPORTLOC, 0, tX, tY, 0, "2ndmiddle");
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					_RequestMapStatus("2ndmiddle", 1);
					break;

				case 2:
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					break;

				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 809, 0, 0);
					PlaySound('E', 14, 5);
			}
			break;

		case 2: // Use TP
			switch (onButton)
			{
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
					DisableDialogBox(36);
					PlaySound('E', 14, 5);
					break;

				case 2:
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					break;

				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 810, 0, 0);
					PlaySound('E', 14, 5);
			}
			break;

		case 3: // Summon Unit
			if (m_side == ARESDEN)
			{
				switch (onButton)
				{
					case 1:
						if (m_iConstructionPoint >= 3000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 47, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;

					case 2:
						if (m_iConstructionPoint >= 2000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 46, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;

					case 3:
						if (m_iConstructionPoint >= 1000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 43, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;

					case 4:
						if (m_iConstructionPoint >= 1500)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 51, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;
				}
			}
			else if (m_side == ELVINE)
			{
				switch (onButton)
				{
					case 1:
						if (m_iConstructionPoint >= 3000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 45, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;
					case 2:
						if (m_iConstructionPoint >= 2000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 44, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;
					case 3:
						if (m_iConstructionPoint >= 1000)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 43, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;
					case 4:
						if (m_iConstructionPoint >= 1500)
						{
							bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 51, 1, m_dialogBoxes[36].sV1, 0);
							PlaySound('E', 14, 5);
							DisableDialogBox(36);
						}
						break;
				}
			}
			switch (onButton)
			{
				case 5:
					m_dialogBoxes[36].sV1 = 0;
					PlaySound('E', 14, 5);
					break;
				case 6:
					m_dialogBoxes[36].sV1 = 1;
					PlaySound('E', 14, 5);
					break;
				case 7:
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					break;
				case 8:
					DisableDialogBox(18);
					EnableDialogBox(18, 811, 0, 0);
					PlaySound('E', 14, 5);
					break;
			}
			break;

		case 4: // Set constr
			switch (onButton)
			{
				case 1:
					d1 = (double)(m_stMCursor.sX - (sX + 15));
					d2 = (double)(250.0);//(752.0f);
					d3 = (d2 * d1) / 125.0f;
					tX = (int)d3;
					d1 = (double)(m_stMCursor.sY - (sY + 60));
					d2 = (double)(250.0);//(680.0f);
					d3 = (d2 * d1) / (125.0);//253.0f;
					tY = (int)d3;
					if (tX < 30) tX = 30;
					if (tY < 30) tY = 30;
					if (tX > 220) tX = 220;//722;
					if (tY > 220) tY = 220;//650;
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SETGUILDCONSTRUCTLOC, 0, tX, tY, 0, "2ndmiddle");
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					_RequestMapStatus("2ndmiddle", 1);
					break;
				case 2:
					m_dialogBoxes[36].SetMode(0);
					PlaySound('E', 14, 5);
					break;
				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 812, 0, 0);
					PlaySound('E', 14, 5);
					break;
			}
			break;
	}
}


void helbreath::DlgBoxClick_Constructor()  // Snoopy: Fixed for 351
{ //short sX, sY;
	if (m_bIsCrusadeMode == false) return;
	//sX = m_stDialogBoxInfo[37].sX;
	//sY = m_stDialogBoxInfo[37].sY;
	char onButton = m_dialogBoxes[37].OnButton();
	switch (m_dialogBoxes[37].GetMode())
	{
		case 0: // Main
			switch (onButton)
			{
				case 1:
					if (m_iConstructLocX == -1)
					{
						SetTopMsg(CRUSADE_MESSAGE14, 5);
					}
					else
					{
						m_dialogBoxes[37].SetMode(1);
						PlaySound('E', 14, 5);
					}
					break;
				case 2:
					if (m_iTeleportLocX == -1)
					{
						SetTopMsg(CRUSADE_MESSAGE15, 5);
					}
					else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
					{
						SetTopMsg(CRUSADE_MESSAGE16, 5);
					}
					else
					{
						m_dialogBoxes[37].SetMode(2);
						PlaySound('E', 14, 5);
					}
					break;
				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 805, 0, 0);
					PlaySound('E', 14, 5);
					break;
			}
			break;

		case 1: // Choose building
			switch (onButton)
			{
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 38, 1, m_dialogBoxes[36].sV1, 0);
					DisableDialogBox(37);
					break;

				case 2:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 39, 1, m_dialogBoxes[36].sV1, 0);
					DisableDialogBox(37);
					break;

				case 3:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 36, 1, m_dialogBoxes[36].sV1, 0);
					DisableDialogBox(37);
					break;

				case 4:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SUMMONWARUNIT, 0, 37, 1, m_dialogBoxes[36].sV1, 0);
					DisableDialogBox(37);
					break;

				case 5:
					m_dialogBoxes[37].SetMode(0);
					break;

				case 6:
					DisableDialogBox(18);
					EnableDialogBox(18, 806, 0, 0);
					break;
			}
			if (onButton) PlaySound('E', 14, 5);
			break;

		case 2: // Use TP
			switch (onButton)
			{
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
					DisableDialogBox(37);
					break;

				case 2:
					m_dialogBoxes[37].SetMode(0);
					break;

				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 807, 0, 0);
					break;
			}
			if (onButton) PlaySound('E', 14, 5);
			break;
	}
}


void helbreath::DlgBoxClick_Soldier() // Snoopy: Fixed for 351
{
	if (m_bIsCrusadeMode == false) return;
	char onButton = m_dialogBoxes[38].OnButton();
	switch (m_dialogBoxes[38].GetMode())
	{
		case 0: // Main dlg
			switch (onButton)
			{
				case 1:
					if (m_iTeleportLocX == -1)
					{
						SetTopMsg(CRUSADE_MESSAGE15, 5);
					}
					else if (strcmp(m_cMapName, m_cTeleportMapName) == 0)
					{
						SetTopMsg(CRUSADE_MESSAGE16, 5);
					}
					else
					{
						m_dialogBoxes[38].SetMode(1);
						PlaySound('E', 14, 5);
					}
					break;
				case 2:
					DisableDialogBox(18);
					EnableDialogBox(18, 803, 0, 0);
					PlaySound('E', 14, 5);
					break;
			}
			break;

		case 1: // Use TP
			switch (onButton)
			{
				case 1:
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GUILDTELEPORT, 0, 0, 0, 0, 0);
					DisableDialogBox(38);
					break;
				case 2:
					m_dialogBoxes[38].SetMode(0);
					break;
				case 3:
					DisableDialogBox(18);
					EnableDialogBox(18, 804, 0, 0);
			}
			if (onButton) PlaySound('E', 14, 5);
			break;
	}
}

void helbreath::SetCameraShakingEffect(short sDist, int iMul)
{
	int iDegree;

	iDegree = 5 - sDist;
	if (iDegree <= 0) iDegree = 0;
	iDegree *= 2;

	if (iMul != 0) iDegree *= iMul;

	if (iDegree <= 2) return;

	m_iCameraShakingDegree = iDegree;
}

void helbreath::MeteorStrikeComing(int iCode)
{
	switch (iCode)
	{
		case 1: //
			SetTopMsg(CRUSADE_MESSAGE0, 5);
			break;
		case 2: //
			SetTopMsg(CRUSADE_MESSAGE10, 10);
			break;
		case 3: //
			SetTopMsg(CRUSADE_MESSAGE90, 5);
			break;
		case 4: //
			SetTopMsg(CRUSADE_MESSAGE11, 10);
			break;
	}
}

void helbreath::DrawObjectFOE(int ix, int iy, int iFrame)
{
	if (_iGetFOE(_tmp_iStatus) < 0) // red crusade circle
	{
		if (iFrame <= 4) m_pEffectSpr[38]->PutTransSprite(ix, iy, iFrame, G_dwGlobalTime);
	}
}

void helbreath::SetTopMsg(const char * pString, unsigned char iLastSec)
{
	ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	strcpy(m_cTopMsg, pString);

	m_iTopMsgLastSec = iLastSec;
	m_dwTopMsgTime = G_dwGlobalTime;
}

void helbreath::DrawTopMsg()
{
	if (strlen(m_cTopMsg) == 0) return;
	////DIRECTX m_DDraw.DrawShadowBox(0, 0, 639, 30);
	//DIRECTX m_DDraw.DrawShadowBox(0, 20, 799, 55); // 800x600 Resolution xRisenx

	if ((((G_dwGlobalTime - m_dwTopMsgTime) / 250) % 2) == 0)
		//PutAlignedString(0, 639, 10, m_cTopMsg, 255,255,255);
		PutAlignedString(0, GetWidth() - 1, 30, m_cTopMsg, Color(255, 255, 255, 255)); // 800x600 Resolution xRisenx

	if (G_dwGlobalTime > (m_iTopMsgLastSec * CLOCKS_PER_SEC + m_dwTopMsgTime))
	{
		ZeroMemory(m_cTopMsg, sizeof(m_cTopMsg));
	}
}

void helbreath::DrawAstoriaStats()
{
	//fmt::format_to( G_cTxt, "Kills");
	//PutString_SprFont3(30, 150, G_cTxt, m_wR[14]*4, m_wG[14]*4, m_wB[14]*4, TRUE, 2);

	fmt::format_to(G_cTxt, "%s: %d", sideName[ARESDEN], m_astoriaStats[ARESDEN].kills);
	PutString_SprFont3(10, 160, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
	fmt::format_to(G_cTxt, "%s: %d", sideName[ELVINE], m_astoriaStats[ELVINE].kills);
	PutString_SprFont3(10, 175, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);

	if (m_astoriaShieldsHP[ARESDEN] != 0 && m_astoriaShieldsHP[ELVINE] != 0)
	{
		fmt::format_to(G_cTxt, "%s Shield: %d", sideName[ARESDEN], m_astoriaShieldsHP[ARESDEN]);
		PutString_SprFont3(10, 200, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
		fmt::format_to(G_cTxt, "%s Shield: %d", sideName[ELVINE], m_astoriaShieldsHP[ELVINE]);
		PutString_SprFont3(10, 215, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
	}

	if (m_relicOwnedTime != 0)
	{
		uint32_t currTime = unixtime();
		fmt::format_to(G_cTxt, "Time left for %s to win: %u:%.2u", sideName[m_relicOwnedSide],
			((m_relicOwnedTime + RELICVICTORYTIME - currTime) / 1000) / 60,
			((m_relicOwnedTime + RELICVICTORYTIME - currTime) / 1000) % 60
		);
		PutString_SprFont3(190, 25, G_cTxt, m_wR[3] * 4, m_wG[3] * 4, m_wB[3] * 4, true, 2);
	}
}

void helbreath::DrawDialogBox_Text()
{
	short sX, sY;
	int i, iTotalLines;

	sX = m_dialogBoxes[18].m_X;
	sY = m_dialogBoxes[18].m_Y;

	iTotalLines = 0;
	for (i = 0; i < TEXTDLGMAXLINES; i++)
		if (m_pMsgTextList[i] != 0) iTotalLines++;

	Point pointerLoc = m_dialogBoxes[18].HandleScroll(17, iTotalLines);

	if (iTotalLines > 17)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
	}

	for (i = 0; i < 17; i++)
		if (m_pMsgTextList[i + m_dialogBoxes[18].sView] != 0)
		{
			if (m_bDialogTrans == false)
			{
				switch (m_pMsgTextList[i + m_dialogBoxes[18].sView]->m_pMsg[0])
				{
					case '_': PutAlignedString(sX + 24, sX + 236, sY + 50 + i * 13, (m_pMsgTextList[i + m_dialogBoxes[18].sView]->m_pMsg + 1), Color(255, 255, 255, 255)); break;
					case ';': PutAlignedString(sX + 24, sX + 236, sY + 50 + i * 13, (m_pMsgTextList[i + m_dialogBoxes[18].sView]->m_pMsg + 1), Color(255, 4, 0, 50)); break;
					default: PutAlignedString(sX + 24, sX + 236, sY + 50 + i * 13, m_pMsgTextList[i + m_dialogBoxes[18].sView]->m_pMsg, Color(255, 45, 25, 25)); break;
				}
			}
			else PutAlignedString(sX + 24, sX + 236, sY + 50 + i * 13, m_pMsgTextList[i + m_dialogBoxes[18].sView]->m_pMsg, Color(255, 0, 0, 0));
		}

	if (m_dialogBoxes[18].OnButton() == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
}

void helbreath::DrawDialogBox_15AgeMsg()
{
	return;
	// Snoopy: removed FeedbackCard & minus 15 age

}


void helbreath::DrawDialogBox_WarningMsg()
{
	short sX, sY;
	char onButton = m_dialogBoxes[6].OnButton();

	sX = m_dialogBoxes[6].m_X;
	sY = m_dialogBoxes[6].m_Y;


	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX, sY, 2);

	PutString2(sX + 72, sY + 32, MSG_WARNING1, 200, 200, 25);//" ** This is a battle area **"
	PutString(sX + 30, sY + 55, MSG_WARNING2, Color(255, 220, 130, 45));//"This is a dangerous area where you"
	PutString(sX + 30, sY + 72, MSG_WARNING3, Color(255, 220, 130, 45));//"cannot protected from others' attack."
	PutString(sX + 30, sY + 90, MSG_WARNING4, Color(255, 220, 130, 45));//"To play the game in safe, go to the"
	PutString(sX + 30, sY + 108, MSG_WARNING5, Color(255, 220, 130, 45));//" cityhall and change to civilian mode."

	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 122, sY + 127, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 122, sY + 127, 0);

}

void helbreath::DrawDialogBox_NpcTalk()
{
	short sX, sY;
	int i, iTotalLines;
	double d1, d2, d3;

	char onButton = m_dialogBoxes[4].OnButton();
	sX = m_dialogBoxes[21].m_X;
	sY = m_dialogBoxes[21].m_Y;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_dialogBoxes[21].GetMode())
	{
		case 0: //  OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 1: // Accept / Decline
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 33);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 32);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 41);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 40);
			break;

		case 2: // Next
			if (onButton == 1)
				PutString_SprFont(sX + RBTNPOSX, sY + BTNPOSY, "Next", 6, 6, 20);
			else PutString_SprFont(sX + RBTNPOSX, sY + BTNPOSY, "Next", 0, 0, 7);
			break;
	}

	for (i = 0; i < 17; i++)
		if ((i < TEXTDLGMAXLINES) && (m_pMsgTextList2[i + m_dialogBoxes[21].sView] != 0))
		{
			PutAlignedString(sX, sX + m_dialogBoxes[21].sSizeX, sY + 57 + i * 15, m_pMsgTextList2[i + m_dialogBoxes[21].sView]->m_pMsg, Color(255, 45, 25, 25));
		}

	iTotalLines = 0;
	for (i = 0; i < TEXTDLGMAXLINES; i++)
		if (m_pMsgTextList2[i] != 0) iTotalLines++;

	Point pointerLoc = m_dialogBoxes[21].HandleScroll(17, iTotalLines);
	if (iTotalLines > 17)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
	}
}

void helbreath::DlgBoxClick_Slates()
{
	switch (m_dialogBoxes[40].GetMode())
	{
		case 1:
			if ((m_dialogBoxes[40].sV1 != -1) && (m_dialogBoxes[40].sV2 != -1) && (m_dialogBoxes[40].sV3 != -1) && (m_dialogBoxes[40].sV4 != -1))
			{
				if (m_dialogBoxes[40].OnButton() == 1)
				{
					m_dialogBoxes[40].SetMode(2);
					PlaySound('E', 14, 5);
				}
			}
			break;
	}
}

void helbreath::DlgBoxClick_NpcTalk()
{
	char onButton = m_dialogBoxes[21].OnButton();
	switch (m_dialogBoxes[21].GetMode())
	{
		case 0: //  OK
			if (onButton == 1)
			{
				DisableDialogBox(21);
			}
			break;

		case 1: // Accept / Decline
			if (onButton == 1)
			{
				// Accept
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_QUESTACCEPTED, 0, 0, 0, 0, 0);
				DisableDialogBox(21);
			}
			else if (onButton == 2)
			{
				// Cancel
				DisableDialogBox(21);
			}
			break;

		case 2:	// Next
			if (onButton == 1)
			{
				DisableDialogBox(21);
			}
			break;
	}
	if (onButton)PlaySound('E', 14, 5);
}

void helbreath::TimeStamp(char * pString)
{
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	fmt::format_to(pString, "%02d:%02d:%02d", SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
}

void helbreath::DrawDialogBox_Chat()
{
	char G_cTxt[120];

	CDialogBox & dlg = m_dialogBoxes[DIALOG_CHAT];
	char onButton = dlg.OnButton();
	short sX = dlg.m_X;
	short sY = dlg.m_Y;

	if (m_stMCursor.sZ != 0 && dlg.IsTop())
	{
		dlg.sView = dlg.sView + m_stMCursor.sZ/*/30*/;
		////DIRECTX m_dInput.m_sZ = 0;//DIRECTX
	}
	if (dlg.sView < 0) dlg.sView = 0;
	if (dlg.sView > MAXCHATSCROLLMSGS - 8) dlg.sView = MAXCHATSCROLLMSGS - 8;

	//uncomment	ButtonStringToggle(dlg, 2, DRAW_CHAT1, m_chatToggle[CHAT_SHOUT]);
	//uncomment	ButtonStringToggle(dlg, 3, DRAW_CHAT2, m_chatToggle[CHAT_NATIONSHOUT]);
	//uncomment	ButtonStringToggle(dlg, 4, DRAW_CHAT3, m_chatToggle[CHAT_NORMAL]);
	//uncomment	ButtonStringToggle(dlg, 5, DRAW_CHAT4, m_chatToggle[CHAT_GUILD]);
	//uncomment	ButtonStringToggle(dlg, 6, DRAW_CHAT5, m_chatToggle[CHAT_PARTY]);
	//uncomment	ButtonStringToggle(dlg, 7, DRAW_CHAT6, m_chatToggle[CHAT_WHISPER]);
	//uncomment	ButtonStringToggle(dlg, 8, DRAW_CHAT7, m_chatToggle[CHAT_GM]);
	//uncomment	ButtonStringToggle(dlg, 9, DRAW_CHAT8);

	uint32_t chatsize = m_chatDisplay->size();

	if (dlg.sView >= chatsize)
		dlg.sView = (chatsize == 0) ? 0 : chatsize - 1;

	double d1 = (double)dlg.sView;
	double d2 = (double)(105);
	double d3 = (d1 * d2) / (MAXCHATSCROLLMSGS - 8);
	int iPointerLoc = (int)d3;
	iPointerLoc = 105 - iPointerLoc;
	DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX + 346, sY + 33 + iPointerLoc, 7);

	std::vector<CMsg *>::reverse_iterator it = m_chatDisplay->rbegin() + dlg.sView;

	for (int i = 0; i < 8; i++, ++it)
	{
		if (it == m_chatDisplay->rend())
			break;

		CMsg * msg = (*it);

		int32_t r = 0, g = 0, b = 0;
		switch (msg->m_dwTime)
		{
			case CHAT_NORMAL:
				r = 230; g = 230; b = 230;
				break;
			case CHAT_GUILD:
				r = 130; g = 200; b = 130;
				break;
			case CHAT_SHOUT:
				r = 255; g = 130; b = 130;
				break;
			case CHAT_NATIONSHOUT:
				r = 130; g = 130; b = 255;
				break;
			case CHAT_PARTY:
				r = 230; g = 230; b = 130;
				break;
			case CHAT_GM:
				r = 180; g = 255; b = 180;
				break;
			case CHAT_WHISPER:
				r = 150; g = 150; b = 170;
				break;
		}

		PutString(sX + 25, sY + 130 - i * 13, msg->m_pMsg, Color(255, r, g, b), false, 1);
	}


	if ((m_stMCursor.LB != 0) && dlg.IsTop())
	{
		if ((m_stMCursor.sX >= sX + 336) && (m_stMCursor.sX <= sX + 361) && (m_stMCursor.sY >= sY + 28) && (m_stMCursor.sY <= sY + 140))
		{
			d1 = (double)(m_stMCursor.sY - (sY + 28));
			d2 = ((MAXCHATSCROLLMSGS - 8) * d1) / 105.0f;
			dlg.sView = MAXCHATSCROLLMSGS - 8 - (int)d2;
		}

		if ((m_stMCursor.sX >= sX + 336) && (m_stMCursor.sX <= sX + 361) && (m_stMCursor.sY > sY + 18) && (m_stMCursor.sY < sY + 28))
			dlg.sView = MAXCHATSCROLLMSGS - 8;

		if ((m_stMCursor.sX >= sX + 336) && (m_stMCursor.sX <= sX + 361) && (m_stMCursor.sY > sY + 140) && (m_stMCursor.sY < sY + 163))
			dlg.sView = 0;
	}
	else dlg.bIsScrollSelected = false;

}

void helbreath::DlgBoxClick_Chat()
{
	ChatType t;

	switch (m_dialogBoxes[DIALOG_CHAT].OnButton())
	{
		case 2:
			t = CHAT_SHOUT;
			break;
		case 3:
			t = CHAT_NATIONSHOUT;
			break;
		case 4:
			t = CHAT_NORMAL;
			break;
		case 5:
			t = CHAT_GUILD;
			break;
		case 6:
			t = CHAT_PARTY;
			break;
		case 7:
			t = CHAT_WHISPER;
			break;
		case 8:
			t = CHAT_GM;
			break;
		case 9:
			for (int i = 0; i < CHAT_MAX; i++)
			{
				if (m_chatMsgs[i].size() > 0)
				{
					EnableChat((ChatType)i, true);
				}
				m_chatToggle[i] = true;
			}

			return;

		default:
			return;
	}

	EnableChat(t, !m_chatToggle[t]);
}

void helbreath::DlgBoxDoubleClick_Chat()
{
	ChatType t;

	switch (m_dialogBoxes[DIALOG_CHAT].OnButton())
	{
		case 2:
			t = CHAT_SHOUT;
			break;
		case 3:
			t = CHAT_NATIONSHOUT;
			break;
		case 4:
			t = CHAT_NORMAL;
			break;
		case 5:
			t = CHAT_GUILD;
			break;
		case 6:
			t = CHAT_PARTY;
			break;
		case 7:
			t = CHAT_WHISPER;
			break;
		case 8:
			t = CHAT_GM;
			break;
		case 9:
		default:
			return;
	}

	for (int i = 0; i < CHAT_MAX; i++)
	{
		if (m_chatToggle[i] && i != t)
		{
			EnableChat((ChatType)i, false);
		}
	}

	EnableChat(t, true);
}

void helbreath::EnableChat(ChatType t, bool enable)
{
	if ((enable == m_chatToggle[t]))
		return;

	m_chatToggle[t] = !m_chatToggle[t];

	if (m_chatMsgs[t].size() == 0)
		return;

	if (enable)
	{
		std::vector<CMsg *> * result = new std::vector<CMsg *>(m_chatDisplay->size() + m_chatMsgs[t].size());
		merge(m_chatDisplay->begin(), m_chatDisplay->end(),
			m_chatMsgs[t].begin(), m_chatMsgs[t].end(), result->begin(), &CMsg::OrderPred);

		delete m_chatDisplay;
		m_chatDisplay = result;
	}
	else
	{
		CMsg::SetPred(t);
		std::vector<CMsg *>::iterator remIt = remove_if(m_chatDisplay->begin(), m_chatDisplay->end(), CMsg::RemovePred);
		m_chatDisplay->erase(remIt, m_chatDisplay->end());
	}
}

void helbreath::DlgBoxClick_ItemUpgrade()
{
	int i, iSoX, iSoM;
	char onButton = m_dialogBoxes[34].OnButton();
	if (onButton) PlaySound('E', 14, 5);

	switch (m_dialogBoxes[34].GetMode())
	{
		case 1:	// Upgrade Majestic, items in the window
			if ((m_dialogBoxes[34].sV1 != -1) && onButton == 1)
			{
				int iValue = (m_pItemList[m_dialogBoxes[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
				iValue = iValue * (iValue + 6) / 8 + 2;
				if (m_iGizonItemUpgradeLeft < iValue) break;

				PlaySound('E', 44, 0);
				m_dialogBoxes[34].SetMode(2);
				m_dialogBoxes[34].dwV1 = unixtime();
			}
			else if (onButton == 2)
			{	// Cancel
				DisableDialogBox(34);
			}
			break;

		case 3: // Success
		case 4: // Not possible
		case 7: // Lost item
		case 8: // Failed
		case 9: // Failed
		case 10:// Failed
		case 12:// 12 Need stone!
			if (onButton == 1)
			{	// OK
				DisableDialogBox(34);
			}
			break;
		case 5: // main menu
			if (onButton == 1)
			{
				iSoX = iSoM = 0;
				for (i = 0; i < MAXITEMS; i++)
					if (m_pItemList[i] != 0)
					{
						if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 128)) iSoX++;
						if ((m_pItemList[i]->m_sSprite == 6) && (m_pItemList[i]->m_sSpriteFrame == 129)) iSoM++;
					}
				if ((iSoX > 0) || (iSoM > 0))
				{
					m_dialogBoxes[34].SetMode(6);
					m_dialogBoxes[34].sV2 = iSoX;
					m_dialogBoxes[34].sV3 = iSoM;
				}
				else AddEventList(DRAW_DIALOGBOX_ITEMUPGRADE30, 10); //"Stone of Xelima or Merien is not present."
			}
			else if (onButton == 2)
			{
				m_dialogBoxes[34].SetMode(1);
			}
			else if (onButton == 3)
			{	// Cancel
				DisableDialogBox(34);
			}
			else if (onButton == 4) // Upgrade Hero System xRisenx
			{
				m_dialogBoxes[34].SetMode(6);
			}
			break;
		case 6: // Upgrade Xelima / Merien
			if ((m_dialogBoxes[34].sV1 != -1) && onButton == 1)
			{	// Upgrade
				PlaySound('E', 44, 0);
				m_dialogBoxes[34].SetMode(2);
				m_dialogBoxes[34].dwV1 = unixtime();
			}
			if (onButton == 2)
			{	// Cancel
				DisableDialogBox(34);
			}
			break;

		case 13: // Upgrade Hero System xRisenx
			if ((m_dialogBoxes[34].sV1 != -1) && onButton == 1)
			{	// Upgrade
				PlaySound('E', 44, 0);
				m_dialogBoxes[34].SetMode(2);
				m_dialogBoxes[34].dwV1 = unixtime();
			}
			if (onButton == 2)
			{	// Cancel
				DisableDialogBox(34);
			}
			break;
	}
}


void helbreath::DlgBoxClick_SellList()
{
	int i, x;
	char onButton = m_dialogBoxes[31].OnButton();
	i = onButton - 1;

	if (onButton > 0 && onButton <= MAXSELLLIST)
	{
		if (m_pItemList[m_stSellItemList[i].iIndex] != 0)
		{
			m_bIsItemDisabled[m_stSellItemList[i].iIndex] = false;
			m_stSellItemList[i].iIndex = -1;

			PlaySound('E', 14, 5);

			for (x = 0; x < MAXSELLLIST - 1; x++)
				if (m_stSellItemList[x].iIndex == -1)
				{
					m_stSellItemList[x].iIndex = m_stSellItemList[x + 1].iIndex;
					m_stSellItemList[x].iAmount = m_stSellItemList[x + 1].iAmount;

					m_stSellItemList[x + 1].iIndex = -1;
					m_stSellItemList[x + 1].iAmount = 0;
				}
		}
		return;
	}

	if (onButton == MAXSELLLIST + 1) // Sell
	{
		bSendCommand(MSGID_REQUEST_SELLITEMLIST);
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}
	else if (onButton == MAXSELLLIST + 2) // Cancel
	{
		PlaySound('E', 14, 5);
		DisableDialogBox(31);
	}
}

void helbreath::DlgBoxClick_LevelUpSettings()
{
	short
		cStat = NONE;
	int statChange;

	short msY = m_stMCursor.sY;
	short msX = m_stMCursor.sX;
	short sY = m_dialogBoxes[12].m_Y;
	short sX = m_dialogBoxes[12].m_X;
	char onButton = m_dialogBoxes[12].OnButton();

	if (m_bCtrlPressed == true)	statChange = 10;
	else	statChange = 1;

	if (onButton == 3 || onButton == 4)
		cStat = STAT_STR;
	if (onButton == 5 || onButton == 6)
		cStat = STAT_VIT;
	if (onButton == 7 || onButton == 8)
		cStat = STAT_DEX;
	if (onButton == 9 || onButton == 10)
		cStat = STAT_INT;
	if (onButton == 11 || onButton == 12)
		cStat = STAT_MAG;
	if (onButton == 13 || onButton == 14)
		cStat = STAT_CHR;

	if (cStat != NONE && onButton % 2 == 1)
	{
		if (statChange > m_iLU_Point)
			statChange = m_iLU_Point;

		if (m_stat[cStat] - m_angelStat[cStat] + m_luStat[cStat] + statChange > Stats_Limit)
			//if(m_stat[cStat] - m_angelStat[cStat] + m_luStat[cStat] + statChange > 450)
				//statChange = Stats_Limit - (m_stat[cStat] - m_angelStat[cStat] + m_luStat[cStat]);
				//statChange = 450 - (m_stat[cStat] - m_angelStat[cStat] + m_luStat[cStat]);
			statChange = Stats_Limit - (m_stat[cStat] - m_angelStat[cStat] + m_luStat[cStat]);
		if (statChange < 0) statChange = 0;

		if (m_iLU_Point >= statChange)
			m_luStat[cStat] += statChange;
		else
		{
			statChange = m_luStat[cStat];
			m_luStat[cStat] = 0;
		}

		PlaySound('E', 14, 5);
		m_iLU_Point -= statChange;
	}

	if (cStat != NONE && onButton % 2 == 0)
	{
		if (statChange > m_luStat[cStat])
		{
			statChange = m_luStat[cStat];
			m_luStat[cStat] = 0;
		}
		else	m_luStat[cStat] -= statChange;

		PlaySound('E', 14, 5);
		m_iLU_Point += statChange;
	}

	if (onButton == 1)
	{
		if (m_dialogBoxes[12].sV1 != m_iLU_Point)
			// Send command to HG - Diuuude, Only if changed - Snoopy
			bSendCommand(MSGID_LEVELUPSETTINGS);
		//m_luStat[STAT_STR] = m_luStat[STAT_VIT] = m_luStat[STAT_DEX] = m_luStat[STAT_INT] = m_luStat[STAT_MAG] = m_luStat[STAT_CHR] = 0;
		DisableDialogBox(12);
		PlaySound('E', 14, 5);
	}
	else if (onButton == 2)
	{	// Change stats with Majestic
		if ((m_iGizonItemUpgradeLeft > 0) && (m_iLU_Point <= 0)
			&& (m_luStat[STAT_STR] == 0) && (m_luStat[STAT_VIT] == 0) && (m_luStat[STAT_DEX] == 0) && (m_luStat[STAT_INT] == 0) && (m_luStat[STAT_MAG] == 0) && (m_luStat[STAT_CHR] == 0))
		{
			DisableDialogBox(12);
			EnableDialogBox(42, 0, 0, 0);
			//PlaySound('E', 14, 5);
		}
	}
}

void helbreath::CannotConstruct(int iCode)
{
	switch (iCode)
	{
		case 1:
			SetTopMsg(CRUSADE_MESSAGE18, 5);
			break;

		case 2:
			fmt::format_to(G_cTxt, "%s XY(%d, %d)", CRUSADE_MESSAGE19, m_iConstructLocX, m_iConstructLocY);
			SetTopMsg(G_cTxt, 5);
			break;

		case 3:
			SetTopMsg(CRUSADE_MESSAGE20, 5);
			break;

		case 4:
			SetTopMsg(CRUSADE_MESSAGE20, 5);
			break;

		case 5:
			SetTopMsg(CRUSADE_MESSAGE20B, 5);
			break;
	}
}

void helbreath::DisplayCommaNumber_G_cTxt(int iGold)
{
	char cGold[20];
	int iStrLen;
	ZeroMemory(cGold, sizeof(cGold));
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	_itoa(iGold, cGold, 10);
#ifdef COMMA_GOLD
	iStrLen = strlen(cGold);
	iStrLen--;
	int cnt = 0;
	for (int i = 0; i < iStrLen + 1; i++)
	{
		if ((cnt != 0) && ((cnt + 1) % 4 == 0))
		{
			G_cTxt[cnt] = ',';
			i--;
		}
		else G_cTxt[cnt] = cGold[iStrLen - i];
		cnt++;
	}
	iStrLen = strlen(G_cTxt);
	G_cTxt[iStrLen] = '\0';
	_strrev(G_cTxt);
#else
	strcpy(G_cTxt, cGold);
#endif
}

void helbreath::DrawDialogBox_Inventory()
{
	int i;
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	uint32_t ItemColor;
	int uTotalItem = 0;
	char onButton = m_dialogBoxes[2].OnButton();
	sX = m_dialogBoxes[2].m_X;
	sY = m_dialogBoxes[2].m_Y;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_INVENTORY, sX, sY, 0);
	for (i = 0; i < MAXITEMS; i++)
		if ((m_cItemOrder[i] != -1) && (m_pItemList[m_cItemOrder[i]] != 0))
		{
			uTotalItem++; // Added Current/Max xRisenx
			if (((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_ITEM) && (m_stMCursor.sSelectedObjectID == m_cItemOrder[i])) || (m_bIsItemEquipped[m_cItemOrder[i]] == true))
			{

			}
			else
			{
				ItemColor = m_pItemList[m_cItemOrder[i]]->m_ItemColor;
				if (m_bIsItemDisabled[m_cItemOrder[i]] == true)
				{
					if (ItemColor == 0)
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSprite2(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
							sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
					else
					{
						if ((m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_LHAND)
							|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_RHAND)
							|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_TWOHAND))
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
								sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
								ItemColor,
								dwTime);
						}
						else
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutTransSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
								sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
								ItemColor,
								dwTime);
						}
					}
				}
				else
				{
					if (ItemColor == 0)
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteFast(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
							sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame, dwTime);
					else
					{
						if ((m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_LHAND)
							|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_RHAND)
							|| (m_pItemList[m_cItemOrder[i]]->m_cEquipPos == EQUIPPOS_TWOHAND))
						{

							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
								sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
								ItemColor,
								dwTime);
						}
						else
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_cItemOrder[i]]->m_sSprite]->PutSpriteRGB(sX + 32 + m_pItemList[m_cItemOrder[i]]->m_sX,
								sY + 44 + m_pItemList[m_cItemOrder[i]]->m_sY, m_pItemList[m_cItemOrder[i]]->m_sSpriteFrame,
								ItemColor,
								dwTime);
						}
					}
				}
				if ((m_pItemList[m_cItemOrder[i]]->m_cItemType == ITEMTYPE_CONSUME)
					|| (m_pItemList[m_cItemOrder[i]]->m_cItemType == ITEMTYPE_ARROW))
				{
					DisplayCommaNumber_G_cTxt((int)m_pItemList[m_cItemOrder[i]]->m_dwCount); // nbe show, as US: 1,200,000
					PutString2(sX + 29 + m_pItemList[m_cItemOrder[i]]->m_sX + 10, sY + 41 + m_pItemList[m_cItemOrder[i]]->m_sY + 10, G_cTxt, 200, 200, 200);
				}
			}
		}
	if (onButton == 1)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_INVENTORY, sX + 23, sY + 172, 1);
	}
	else if (onButton == 2)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_INVENTORY, sX + 140, sY + 172, 2);
	}

	fmt::format_to(G_cTxt, "%d/%d", uTotalItem, MAXITEMS);
	PutString2(sX + 102, sY + 174, G_cTxt, 200, 200, 200);
}


void helbreath::CrusadeContributionResult(int iWarContribution)
{
	int i;
	char cTemp[120];
	DisableDialogBox(18);
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}
	if (iWarContribution > 0)
	{
		PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE22, 0);
		m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE23, 0);
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, CRUSADE_MESSAGE24, 0);
		m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE25, 0);
		m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE26, 0);
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE27, 0);
		m_pMsgTextList[8] = new class CMsg(0, " ", 0);
		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "You Gained %dExp Points!", iWarContribution * 35);
		m_pMsgTextList[9] = new class CMsg(0, cTemp, 0);
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);

	}
	else if (iWarContribution < 0)
	{
		PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE28, 0);
		m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE29, 0);
		m_pMsgTextList[2] = new class CMsg(0, " ", 0);
		m_pMsgTextList[3] = new class CMsg(0, CRUSADE_MESSAGE30, 0);
		m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE31, 0);
		m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE32, 0);
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE33, 0);
		m_pMsgTextList[8] = new class CMsg(0, CRUSADE_MESSAGE34, 0);
		for (i = 9; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else if (iWarContribution == 0)
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE50, 0); // The battle that you have participated
		m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE51, 0); // is already finished;
		m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE52, 0); //
		m_pMsgTextList[3] = new class CMsg(0, " ", 0);
		m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE53, 0); // You must connect after finishing
		m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE54, 0); // the previous and before starting
		m_pMsgTextList[6] = new class CMsg(0, CRUSADE_MESSAGE55, 0); // the next battle so you can receive
		m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE56, 0); // the prize
		for (i = 8; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	EnableDialogBox(18);
}


void helbreath::CrusadeWarResult(int iWinnerSide)
{
	int i;

	DisableDialogBox(18);
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	if (m_side == 0)
	{
		switch (iWinnerSide)
		{
			case 0:
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
				m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE36, 0); // There was a draw in the
				m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE37, 0); // battle
				m_pMsgTextList[3] = new class CMsg(0, " ", 0);
				break;
			case 1:
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
				m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE38, 0); // Aresden was victorious
				m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE39, 0); // and put an end to the war
				m_pMsgTextList[3] = new class CMsg(0, " ", 0);
				break;
			case 2:
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
				m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE40, 0); // Elvine was victorious
				m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE41, 0); // and put an end to the war
				m_pMsgTextList[3] = new class CMsg(0, " ", 0);
				break;
		}
		for (i = 4; i < 18; i++)
			m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (iWinnerSide == 0)
		{
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
			m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE36, 0); // There was a draw in the
			m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE37, 0); // battle
			m_pMsgTextList[3] = new class CMsg(0, " ", 0);
			for (i = 4; i < 18; i++)
				m_pMsgTextList[i] = new class CMsg(0, " ", 0);
		}
		else
		{
			if (iWinnerSide == m_side)
			{
				PlaySound('E', 23, 0, 0);
				PlaySound('C', 21, 0, 0);
				PlaySound('C', 22, 0, 0);
				switch (iWinnerSide)
				{
					case 1:
						m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!;
						m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE38, 0); // Aresden was victorious;
						m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE39, 0); // and put an end to the war
						m_pMsgTextList[3] = new class CMsg(0, " ", 0);
						m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE42, 0); // Congratulations!
						m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE43, 0); // As a victorious citizen
						m_pMsgTextList[6] = new class CMsg(0, CRUSADE_MESSAGE44, 0); // You will receive
						m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE45, 0); // a prize
						break;
					case 2:
						m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
						m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE40, 0); // Elvine was victorious
						m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE41, 0); // and put an end to the war
						m_pMsgTextList[3] = new class CMsg(0, " ", 0);
						m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE42, 0); // Congratulations!
						m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE43, 0); // As a victorious citizen
						m_pMsgTextList[6] = new class CMsg(0, CRUSADE_MESSAGE44, 0); // You will receive
						m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE45, 0); // a prize
						break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if (iWinnerSide != m_side)
			{
				PlaySound('E', 24, 0, 0);
				PlaySound('C', 12, 0, 0);
				PlaySound('C', 13, 0, 0);
				switch (iWinnerSide)
				{
					case 1:
						m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
						m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE38, 0); // Aresden was victorious;
						m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE39, 0); // and put an end to the war
						m_pMsgTextList[3] = new class CMsg(0, " ", 0);
						m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE46, 0); // Unfortunately,
						m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE47, 0); // As a losser citizen
						m_pMsgTextList[6] = new class CMsg(0, CRUSADE_MESSAGE48, 0); // the prize that accomplishes
						m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE49, 0); // will not be given.
						break;
					case 2:
						m_pMsgTextList[0] = new class CMsg(0, CRUSADE_MESSAGE35, 0); // All out war finished!
						m_pMsgTextList[1] = new class CMsg(0, CRUSADE_MESSAGE40, 0); // Elvine was victorious
						m_pMsgTextList[2] = new class CMsg(0, CRUSADE_MESSAGE41, 0); // and put an end to the war
						m_pMsgTextList[3] = new class CMsg(0, " ", 0);
						m_pMsgTextList[4] = new class CMsg(0, CRUSADE_MESSAGE46, 0); // Unfortunately,
						m_pMsgTextList[5] = new class CMsg(0, CRUSADE_MESSAGE47, 0); // As a losser citizen
						m_pMsgTextList[6] = new class CMsg(0, CRUSADE_MESSAGE48, 0); // the prize that accomplishes
						m_pMsgTextList[7] = new class CMsg(0, CRUSADE_MESSAGE49, 0); // will not be given.
						break;
				}
				for (i = 8; i < 18; i++)
					m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
		}
	}
	EnableDialogBox(18);
	DisableDialogBox(36);
	DisableDialogBox(37);
	DisableDialogBox(38);
}

void helbreath::_Draw_UpdateScreen_OnCreateNewAccount()
{
	//DIRECTX m_DDraw.ClearBackB4();
	DrawNewDialogBox(SPRID_INTERFACE_ND_NEWACCOUNT, 0, 0, 0, true);
	PutString2((800 / 2) - 80, (600 / 2) - 120, m_cAccountName, 200, 200, 200);
	PutString((800 / 2) - 80, (600 / 2) - 120 + 20, m_cAccountPassword, Color(255, 200, 200, 200), true, 1);
	PutString((800 / 2) - 80, (600 / 2) - 120 + 20 * 2, m_cAccountPassword, Color(255, 200, 200, 200), true, 1);
	PutString2((800 / 2) - 80, (600 / 2) - 120 + 20 * 3, m_cAccountCountry, 200, 200, 200);
	PutString2((800 / 2) - 80, (600 / 2) - 120 + 20 * 4, m_cAccountSSN, 200, 200, 200);
	PutString2((800 / 2) - 80, (600 / 2) - 120 + 20 * 5, m_cEmailAddr, 200, 200, 200);
	/*//DIRECTX m_DDraw.ClearBackB4();
	DrawNewDialogBox(SPRID_INTERFACE_ND_NEWACCOUNT, 0,0,0, TRUE);
	PutString2(329, 110, m_cAccountName, 200,200,200);
	PutString( 329, 125, m_cAccountPassword,Color(255,200,200,200), TRUE, 1);
	PutString( 329, 140, m_cAccountPassword,Color(255,200,200,200), TRUE, 1);
	PutString2(300, 202, m_cAccountCountry, 200,200,200);
	PutString2(300, 218, m_cAccountSSN, 200,200,200);
	PutString2(194, 257, m_cEmailAddr, 200,200,200);*/
}

void helbreath::DrawChatMsgBox(short sX, short sY, int iChatIndex, bool bIsPreDC)
{
	char cMsg[200], cMsgA[22], cMsgB[22], cMsgC[22], * cp;
	int  iRet, iLines, i, iSize, iSize2, iLoc, iFontSize;
	uint64_t dwTime;
	Color rgb;
	bool bIsTrans;
	RECT rcRect;
	SIZE Size;

	ZeroMemory(cMsg, sizeof(cMsg));
	ZeroMemory(cMsgA, sizeof(cMsgA));
	ZeroMemory(cMsgB, sizeof(cMsgB));
	ZeroMemory(cMsgC, sizeof(cMsgC));

	if (iChatIndex >= MAXCHATMSGS)
	{
#ifdef _DEBUG
		MessageBoxA(0, "check _tmp_cName (must be a buffer overflow)", "ASSERTION FAILED", MB_OK);
#else
		return;
#endif
	}

	dwTime = m_pChatMsgList[iChatIndex]->m_dwTime;
	strncpy(cMsg, m_pChatMsgList[iChatIndex]->m_pMsg, sizeof(cMsg) - 1);
	cp = (char *)cMsg;
	iLines = 0;

	rgb = Color(255, 255, 255, 255);
	switch (m_pChatMsgList[iChatIndex]->m_cType)
	{
		case 1:
			rgb = Color(255, 255, 255, 255);
			break;
		case 20:
			rgb = Color(255, 255, 255, 20);
			if ((m_dwCurTime - dwTime) < 650) return;
			else dwTime += 650;
			break;
		case 41:
			rgb = Color(255, 255, 80, 80);
			break;

		case 42:
			rgb = Color(255, 255, 80, 80);
			if ((m_dwCurTime - dwTime) < 650) return;
			else dwTime += 650;
			break;
	}

	if (strlen(cp) != 0)
	{
		memcpy(cMsgA, cp, 20);

		iRet = GetCharKind(cMsgA, 19);
		if (iRet == CODE_HAN1)
		{
			cMsgA[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 1;
	}

	if (strlen(cp) != 0)
	{
		memcpy(cMsgB, cp, 20);

		iRet = GetCharKind(cMsgB, 19);
		if (iRet == CODE_HAN1)
		{
			cMsgB[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 2;
	}

	if (strlen(cp) != 0)
	{
		memcpy(cMsgC, cp, 20);

		iRet = GetCharKind(cMsgC, 19);
		if (iRet == CODE_HAN1)
		{
			cMsgC[20] = cp[20];
			cp++;
		}
		cp += 20;
		iLines = 3;
	}

	iSize = 0;
	for (i = 0; i < 20; i++)
		if (cMsgA[i] != 0)

			if ((unsigned char)cMsgA[i] >= 128)
			{
				iSize += 5;	//6
				i++;
			}
			else iSize += 4;

	iLoc = m_dwCurTime - dwTime;
	switch (m_pChatMsgList[iChatIndex]->m_cType)
	{
		case 21:
		case 22:
		case 23://...
			if (iLoc > 80) iLoc = 10;
			else iLoc = iLoc >> 3;
			break;
		default://
			if (iLoc > 352) iLoc = 9;
			else if (iLoc > 320) iLoc = 10;
			else iLoc = iLoc >> 5;
			break;
	}

	if (m_cDetailLevel == 0)
		bIsTrans = false;
	else bIsTrans = true;

	switch (m_pChatMsgList[iChatIndex]->m_cType)
	{
		case 41:
		case 42:
			iSize2 = 0;
			for (i = 0; i < 100; i++)
				if (cMsg[i] != 0)
					if ((unsigned char)cMsg[i] >= 128)
					{
						iSize2 += 5;
						i++;
					}
					else iSize2 += 4;
			if (m_Misc.bCheckIMEString(cMsg) == false)
			{
				PutString3(sX - iSize2, sY - 65 - iLoc, cMsg, Color(255, 180, 30, 30));
			}
			else PutString_SprFont3(sX - iSize2, sY - 65 - iLoc, cMsg, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, false, 0);
			break;

		case 21:
		case 22:
		case 23:
			iFontSize = 23 - (int)m_pChatMsgList[iChatIndex]->m_cType;
			switch (iLines)
			{
				case 1:
					PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgA, 255, 255, 0, bIsTrans, iFontSize);
					break;
				case 2:
					PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgA, 255, 255, 0, bIsTrans, iFontSize);
					PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgB, 255, 255, 0, bIsTrans, iFontSize);
					break;
				case 3:
					PutString_SprFont3(sX - iSize, sY - 97 - iLoc, cMsgA, 255, 255, 0, bIsTrans, iFontSize);
					PutString_SprFont3(sX - iSize, sY - 81 - iLoc, cMsgB, 255, 255, 0, bIsTrans, iFontSize);
					PutString_SprFont3(sX - iSize, sY - 65 - iLoc, cMsgC, 255, 255, 0, bIsTrans, iFontSize);
					break;
			}
			break;

		case 20:
		default:
			//if (bIsPreDC == FALSE)
				//DIRECTX m_DDraw._GetBackBufferDC();

			//GetTextExtentPoint32(//DIRECTX m_DDraw.m_hDC, cMsg, strlen(cMsg), &Size);

	// 		switch (Size.cx / 160) {
	// 		case 0:
			PutChatString(sX - 80 + 1, sY - 65 - iLoc, (char *)cMsg, Color(255, 0, 0, 0));
			//SetRect(&rcRect, sX - 80 + 1, sY - 65 - iLoc, sX + 80 + 1, sY - iLoc);
			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));

			PutChatString(sX - 80, sY - 65 - iLoc + 1, (char *)cMsg, Color(255, 0, 0, 0));
			//SetRect(&rcRect, sX-80, sY-65 -iLoc +1, sX+80, sY -iLoc +1);
			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));

			PutChatString(sX - 80, sY - 65 - iLoc, (char *)cMsg, rgb);
			//SetRect(&rcRect, sX-80, sY-65 -iLoc, sX+80, sY -iLoc);
			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg, rgb);
// 			break;
// 
// 		case 1:
// 			//SetRect(&rcRect, sX-80 +1, sY-83 -iLoc, sX+80 +1, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-83 -iLoc +1, sX+80, sY -iLoc +1);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-83 -iLoc, sX+80, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg, rgb);
// 			break;
// 
// 		case 2:
// 			//SetRect(&rcRect, sX-80 +1, sY-101 -iLoc, sX+80 +1, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-101 -iLoc +1, sX+80, sY -iLoc +1);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-101 -iLoc, sX+80, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg, rgb);
// 			break;
// 
// 		case 3:
// 			//SetRect(&rcRect, sX-80 +1, sY-119 -iLoc, sX+80 +1, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-119 -iLoc +1, sX+80, sY -iLoc +1);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg,Color(255,0,0,0));
// 
// 			//SetRect(&rcRect, sX-80, sY-119 -iLoc, sX+80, sY -iLoc);
// 			//DIRECTX m_DDraw.DrawText(&rcRect, cMsg, rgb);
// 			break;
// 		}

		//if (bIsPreDC == FALSE)
			//DIRECTX m_DDraw._ReleaseBackBufferDC();
			break;
	}
}

void helbreath::ClearContents_OnSelectCharacter()
{
	m_cCurFocus = 1;
}



bool helbreath::DlgBoxPress_Character()
{
	int i;
	short sX, sY, sSprH, sFrame;
	char cEquipPoiStatus[MAXITEMEQUIPPOS];

	if (m_bIsDialogEnabled[17] == true) return false;

	short msX = m_stMCursor.sX;
	short msY = m_stMCursor.sY;
	sX = m_dialogBoxes[1].m_X;
	sY = m_dialogBoxes[1].m_Y;
	for (i = 0; i < MAXITEMEQUIPPOS; i++) cEquipPoiStatus[i] = -1;
	for (i = 0; i < MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}

	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 100, sY + 185, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 41, sY + 137, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_HEAD];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_RFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 100, sY + 185, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_LFINGER];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_NECK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_TWOHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_RHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_LHAND];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_FULLBODY];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BOOTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_ARMS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_PANTS];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY))
			{
				m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
				m_stMCursor.sSelectedObjectID = m_sItemEquipmentStatus[EQUIPPOS_BACK];
				m_stMCursor.sDistX = 0;
				m_stMCursor.sDistY = 0;
				return true;
			}
		}
	}
	return false;
}

void helbreath::DlgBoxClick_CityhallMenu()
{
	enum modes
	{
		LEGIONPTSSERVICES = 9,
		TELEPORTLIST = 10
	};
	short sX, sY;
	int i;
	sX = m_dialogBoxes[13].m_X;
	sY = m_dialogBoxes[13].m_Y;
	short szX = m_dialogBoxes[13].sSizeX;
	char onButton = m_dialogBoxes[13].OnButton();
	switch (m_dialogBoxes[13].GetMode())
	{
		case 0:
			switch (onButton)
			{
				case 1:
					if (m_side != NEUTRAL) return;
					m_dialogBoxes[13].SetMode(1); // citizenship rq
					break;
				case 2:
					if (m_iRewardGold <= 0) return;
					m_dialogBoxes[13].SetMode(5); // rq reward gold
					break;
				case 3:
					if (m_iEnemyKillCount < 100) return;
					m_dialogBoxes[13].SetMode(7);
					break;
				case 4:
					if (m_stQuest.bIsQuestCompleted) return;
					if (m_stQuest.sQuestType == 0) return;
					m_dialogBoxes[13].SetMode(8);
					break;
				case 5: // Fantasy point services
					m_dialogBoxes[13].SetMode(LEGIONPTSSERVICES);
					bSendCommand(MSGID_REQUEST_LGNPTS, 0, 0, 0, 0, 0, 0);
					break;
				case 6: // Teleport List
					m_dialogBoxes[13].SetMode(TELEPORTLIST);
					bSendCommand(MSGID_REQUEST_TELEPORT_LIST, 0, 0, 0, 0, 0, "William");
					break;
				case 7: // Quest List
					bSendCommand(MSGID_REQUEST_QUEST_LIST, 0, 0, 0, 0, 0, "William");
					EnableDialogBox(61);
					break;
				case 8: // Change Part in Crusade
					if (m_bIsCrusadeMode == false) return;
					EnableDialogBox(33, 1, 0, 0);
					break;
			}
			if (onButton) PlaySound('E', 14, 5);
			break;

		case 1:
			if (onButton == 1)
			{	// Yes Click
				bSendCommand(MSGID_REQUEST_CIVILRIGHT, MSGTYPE_CONFIRM, 0, 0, 0, 0, 0);
				m_dialogBoxes[13].SetMode(2);
			}
			else if (onButton == 2)
			{	// No Click
				m_dialogBoxes[13].SetMode(0);
			}
			if (onButton) PlaySound('E', 14, 5);
			break;

		case 3:	//
		case 4:
			if (onButton == 1)
			{
				// No Click
				m_dialogBoxes[13].SetMode(0);
				PlaySound('E', 14, 5);
			}
			break;

		case 5:
			if (onButton == 1)
			{
				// Yes
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_GETREWARDMONEY, 0, 0, 0, 0, 0);
				m_dialogBoxes[13].SetMode(0);
			}
			else if (onButton == 2)
			{
				// No
				m_dialogBoxes[13].SetMode(0);
			}
			if (onButton) PlaySound('E', 14, 5);
			break;

			// 3.51 Cityhall Menu - Request Hero's Items - Diuuude - fix by Drajwer
		case 7:
			int iReqHeroItemID;
			if (onButton)
			{
				ZeroMemory(m_cTakeHeroItemName, sizeof(m_cTakeHeroItemName));
				m_dialogBoxes[13].SetMode(11);
				PlaySound('E', 14, 5);
			}

			switch (onButton)
			{
				case 1: // Hero's Cape
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU47, strlen(DRAW_DIALOGBOX_CITYHALL_MENU47));
					m_dialogBoxes[13].sV1 = HR_CAPE;
					break;
				case 2:// Hero's Helm
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU48, strlen(DRAW_DIALOGBOX_CITYHALL_MENU48));
					m_dialogBoxes[13].sV1 = HR_HELM;
					break;
				case 3:// Hero's Cap
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU49, strlen(DRAW_DIALOGBOX_CITYHALL_MENU49));
					m_dialogBoxes[13].sV1 = HR_CAP;
					break;
				case 4:// Hero's Armor
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU50, strlen(DRAW_DIALOGBOX_CITYHALL_MENU50));
					m_dialogBoxes[13].sV1 = HR_PLATE;
					break;
				case 5:	// Hero's Robe
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU51, strlen(DRAW_DIALOGBOX_CITYHALL_MENU51));
					m_dialogBoxes[13].sV1 = HR_ROBE;
					break;
				case 6:	// Hero's Hauberk
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU52, strlen(DRAW_DIALOGBOX_CITYHALL_MENU52));
					m_dialogBoxes[13].sV1 = HR_HAUBERK;
					break;
				case 7: // Hero's Leggings
					memcpy(m_cTakeHeroItemName, DRAW_DIALOGBOX_CITYHALL_MENU53, strlen(DRAW_DIALOGBOX_CITYHALL_MENU53));
					m_dialogBoxes[13].sV1 = HR_LEGGINGS;
			}

			break;

		case 8:
			if (onButton == 1)
			{ // Yes
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_CANCELQUEST, 0, 0, 0, 0, 0);
			}

			if (onButton)
			{ //Either button
				m_dialogBoxes[13].SetMode(0);
				PlaySound('E', 14, 5);
			}
			break;

		case LEGIONPTSSERVICES:
			if (onButton == 1)
			{
				PlaySound('E', 14, 5);
				bSendCommand(MSGID_REQUEST_LGNPTS, 0, 0, 0, 0, 0, 0);
				break;
			}

			i = onButton - 2;
			if (onButton >= 2)
			{
				uint16_t cmd = lgnPtsSvcs[i + m_dialogBoxes[13].sView].cmd;

				if (cmd >= CMD_LGNSVC_TRADETOKEN1 && cmd <= CMD_LGNSVC_TRADETOKEN100)
				{
					if (GetItemCount("XtremeTokens") >= lgnPtsSvcs[i + m_dialogBoxes[13].sView].price
						|| GetItemCount("XtremeDonateTokens") >= lgnPtsSvcs[i + m_dialogBoxes[13].sView].price)
					{
						bSendCommand(MSGID_REQUEST_LGNSVC, cmd, 0, 0, 0, 0, 0);
						m_cash += lgnPtsSvcs[i + m_dialogBoxes[13].sView].price;
					}
					else
					{
						AddEventList(MSG_NOTIFY_LEGIONPT4, CHAT_GM, true);
					}
				}
				else if (cmd >= CMD_LGNSVC_TRADESCAN && cmd <= CMD_LGNSVC_TRADEBSW)
				{
					int32_t spellid = -1;

					switch (cmd)
					{
						case CMD_LGNSVC_TRADESCAN:
							spellid = 67;
							break;
						case CMD_LGNSVC_TRADEMAGICSHIELD:
							spellid = 84;
							break;
						case CMD_LGNSVC_TRADEICESTORM:
							spellid = 55;
							break;
						case CMD_LGNSVC_TRADEMASSHEAL:
							spellid = 85;
							break;
						case CMD_LGNSVC_TRADESOTG:
							spellid = 87;
							break;
						case CMD_LGNSVC_TRADECOTG:
							spellid = 92;
							break;
						case CMD_LGNSVC_TRADELC:
							spellid = 88;
							break;
						case CMD_LGNSVC_TRADEMB:
							spellid = 98;
							break;
						case CMD_LGNSVC_TRADEFSW:
							spellid = 97;
							break;
						case CMD_LGNSVC_TRADEBSW:
							spellid = 70;
							break;
					}

					if (spellid != -1 && m_cMagicMastery[spellid])
					{
						bSendCommand(MSGID_REQUEST_LGNSVC, cmd, 0, 0, 0, 0, 0);
						m_cash -= lgnPtsSvcs[i + m_dialogBoxes[13].sView].price;
					}
					else
					{
						AddEventList(MSG_NOTIFY_LEGIONPT5, CHAT_GM, true);
					}
				}
				else
				{
					if (m_cash >= lgnPtsSvcs[i + m_dialogBoxes[13].sView].price)
					{
						bSendCommand(MSGID_REQUEST_LGNSVC, cmd, 0, 0, 0, 0, 0);
						m_cash -= lgnPtsSvcs[i + m_dialogBoxes[13].sView].price;
					}
					else
					{
						AddEventList(MSG_NOTIFY_LEGIONPT1, CHAT_GM, true);
						AddEventList(MSG_NOTIFY_LEGIONPT2, CHAT_GM, true);
						AddEventList(MSG_NOTIFY_LEGIONPT3, CHAT_GM, true);
					}
				}
			}
			break;

		case TELEPORTLIST:
			if (m_iTeleportMapCount > 0)
			{
				i = onButton - 1;
				if (onButton)
				{
					bSendCommand(MSGID_REQUEST_CHARGED_TELEPORT, 0, 0, m_stTeleportList[i].iIndex, 0, 0, 0);
					DisableDialogBox(51);
					return;
				}
			}
			break;

		case 11: // Hero confirm
			if (onButton == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_GETHEROMANTLE, 0, m_dialogBoxes[13].sV1, 0, 0, 0);
				m_dialogBoxes[13].SetMode(0);
			}
			else if (onButton == 2)
			{
				m_dialogBoxes[13].SetMode(7);
			}
			if (onButton) PlaySound('E', 14, 5);
			break;
	}
}

void helbreath::CivilRightAdmissionHandler(char * pData)
{
	uint16_t * wp, wResult;
	char * cp;

	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	wResult = *wp;

	switch (wResult)
	{
		case 0:
			m_dialogBoxes[13].SetMode(4);
			break;

		case 1:
			m_dialogBoxes[13].SetMode(3);
			cp = (char *)(pData + INDEX2_MSGTYPE + 2);
			ZeroMemory(m_cLocation, sizeof(m_cLocation));
			memcpy(m_cLocation, cp, 10);

			if (memcmp(m_cLocation, "are", 3) == 0)
				m_side = ARESDEN;
			else if (memcmp(m_cLocation, "elv", 3) == 0)
				m_side = ELVINE;
			else if (memcmp(m_cLocation, "ist", 3) == 0)
				m_side = ISTRIA;
			else
				m_side = NEUTRAL;
			break;
	}
}

void helbreath::DlgBoxClick_Text()
{
	if (m_dialogBoxes[18].OnButton() == 1)
	{
		DisableDialogBox(18);
		PlaySound('E', 14, 5);
	}
}

void helbreath::DlgBoxClick_Inventory()
{
	int i;
	char onButton = m_dialogBoxes[2].OnButton();

	if (onButton == 1)
	{
		if (m_iGizonItemUpgradeLeft == 0)
		{
			m_iGizonItemUpgradeLeft = 0;
		}
		EnableDialogBox(34, 5, 0, 0);
		PlaySound('E', 14, 5);
	}
	else if (onButton == 2)
	{
		//{	if (m_cSkillMastery[SKILL_MANUFACTURING] == 0)
		//	{	AddEventList(DLGBOXCLICK_INVENTORY1, 10);
		//		AddEventList(DLGBOXCLICK_INVENTORY2, 10);//"The manufacturing manual is purchasable in Blacksmith."
		//	}else 
		if (m_bSkillUsingStatus == true)
		{
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY5, 10);//""You are already using another skill."
			return;
		}
		else if (_bIsItemOnHand() == true)
		{
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY4, 10);//""Your hands should be free to use this item."
			return;
		}
		else
		{
			for (i = 0; i < MAXITEMS; i++)
				if ((m_pItemList[i] != 0) && (m_pItemList[i]->m_cItemType == ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX)
					&& (m_pItemList[i]->m_sSpriteFrame == 113)
					&& (m_pItemList[i]->m_wCurLifeSpan > 0))
				{
					EnableDialogBox(26, 3, 0, 0, 0);
					AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY12, 10);//"Using a manufacturing skill..."
					PlaySound('E', 14, 5);
					return;
				}
			AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY14, 10);
		}
		PlaySound('E', 14, 5);
	}
}

void helbreath::DlgBoxClick_Character()
{
	char onButton = m_dialogBoxes[1].OnButton();

	if (onButton == 1)
	{
		EnableDialogBox(28, 1, 0, 0);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if (onButton == 2)
	{
		EnableDialogBox(32, 0, 0, 0);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
	else if (onButton == 3)
	{
		EnableDialogBox(12, 0, 0, 0);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);

	}
	else if (onButton == 4)
	{
		if (m_iGuildRank != GUILDRANK_NONE)
		{
			EnableDialogBox(57, 0, 0, 0);
			DisableDialogBox(1);
			PlaySound('E', 14, 5);
		}
		else
		{
			fmt::format_to(G_cTxt, GUILD_ERROR1);
			AddEventList(G_cTxt, 10);
		}
	}
#ifdef TitleClient
	else if (onButton == 5)
	{
		EnableDialogBox(63, 0, 0, 0);
		DisableDialogBox(1);
		PlaySound('E', 14, 5);
	}
#endif
}

void helbreath::DlgBoxClick_FeedBackCard()
{

}

void helbreath::DlgBoxClick_MagicShop()
{

	int i, j, iCPivot;

	iCPivot = m_dialogBoxes[16].sView * 10;

	char onButton = m_dialogBoxes[16].OnButton();
	for (i = 0, j = 0; i < 9; i++)
	{
		if ((m_pMagicCfgList[iCPivot + i] != 0) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible))
		{
			if (onButton == ++j)
			{
				if (m_cMagicMastery[iCPivot + i] == 0)
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_STUDYMAGIC, 0, 0, 0, 0, m_pMagicCfgList[iCPivot + i]->m_cName);
					//bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_STUDYMAGIC, NULL, iCPivot + i, NULL, NULL, NULL);
					PlaySound('E', 14, 5);
				}
				return;
			}
		}
	}
	if (onButton == 10)
	{
		m_dialogBoxes[16].SetMode(1);
		PlaySound('E', 14, 5);
		return;
	}
	else if (onButton == 11)	m_dialogBoxes[16].sView = 0;
	else if (onButton == 12)	m_dialogBoxes[16].sView = 1;
	else if (onButton == 13)	m_dialogBoxes[16].sView = 2;
	else if (onButton == 14)	m_dialogBoxes[16].sView = 3;
	else if (onButton == 15)	m_dialogBoxes[16].sView = 4;
	else if (onButton == 16)	m_dialogBoxes[16].sView = 5;
	else if (onButton == 17)	m_dialogBoxes[16].sView = 6;
	else if (onButton == 18)	m_dialogBoxes[16].sView = 7;
	else if (onButton == 19)	m_dialogBoxes[16].sView = 8;
	else if (onButton == 20)	m_dialogBoxes[16].sView = 9;
}

void helbreath::_RemoveChatMsgListByObjectID(int iObjectID)
{
	int i;

	for (i = 1; i < MAXCHATMSGS; i++)
		if ((m_pChatMsgList[i] != 0) && (m_pChatMsgList[i]->m_iObjectID == iObjectID))
		{
			delete m_pChatMsgList[i];
			m_pChatMsgList[i] = 0;
		}
}

void helbreath::PlaySound(char cType, int iNum, int iDist, long lPan)
{
	int iVol;

	if (m_bSoundFlag == false) return;
	if (m_bSoundStat == false) return;

	if (iDist > 10) iDist = 10;

	iVol = (m_cSoundVolume - 100) * 30;
	iVol += -200 * iDist;

	if (iVol > 0) iVol = 0;
	if (iVol < -10000) iVol = -10000;

	// 		switch (cType) {
	// 		case 'C':
	// 			if (m_pCSound[iNum] == NULL) return;
	// 			m_pCSound[iNum]->Play(FALSE, lPan, iVol);
	// 			break;
	// 
	// 		case 'M':
	// 			if (m_pMSound[iNum] == NULL) return;
	// 			m_pMSound[iNum]->Play(FALSE, lPan, iVol);
	// 			break;
	// 
	// 		case 'E':
	// 			if (m_pESound[iNum] == NULL) return;
	// 			m_pESound[iNum]->Play(FALSE, lPan, iVol);
	// 			break;
	// 		}
}

void helbreath::_DrawBlackRect(int iSize)
{
	int ix, iy, sx, sy, dcx, dcy;
	uint64_t dwTime;

	dwTime = unixtime();

	dcx = 40 - iSize * 2;
	dcy = 30 - iSize * 2;

	sx = iSize * 16;
	sy = iSize * 16;

	for (ix = 0; ix < dcx; ix++)
	{
		m_pSprite[SPRID_MOUSECURSOR]->PutSpriteFast(ix * 16 + sx, iSize * 16, 12, dwTime);
		m_pSprite[SPRID_MOUSECURSOR]->PutSpriteFast(ix * 16 + sx, 464 - iSize * 16, 12, dwTime);
	}

	for (iy = 0; iy < dcy; iy++)
	{
		m_pSprite[SPRID_MOUSECURSOR]->PutSpriteFast(iSize * 16, iy * 16 + sy, 12, dwTime);
		m_pSprite[SPRID_MOUSECURSOR]->PutSpriteFast(624 - iSize * 16, iy * 16 + sy, 12, dwTime);
	}
}

bool helbreath::_bCheckItemByType(char cType)
{
	int i;

	for (i = 0; i < MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_pItemList[i]->m_cItemType == cType)) return true;

	return false;
}


void helbreath::DynamicObjectHandler(char * pData)
{
	uint16_t * wp;
	char * cp;
	short * sp, sX, sY, sV1, sV2, sV3;

	cp = (char *)(pData + INDEX2_MSGTYPE);
	wp = (uint16_t *)cp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	sV1 = *sp;
	cp += 2;

	sp = (short *)cp;
	sV2 = *sp;		   // Dyamic Object Index
	cp += 2;

	sp = (short *)cp;
	sV3 = *sp;
	cp += 2;

	switch (*wp)
	{
		case MSGTYPE_CONFIRM:// Dynamic Object
			m_pMapData->bSetDynamicObject(sX, sY, sV2, sV1, true);
			break;

		case MSGTYPE_REJECT:// Dynamic object
			m_pMapData->bSetDynamicObject(sX, sY, sV2, 0, true);
			break;
	}
}

bool helbreath::_bIsItemOnHand() // Snoopy: Fixed to remove ShieldCast
{
	int i;
	uint16_t wWeaponType;
	for (i = 0; i < MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if ((m_pItemList[i]->m_cEquipPos == EQUIPPOS_LHAND)
				|| /*(*/(m_pItemList[i]->m_cEquipPos == EQUIPPOS_TWOHAND))/* && !(wWeaponType == 35)))*/ // Battle Mages xRisenx
				//|| (m_pItemList[i]->m_cEquipPos == EQUIPPOS_TWOHAND))
				return true;
		}
	for (i = 0; i < MAXITEMS; i++)
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
		{
			if (m_pItemList[i]->m_cEquipPos == EQUIPPOS_RHAND)
			{
				wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
				// Snoopy 34 for all wands.
				if ((wWeaponType >= 34) && (wWeaponType < 41)) return false;
				//else if( wWeaponType == 27 ) return FALSE; // Farming's hoe !
				else return true;
			}
		}
	return false;
}

int helbreath::_iCalcTotalWeight()
{
	int i, iWeight, iCnt, iTemp;
	iCnt = 0;
	iWeight = 0;
	for (i = 0; i < MAXITEMS; i++)
		if (m_pItemList[i] != 0)
		{
			if ((m_pItemList[i]->m_cItemType == ITEMTYPE_CONSUME)
				|| (m_pItemList[i]->m_cItemType == ITEMTYPE_ARROW))
			{
				iTemp = m_pItemList[i]->m_wWeight * m_pItemList[i]->m_dwCount;
				if ((strcmp(m_pItemList[i]->m_cName, "Gold") == 0) || (strcmp(m_pItemList[i]->m_cName, "XtremeTokens") == 0)) iTemp = iTemp / 20;
				iWeight += iTemp;
			}
			else iWeight += m_pItemList[i]->m_wWeight;
			iCnt++;
		}
	m_weight = iWeight / 100;
	return iWeight;
}

void helbreath::DlgBoxClick_15AgeMsg()
{	// Snoopy: removed feedback card
	if (m_dialogBoxes[5].OnButton() == 1)
		DisableDialogBox(5);
}


void helbreath::DlgBoxClick_WarningMsg()
{
	if (m_dialogBoxes[6].OnButton() == 1)
		DisableDialogBox(6);
}

void helbreath::DlgBoxClick_ItemDrop()
{
	if (m_cCommand < 0) return;

	switch (m_dialogBoxes[4].OnButton())
	{
		case 1:
			m_dialogBoxes[4].SetMode(3);
			bSendCommand(MSGID_COMMAND_COMMON,
				COMMONTYPE_ITEMDROP,
				0,
				m_dialogBoxes[4].sView,
				1,
				0,
				m_pItemList[m_dialogBoxes[4].sView]->m_cName);
			//m_stDialogBoxInfo[40].sView ;
			DisableDialogBox(4);
			break;

		case 2:
			for (int i = 0; i < MAXSELLLIST; i++)
				m_bIsItemDisabled[i] = false;

			DisableDialogBox(4);
			break;

		case 3:
			m_bItemDrop = !m_bItemDrop;
			break;
	}
}

void helbreath::DrawDialogBox_GuildContribute()
{
	short sX, sY, szX;
	char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	sX = m_dialogBoxes[58].m_X;
	sY = m_dialogBoxes[58].m_Y;
	szX = m_dialogBoxes[58].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);

	switch (m_dialogBoxes[58].sView)
	{
		case 0: // Gold
			PutAlignedString(sX, sX + szX, sY + 20, DRAW_DIALOGBOX_GUILDCONTRIBUTE1);
			PutAlignedString(sX, sX + szX, sY + 35, DRAW_DIALOGBOX_GUILDCONTRIBUTE2);

			if (iGetTopDialogBoxIndex() != 58)
				PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", GetGold());
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;

		case 1: // Maj
			PutAlignedString(sX, sX + szX, sY + 20, DRAW_DIALOGBOX_GUILDCONTRIBUTE3);
			PutAlignedString(sX, sX + szX, sY + 35, DRAW_DIALOGBOX_GUILDCONTRIBUTE4);

			if (iGetTopDialogBoxIndex() != 58)
				PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", m_iGizonItemUpgradeLeft);
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;

		case 2: // Cont
			PutAlignedString(sX, sX + szX, sY + 20, DRAW_DIALOGBOX_GUILDCONTRIBUTE7);
			PutAlignedString(sX, sX + szX, sY + 35, DRAW_DIALOGBOX_GUILDCONTRIBUTE8);

			if (iGetTopDialogBoxIndex() != 58)
				PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", m_iContribution);
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;
	}

}

void helbreath::DlgBoxClick_ItemSellorRepair()
{
	char onButton = m_dialogBoxes[23].OnButton();
	switch (m_dialogBoxes[23].GetMode())
	{
		case 1:
			if (onButton == 1) // Sell
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_SELLITEMCONFIRM, 0, m_dialogBoxes[23].sV1, m_dialogBoxes[23].sV4, m_dialogBoxes[23].sV3, m_pItemList[m_dialogBoxes[23].sV1]->m_cName); //v1.2
				m_dialogBoxes[23].SetMode(3);
			}
			else if (onButton == 2) // Cancel
			{
				m_bIsItemDisabled[m_dialogBoxes[23].sV1] = false;
				DisableDialogBox(23);
			}
			break;

		case 2:
			if (onButton == 1) // Repair
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_REPAIRITEMCONFIRM, 0, m_dialogBoxes[23].sV1, 0, 0, m_pItemList[m_dialogBoxes[23].sV1]->m_cName);
				m_dialogBoxes[23].SetMode(4);
			}
			else if (onButton == 2) // Cancel
			{
				m_bIsItemDisabled[m_dialogBoxes[23].sV1] = false;
				DisableDialogBox(23);
			}
			break;
	}
}


int helbreath::iGetLevelExp(int iLevel)
{
	int iRet;
	if (iLevel == 0) return 0;
	iRet = iGetLevelExp(iLevel - 1) + iLevel * (50 + (iLevel * (iLevel / 17) * (iLevel / 17)));
	return iRet;
}

int helbreath::_iGetTotalItemNum()
{
	int i, iCnt;
	iCnt = 0;
	for (i = 0; i < MAXITEMS; i++)
		if (m_pItemList[i] != 0) iCnt++;
	return iCnt;
}

uint32_t helbreath::GetGold() const
{
	for (int i = 0; i < MAXITEMS; i++)
	{
		if (m_pItemList[i] && strcmp(m_pItemList[i]->m_cName, "Gold") == 0)
			return m_pItemList[i]->m_dwCount;
	}

	return 0;
}

void helbreath::SetGold(uint32_t val)
{
	for (int i = 0; i < MAXITEMS; i++)
	{
		if (m_pItemList[i] && strcmp(m_pItemList[i]->m_cName, "Gold") == 0)
		{
			m_pItemList[i]->m_dwCount = val;
			_iCalcTotalWeight();
			return;
		}
	}
}

void helbreath::DrawWeatherEffects()
{
#define MAXNUM 1000
	static int ix1[MAXNUM];
	static int iy2[MAXNUM];
	static int iFrame[MAXNUM];
	static int iNum = 0;
	int i;
	short dX, dY, sCnt;
	char cTempFrame;
	uint64_t dwTime = m_dwCurTime;

	switch (m_weather)
	{
		case WEATHER_LIGHTRAIN:
		case WEATHER_MEDIUMRAIN:
		case WEATHER_HEAVYRAIN:
			switch (m_weather)
			{
				case WEATHER_LIGHTRAIN:		sCnt = MAXWEATHEROBJECTS / 5; break;
				case WEATHER_MEDIUMRAIN:	sCnt = MAXWEATHEROBJECTS / 2; break;
				case WEATHER_HEAVYRAIN:		sCnt = MAXWEATHEROBJECTS;     break;
			}

			for (i = 0; i < sCnt; i++)
			{
				if ((m_stWeatherObject[i].cStep >= 0) && (m_stWeatherObject[i].cStep < 20) && (m_stWeatherObject[i].sX != 0))
				{
					dX = m_stWeatherObject[i].sX - m_sViewPointX;
					dY = m_stWeatherObject[i].sY - m_sViewPointY;
					cTempFrame = 16 + (m_stWeatherObject[i].cStep / 6);
					m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);
				}
				else if ((m_stWeatherObject[i].cStep >= 20) && (m_stWeatherObject[i].cStep < 25) && (m_stWeatherObject[i].sX != 0))
				{
					dX = m_stWeatherObject[i].sX - m_sViewPointX;
					dY = m_stWeatherObject[i].sY - m_sViewPointY;
					m_pEffectSpr[11]->PutTransSprite(dX, dY, m_stWeatherObject[i].cStep, dwTime);
				}
			}
			break;

		case WEATHER_LIGHTSNOW:
		case WEATHER_MEDIUMSNOW:
		case WEATHER_HEAVYSNOW:
			switch (m_weather)
			{
				case WEATHER_LIGHTSNOW: sCnt = MAXWEATHEROBJECTS / 5; break;
				case WEATHER_MEDIUMSNOW:	sCnt = MAXWEATHEROBJECTS / 2; break;
				case WEATHER_HEAVYSNOW:	sCnt = MAXWEATHEROBJECTS;     break;
			}
			for (i = 0; i < sCnt; i++)
			{
				if ((m_stWeatherObject[i].cStep >= 0) && (m_stWeatherObject[i].cStep < 80))
				{
					dX = m_stWeatherObject[i].sX - m_sViewPointX;
					dY = m_stWeatherObject[i].sY - m_sViewPointY;

					// Snoopy: Snow on lower bar		
					if (dY >= 460)
					{
						cTempFrame = 39 + (m_stWeatherObject[i].cStep / 20) * 3;
						dX = m_stWeatherObject[i].sBX;
						dY = 426;// 426
					}
					else cTempFrame = 39 + (m_stWeatherObject[i].cStep / 20) * 3 + (rand() % 3);

					m_pEffectSpr[11]->PutTransSprite(dX, dY, cTempFrame, dwTime);

					if (m_bIsXmas == true)
					{
						if (dY == 478 - 53)
						{
							ix1[iNum] = dX;
							iy2[iNum] = dY + (rand() % 5);
							iFrame[iNum] = cTempFrame;
							iNum++;
						}
						if (iNum >= MAXNUM) iNum = 0;
					}

				}
			}
			if (m_bIsXmas == true)
			{
				for (i = 0; i < MAXNUM; i++)
				{
					if (iy2[i] > 10) m_pEffectSpr[11]->PutTransSprite(ix1[i], iy2[i], iFrame[i], dwTime);
				}
			}
			break;
	}
}

void helbreath::WeatherObjectFrameCounter()
{
	int i;
	short sCnt;
	char  cAdd;
	uint64_t dwTime = m_dwCurTime;

	if ((dwTime - m_dwWOFtime) < 30) return;
	m_dwWOFtime = dwTime;

	switch (m_weather)
	{
		case WEATHER_LIGHTRAIN:
		case WEATHER_MEDIUMRAIN:
		case WEATHER_HEAVYRAIN:
			switch (m_weather)
			{
				case WEATHER_LIGHTRAIN:		sCnt = MAXWEATHEROBJECTS / 5; break;
				case WEATHER_MEDIUMRAIN:	sCnt = MAXWEATHEROBJECTS / 2; break;
				case WEATHER_HEAVYRAIN:		sCnt = MAXWEATHEROBJECTS;     break;
			}
			for (i = 0; i < sCnt; i++)
			{
				m_stWeatherObject[i].cStep++;
				if ((m_stWeatherObject[i].cStep >= 0) && (m_stWeatherObject[i].cStep < 20))
				{
					cAdd = (40 - m_stWeatherObject[i].cStep);
					if (cAdd < 0) cAdd = 0;
					m_stWeatherObject[i].sY = m_stWeatherObject[i].sY + cAdd;
					if (cAdd != 0)
						m_stWeatherObject[i].sX = m_stWeatherObject[i].sX - 1;
				}
				else if (m_stWeatherObject[i].cStep >= 25)
				{
					if (m_weather == WEATHER_SUNNY)
					{
						m_stWeatherObject[i].sX = 0;
						m_stWeatherObject[i].sY = 0;
						m_stWeatherObject[i].cStep = 30;
					}
					else
					{
						m_stWeatherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
						m_stWeatherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % 800) - 600) + 240;
						m_stWeatherObject[i].cStep = -1 * (rand() % 10);
					}
				}
			}
			break;

		case WEATHER_LIGHTSNOW:
		case WEATHER_MEDIUMSNOW:
		case WEATHER_HEAVYSNOW:
			switch (m_weather)
			{
				case WEATHER_LIGHTSNOW: sCnt = MAXWEATHEROBJECTS / 5; break;
				case WEATHER_MEDIUMSNOW:	sCnt = MAXWEATHEROBJECTS / 2; break;
				case WEATHER_HEAVYSNOW:	sCnt = MAXWEATHEROBJECTS;     break;
			}
			for (i = 0; i < sCnt; i++)
			{
				m_stWeatherObject[i].cStep++;
				if ((m_stWeatherObject[i].cStep >= 0) && (m_stWeatherObject[i].cStep < 80))
				{
					cAdd = (80 - m_stWeatherObject[i].cStep) / 10;
					if (cAdd < 0) cAdd = 0;
					m_stWeatherObject[i].sY = m_stWeatherObject[i].sY + cAdd;

					//Snoopy: Snow on lower bar
					if (m_stWeatherObject[i].sY > (426 + m_sViewPointY))
					{
						m_stWeatherObject[i].sY = 470 + m_sViewPointY;
						if ((rand() % 10) != 2) m_stWeatherObject[i].cStep--;
						if (m_stWeatherObject[i].sBX == 0) m_stWeatherObject[i].sBX = m_stWeatherObject[i].sX - m_sViewPointX;


					}
					else m_stWeatherObject[i].sX += 1 - (rand() % 3);
				}
				else if (m_stWeatherObject[i].cStep >= 80)
				{
					if (m_weather == WEATHER_SUNNY)
					{
						m_stWeatherObject[i].sX = 0;
						m_stWeatherObject[i].sY = 0;
						m_stWeatherObject[i].sBX = 0;
						m_stWeatherObject[i].cStep = 80;
					}
					else
					{
						m_stWeatherObject[i].sX = (m_pMapData->m_sPivotX * 32) + ((rand() % 940) - 200) + 300;
						m_stWeatherObject[i].sY = (m_pMapData->m_sPivotY * 32) + ((rand() % 800) - 600) + 600;
						m_stWeatherObject[i].cStep = -1 * (rand() % 10);
						m_stWeatherObject[i].sBX = 0;
					}
				}
			}
			break;
	}
}

void helbreath::SetWeatherStatus(Weather type)
{
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);

	if (type != WEATHER_SUNNY)
	{
		m_weather = type;

		if (type >= WEATHER_LIGHTRAIN && type <= WEATHER_HEAVYRAIN)
		{
			// 			if(m_bSoundStat && m_bSoundFlag)
			// 				m_pESound[38]->Play(true);//DIRECTX

			if (m_bMusicStat)
				StartBGM();
		}

		for (int i = 0; i < MAXWEATHEROBJECTS; i++)
		{
			m_stWeatherObject[i].sX = 1;
			m_stWeatherObject[i].sBX = 1;
			m_stWeatherObject[i].sY = 1;
			m_stWeatherObject[i].cStep = -1 * (rand() % 40);
		}
	}
	else
	{
		m_weather = WEATHER_SUNNY;
		//DIRECTX		if ((m_bSoundStat == TRUE) && (m_bSoundFlag)) m_pESound[38]->bStop();
	}
}

void helbreath::DlgBoxClick_ShutDownMsg()
{
	if (m_dialogBoxes[25].OnButton() == 1)
	{
		DisableDialogBox(25);
		PlaySound('E', 14, 5);
	}
}

void helbreath::DrawLine(int x0, int y0, int x1, int y1, Color color)
{ //TODO: replace all instances
    DrawLine(x0, y0, x1, y1, color.r, color.g, color.b, color.a);
}

void helbreath::DrawLine(int x0, int y0, int x1, int y1, int iR, int iG, int iB, int iA)
{
    if ((x0 == x1) && (y0 == y1))
        return;

    sf::Vertex line[] =
    {
        sf::Vertex(sf::Vector2f((float)x0, (float)y0), Color(iR, iG, iB, iA)),
        sf::Vertex(sf::Vector2f((float)x1, (float)y1), Color(iR, iG, iB, iA)) };
    visible.draw(line, 2, sf::Lines);
}

void helbreath::DrawLine2(int x0, int y0, int x1, int y1, int iR, int iG, int iB)
{
	// todo - re-add
// 	int dx, dy, x_inc, y_inc, error, index, dstR, dstG, dstB;
// 	int iResultX, iResultY;
// 	uint16_t * pDst;
// 	if ((x0 == x1) && (y0 == y1)) return;
// 
// 	error = 0;
// 	iResultX = x0;
// 	iResultY = y0;
// 	dx = x1 - x0;
// 	dy = y1 - y0;
// 	if (dx >= 0)
// 	{
// 		x_inc = 1;
// 	}
// 	else
// 	{
// 		x_inc = -1;
// 		dx = -dx;
// 	}
// 	if (dy >= 0)
// 	{
// 		y_inc = 1;
// 	}
// 	else
// 	{
// 		y_inc = -1;
// 		dy = -dy;
// 	}
// 	if (dx > dy)
// 	{
// 		for (index = 0; index <= dx; index++)
// 		{
// 			error += dy;
// 			if (error > dx)
// 			{
// 				error -= dx;
// 				iResultY += y_inc;
// 			}
// 			iResultX += x_inc;
// 			//if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
// 			if ((iResultX >= 0) && (iResultX < GetWidth()) && (iResultY >= 0) && (iResultY < GetHeight()))
// 			{ // 800x600 Resolution xRisenx
// //				pDst = (WORD *)//DIRECTX m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*//DIRECTX m_DDraw.m_sBackB4Pitch);
// // 				switch (//DIRECTX m_DDraw.m_cPixelFormat) {
// // 				case 1:
// // 					dstR = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
// // 					dstG = (int)//DIRECTX m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
// // 					dstB = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
// // 					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
// // 					break;
// // 
// // 				case 2:
// // 					dstR = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
// // 					dstG = (int)//DIRECTX m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
// // 					dstB = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
// // 					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
// // 					break;
// // 				}
// 			}
// 		}
// 	}
// 	else
// 	{
// 		for (index = 0; index <= dy; index++)
// 		{
// 			error += dx;
// 			if (error > dy)
// 			{
// 				error -= dy;
// 				iResultX += x_inc;
// 			}
// 			iResultY += y_inc;
// 			//if ((iResultX >= 0) && (iResultX < 640) && (iResultY >= 0) && (iResultY < 480)) {
// 			if ((iResultX >= 0) && (iResultX < GetWidth()) && (iResultY >= 0) && (iResultY < GetHeight()))
// 			{ // 800x600 Resolution xRisenx
// //				pDst = (WORD *)//DIRECTX m_DDraw.m_pBackB4Addr + iResultX + ((iResultY)*//DIRECTX m_DDraw.m_sBackB4Pitch);
// // 				switch (//DIRECTX m_DDraw.m_cPixelFormat) {
// // 				case 1:
// // 					dstR = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0xF800)>>11][iR];
// // 					dstG = (int)//DIRECTX m_DDraw.m_lTransG50[(pDst[0]&0x7E0)>>5][iG];
// // 					dstB = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
// // 					*pDst = (WORD)((dstR<<11) | (dstG<<5) | dstB);
// // 					break;
// // 
// // 				case 2:
// // 					dstR = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x7C00)>>10][iR];
// // 					dstG = (int)//DIRECTX m_DDraw.m_lTransG50[(pDst[0]&0x3E0)>>5][iG];
// // 					dstB = (int)//DIRECTX m_DDraw.m_lTransRB50[(pDst[0]&0x1F)][iB];
// // 					*pDst = (WORD)((dstR<<10) | (dstG<<5) | dstB);
// // 					break;
// // 	
// // 				}
// 			}
// 		}
// 	}
}

void helbreath::_DrawThunderEffect(int sX, int sY, int dX, int dY, int rX, int rY, char cType)
{
	int j, iErr, pX1, pY1, iX1, iY1, tX, tY;
	char cDir;
	uint64_t dwTime;
	uint16_t  wR1, wG1, wB1, wR2, wG2, wB2, wR3, wG3, wB3, wR4, wG4, wB4;
	dwTime = m_dwCurTime;
	sX = pX1 = iX1 = tX = sX;
	sY = pY1 = iY1 = tY = sY;
	// 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,Color(255,50, 50, 100), &wR1, &wG1, &wB1);
	// 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,Color(255,30, 30, 100), &wR2, &wG2, &wB2);
	// 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,Color(255,0, 0, 30), &wR3, &wG3, &wB3);
	// 	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,Color(255,50, 50, 200), &wR4, &wG4, &wB4);

	for (j = 0; j < 100; j++)
	{
		switch (cType)
		{
			case 1:
				DrawLine(pX1, pY1, iX1, iY1, 15, 15, 20);
				DrawLine(pX1 - 1, pY1, iX1 - 1, iY1, wR1, wG1, wB1);
				DrawLine(pX1 + 1, pY1, iX1 + 1, iY1, wR1, wG1, wB1);
				DrawLine(pX1, pY1 - 1, iX1, iY1 - 1, wR1, wG1, wB1);
				DrawLine(pX1, pY1 + 1, iX1, iY1 + 1, wR1, wG1, wB1);

				DrawLine(pX1 - 2, pY1, iX1 - 2, iY1, wR2, wG2, wB2);
				DrawLine(pX1 + 2, pY1, iX1 + 2, iY1, wR2, wG2, wB2);
				DrawLine(pX1, pY1 - 2, iX1, iY1 - 2, wR2, wG2, wB2);
				DrawLine(pX1, pY1 + 2, iX1, iY1 + 2, wR2, wG2, wB2);

				DrawLine(pX1 - 1, pY1 - 1, iX1 - 1, iY1 - 1, wR3, wG3, wB3);
				DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
				DrawLine(pX1 + 1, pY1 - 1, iX1 + 1, iY1 - 1, wR3, wG3, wB3);
				DrawLine(pX1 - 1, pY1 + 1, iX1 - 1, iY1 + 1, wR3, wG3, wB3);
				break;

			case 2:
				DrawLine2(pX1, pY1, iX1, iY1, wR4, wG4, wB4);
				break;
		}
		iErr = 0;
		m_Misc.GetPoint(sX, sY, dX, dY, &tX, &tY, &iErr, j * 10);
		pX1 = iX1;
		pY1 = iY1;
		cDir = m_Misc.cGetNextMoveDir(iX1, iY1, tX, tY);
		switch (cDir)
		{
			case 1:	rY -= 5; break;
			case 2: rY -= 5; rX += 5; break;
			case 3:	rX += 5; break;
			case 4: rX += 5; rY += 5; break;
			case 5: rY += 5; break;
			case 6: rX -= 5; rY += 5; break;
			case 7: rX -= 5; break;
			case 8: rX -= 5; rY -= 5; break;
		}
		if (rX < -20) rX = -20;
		if (rX > 20) rX = 20;
		if (rY < -20) rY = -20;
		if (rY > 20) rY = 20;
		iX1 = iX1 + rX;
		iY1 = iY1 + rY;
		if ((abs(tX - dX) < 5) && (abs(tY - dY) < 5)) break;
	}
	switch (cType)
	{
		case 1:
			m_pEffectSpr[6]->PutTransSprite(iX1, iY1, (rand() % 2), dwTime);
			break;
	}
}

bool helbreath::DlgBoxPress_SkillDlg()
{
	int i, iAdjX, iAdjY;
	char  cItemID;
	short sX, sY, x1, y1, x2, y2, sArray[10];

	short msX = m_stMCursor.sX;
	short msY = m_stMCursor.sY;
	sX = m_dialogBoxes[26].m_X;
	sY = m_dialogBoxes[26].m_Y;
	iAdjX = 5;
	iAdjY = 10;

	switch (m_dialogBoxes[26].GetMode())
	{
		case 1:
			ZeroMemory(sArray, sizeof(sArray));
			sArray[1] = m_dialogBoxes[26].sV1;
			sArray[2] = m_dialogBoxes[26].sV2;
			sArray[3] = m_dialogBoxes[26].sV3;
			sArray[4] = m_dialogBoxes[26].sV4;
			sArray[5] = m_dialogBoxes[26].sV5;
			sArray[6] = m_dialogBoxes[26].sV6;
			for (i = 1; i <= 6; i++)
				if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
				{
					cItemID = (char)sArray[i];
					switch (i)
					{
						case 1: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 2: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 3: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 4: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 5: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 6: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
					}
					x1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
					y1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
					x2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
					y2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
					if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
					{
						switch (i)
						{
							case 1: m_dialogBoxes[26].sV1 = -1; break;
							case 2: m_dialogBoxes[26].sV2 = -1; break;
							case 3: m_dialogBoxes[26].sV3 = -1; break;
							case 4: m_dialogBoxes[26].sV4 = -1; break;
							case 5: m_dialogBoxes[26].sV5 = -1; break;
							case 6: m_dialogBoxes[26].sV6 = -1; break;
						}
						m_bIsItemDisabled[cItemID] = false;
						m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
						m_stMCursor.sSelectedObjectID = cItemID;
						m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
						m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
						return true;
					}
				}
			break;

		case 4:
			ZeroMemory(sArray, sizeof(sArray));
			sArray[1] = m_dialogBoxes[26].sV1;
			sArray[2] = m_dialogBoxes[26].sV2;
			sArray[3] = m_dialogBoxes[26].sV3;
			sArray[4] = m_dialogBoxes[26].sV4;
			sArray[5] = m_dialogBoxes[26].sV5;
			sArray[6] = m_dialogBoxes[26].sV6;
			for (i = 1; i <= 6; i++)
				if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
				{
					cItemID = (char)sArray[i];
					switch (i)
					{
						case 1: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 2: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 3: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 4: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 5: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 6: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180, m_pItemList[cItemID]->m_sSpriteFrame); break;
					}
					x1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
					y1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
					x2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
					y2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;

					if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
					{
						switch (i)
						{
							case 1: m_dialogBoxes[26].sV1 = -1; break;
							case 2: m_dialogBoxes[26].sV2 = -1; break;
							case 3: m_dialogBoxes[26].sV3 = -1; break;
							case 4: m_dialogBoxes[26].sV4 = -1; break;
							case 5: m_dialogBoxes[26].sV5 = -1; break;
							case 6: m_dialogBoxes[26].sV6 = -1; break;
						}
						m_bIsItemDisabled[cItemID] = false;
						m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
						m_stMCursor.sSelectedObjectID = cItemID;
						m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
						m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
						m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
						return true;
					}
				}
			break;
			// Crafting
		case 7:
			ZeroMemory(sArray, sizeof(sArray));
			sArray[1] = m_dialogBoxes[26].sV1;
			sArray[2] = m_dialogBoxes[26].sV2;
			sArray[3] = m_dialogBoxes[26].sV3;
			sArray[4] = m_dialogBoxes[26].sV4;
			sArray[5] = m_dialogBoxes[26].sV5;
			sArray[6] = m_dialogBoxes[26].sV6;
			for (i = 1; i <= 6; i++)
				if ((sArray[i] != -1) && (m_pItemList[sArray[i]] != 0))
				{
					cItemID = (char)sArray[i];
					switch (i)
					{
						case 1: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 55, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 2: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 40, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 3: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 2, sY + iAdjY + 55, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 4: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 5: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 65 + 45 * 1, sY + iAdjY + 115, m_pItemList[cItemID]->m_sSpriteFrame); break;
						case 6: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->_GetSpriteRect(sX + iAdjX + 75 + 45 * 2, sY + iAdjY + 100, m_pItemList[cItemID]->m_sSpriteFrame); break;
					}
					x1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.left;
					y1 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.top;
					x2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.right;
					y2 = (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_rcBound.bottom;
					if ((msX > x1) && (msX < x2) && (msY > y1) && (msY < y2))
					{
						switch (i)
						{
							case 1: m_dialogBoxes[26].sV1 = -1; break;
							case 2: m_dialogBoxes[26].sV2 = -1; break;
							case 3: m_dialogBoxes[26].sV3 = -1; break;
							case 4: m_dialogBoxes[26].sV4 = -1; break;
							case 5: m_dialogBoxes[26].sV5 = -1; break;
							case 6: m_dialogBoxes[26].sV6 = -1; break;
						}
						m_bIsItemDisabled[cItemID] = false;
						m_stMCursor.cSelectedObjectType = SELECTEDOBJTYPE_ITEM;
						m_stMCursor.sSelectedObjectID = cItemID;
						m_stMCursor.sDistX = msX + iAdjX - x1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotX;
						m_stMCursor.sDistY = msY + iAdjY - y1 + (short)m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->m_sPivotY;
						return true;
					}
				}
			break;
	}

	return false;
}

int helbreath::_iGetAttackType()
{
	uint16_t wWeaponType;
	int i; // Battle Mages xRisenx
	wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);
	if (wWeaponType == 0)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_HANDATTACK] >= 100))
			return 20;
		else return 1;		// Boxe
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_SHORTSWORD] >= 100))
			return 21;
		else return 1;		//Dag, SS
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Added Kloness Esterk
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
				(m_cSkillMastery[SKILL_FENCING] >= 100))
				return 22;
			else return 1;  // Esterk
		}
		else if (wWeaponType == 15)
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
				(m_cSkillMastery[SKILL_LONGSWORD] >= 100))
				return 30;
			else return 5;  // StormBlade
		}
		else
		{
			if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
				(m_cSkillMastery[SKILL_LONGSWORD] >= 100))
				return 23;
			else return 1;	// LongSwords
		}
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_AXE] >= 100))
			return 24;
		else return 1;		// Haches
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_HAMMER] >= 100))
			return 26;
		else return 1;		// Hammers
	}
	// Battle Mages xRisenx
	else if ((wWeaponType >= 34) && (wWeaponType < 41))
	{
		for (i = 0; i < MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))
			{
				if ((m_pItemList[i]->m_cEquipPos == EQUIPPOS_TWOHAND) && (wWeaponType == 35))
				{
					if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[21] >= 100)) return 30;
					else return 5;
				}
			}
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (m_cSkillMastery[21] >= 100)) return 27;
		else return 1;		// Wands
		// Battle Mages xRisenx
	//else if ((wWeaponType >= 34) && (wWeaponType < 41))
	//{
	//	if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == TRUE) &&
	//		(m_cSkillMastery[SKILL_STAFF] >= 100))
	//		return 27;
	//	else return 1;		// Wands
	}
	else if (wWeaponType >= 41)
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_ARCHERY] >= 100))
			return 25;
		else return 2;		// Bows
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		if ((m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) &&
			(m_cSkillMastery[SKILL_LONGSWORD] >= 100))
			return 23;
		else return 1;		// LS
	}
	return 0;
}

int helbreath::_iGetWeaponSkillType()
{
	uint16_t wWeaponType = ((m_sPlayerAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0)
	{
		return SKILL_HANDATTACK;
	}
	else if ((wWeaponType >= 1) && (wWeaponType < 3))
	{
		return SKILL_SHORTSWORD;
	}
	else if ((wWeaponType >= 3) && (wWeaponType < 20))
	{
		if ((wWeaponType == 7) || (wWeaponType == 18)) // Esterk or KlonessEsterk
			return SKILL_FENCING;
		else return SKILL_LONGSWORD;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 29))
	{
		return SKILL_AXE;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 33))
	{
		return SKILL_HAMMER;
	}
	else if ((wWeaponType >= 34) && (wWeaponType < 41))
	{
		return SKILL_STAFF;
	}
	else if (wWeaponType >= 41)
	{
		return SKILL_ARCHERY;
	}
	else if ((wWeaponType == 29) || (wWeaponType == 33))
	{
		return SKILL_LONGSWORD;  // LS LightingBlade || BlackShadow
	}
	return SKILL_FISHING;
}

void helbreath::NotifyMsg_AdminInfo(char * pData)
{
	char * cp, cStr[256];
	int * ip, iV1, iV2, iV3, iV4, iV5;

	cp = (char *)(pData + 6);

	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV5 = *ip;
	cp += 4;

	ZeroMemory(cStr, sizeof(cStr));
	fmt::format_to(cStr, "%d %d %d %d %d", iV1, iV2, iV3, iV4, iV5);
	AddEventList(cStr);
}

/*********************************************************************************************************************
**  void CGame::bItemDrop_ExchangeDialog()										**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void helbreath::bItemDrop_ExchangeDialog()
{
	char cItemID;
	if (m_cCommand < 0) return;
	if (m_stDialogBoxExchangeInfo[3].sV1 != -1) return; //Do not accept item's drop if already 4 items.

	short msY = m_stMCursor.sY;
	short msX = m_stMCursor.sX;
	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_stDialogBoxExchangeInfo[0].sV1 == cItemID || m_stDialogBoxExchangeInfo[1].sV1 == cItemID || m_stDialogBoxExchangeInfo[2].sV1 == cItemID)
		return;

	if (((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxes[17].m_X = msX - 140;
		m_dialogBoxes[17].m_Y = msY - 70;
		if (m_dialogBoxes[17].m_Y < 0) m_dialogBoxes[17].m_Y = 0;
		m_dialogBoxes[17].sV1 = m_sPlayerX + 1;
		m_dialogBoxes[17].sV2 = m_sPlayerY + 1;
		m_dialogBoxes[17].sV3 = 1000;
		m_dialogBoxes[17].sV4 = cItemID;
		//m_stDialogBoxInfo[27].sView = cItemID;
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		ZeroMemory(m_dialogBoxes[17].cStr, sizeof(m_dialogBoxes[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		return;
	}
	else // hum? dj on affiche? , bon je dsactive, ca devrait plutt s'afficher lors du retour du serveur.
	{	/*m_stDialogBoxInfo[27].sV1 = m_pItemList[cItemID]->m_sSprite;
		m_stDialogBoxInfo[27].sV2 = m_pItemList[cItemID]->m_sSpriteFrame;
		m_stDialogBoxInfo[27].sV3 = 1;
		m_stDialogBoxInfo[27].sV4 = m_pItemList[cItemID]->m_cItemColor;
		m_stDialogBoxInfo[27].sView = cItemID;*/
		if (m_stDialogBoxExchangeInfo[0].sV1 == -1)			m_stDialogBoxExchangeInfo[0].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[1].sV1 == -1)	m_stDialogBoxExchangeInfo[1].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[2].sV1 == -1)	m_stDialogBoxExchangeInfo[2].sItemID = cItemID;
		else if (m_stDialogBoxExchangeInfo[3].sV1 == -1)	m_stDialogBoxExchangeInfo[3].sItemID = cItemID;
		else return; // Impossible case, tested at function beginning
		m_bIsItemDisabled[cItemID] = true;
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_SETEXCHANGEITEM, 0, cItemID, 1, 0, 0);
		//	   :bSendCommand(DWORD dwMsgID,        WORD wCommand,             char cDir, int iV1, int iV2, int iV3, char * pString, int iV4)
		return;
	}
}
/*********************************************************************************************************************
**  void CGame::DlgBoxClick_Exchange()											**
**  description			:: modifyed for MultiTrade																	**
**********************************************************************************************************************/
void helbreath::DlgBoxClick_Exchange()
{
	char onButton = m_dialogBoxes[27].OnButton();
	switch (m_dialogBoxes[27].GetMode())
	{
		case 1: // Not yet confirmed the exchange
			if (onButton == 1) // Exchange
			{
				if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
				{	/*bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CONFIRMEXCHANGEITEM, NULL
						, m_stDialogBoxExchangeInfo[0].sV1 // ItemID; inutilis par serveur
						, m_stDialogBoxExchangeInfo[0].sV3 // Amount; inutilis par serveur
						, NULL, NULL);	*/
					PlaySound('E', 14, 5);
					m_dialogBoxes[27].SetMode(2);
					// Show confirmation Diag instead.
					EnableDialogBox(41, 0, 0, 0);
					m_dialogBoxes[41].SetMode(1);
				}
				return;
			}
			else if (onButton == 2 && (m_bIsDialogEnabled[41] == false)) // Cancel only possible if confirmation is not activated
			{
				DisableDialogBox(27);
				DisableDialogBox(22);
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0);
				PlaySound('E', 14, 5);
				return;
			}
			break;

		case 2: // Someone already confirmed the exchange
		/*	if (onButton == 1)  // Cancel
			{
				DisableDialogBox(27);
				DisableDialogBox(22);
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL);
				PlaySound('E', 14, 5);
				return;
			}*/
			break;
	}
}
/*********************************************************************************************************************
**  void CGame::DlgBoxClick_ConfirmExchange()									**
**  description			:: click on confirmation diag																**
**********************************************************************************************************************/
void helbreath::DlgBoxClick_ConfirmExchange()
{
	char onButton = m_dialogBoxes[41].OnButton();
	switch (m_dialogBoxes[41].GetMode())
	{
		case 1: // Not yet confirmed the exchange
			// yes
			if (onButton == 1)
			{
				if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CONFIRMEXCHANGEITEM, 0
						, m_stDialogBoxExchangeInfo[0].sV1 // ItemID; inutilis par serveur
						, m_stDialogBoxExchangeInfo[0].sV3 // Amount; inutilis par serveur
						, 0, 0);
					PlaySound('E', 14, 5);
					m_dialogBoxes[27].SetMode(2);
					m_dialogBoxes[41].SetMode(2);
				}
				return;
			}
			else if (onButton == 2)// No
			{
				DisableDialogBox(41);
				DisableDialogBox(27);
				DisableDialogBox(22);
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0);
				PlaySound('E', 14, 5);
				return;
			}
			break;
		case 2: // waiting for other side to confirm
			break;
	}
}

void helbreath::DlgBoxClick_Quest()
{
	if (m_dialogBoxes[28].OnButton() == 1)
	{
		DisableDialogBox(28);
		PlaySound('E', 14, 5);
	}
}

int helbreath::_iGetBankItemCount()
{
	int i, iCnt;

	iCnt = 0;
	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pBankList[i] != 0) iCnt++;

	return iCnt;
}

bool helbreath::_bDecodeBuildItemContents()
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE * pFile;
	uint32_t  dwFileSize;
	char * pBuffer;
	bool   bRet;
	int    i;

	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{
			delete m_pBuildItemList[i];
			m_pBuildItemList[i] = 0;
		}

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));

	strcpy(cTemp, "BItemcfg");
	strcat(cFileName, "data\\shops");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cTemp);
	strcat(cFileName, ".txt");

	hFile = CreateFileA(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return false;
	else
	{
		pBuffer = new char[dwFileSize + 1];
		ZeroMemory(pBuffer, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);
		bRet = __bDecodeBuildItemContents(pBuffer);
		delete[] pBuffer;
	}
	fclose(pFile);
	return bRet;
}

bool helbreath::_bCheckBuildItemStatus()
{
	int iIndex, i, j, iMatch, iCount;
	char cTempName[21];
	int  iItemCount[MAXITEMS];

	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pDispBuildItemList[i] != 0)
		{
			delete m_pDispBuildItemList[i];
			m_pDispBuildItemList[i] = 0;
		}
	iIndex = 0;
#ifdef TitleClient
	int iBSTitleRank = 0;
	for (i = 0; i < MAXMENUITEMS; i++)
	{
		if (m_pTitles[i] != 0)
		{
			if (strcmp(m_pTitles[i]->m_cSubject, "Blacksmithing") == 0)
			{
				iBSTitleRank = m_pTitles[i]->m_iRank;
				break;
			}
		}
	}
#endif
	for (i = 0; i < MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != 0)
		{	// Skill-Limit
#ifdef TitleClient
			if (iBSTitleRank >= m_pBuildItemList[i]->m_iSkillLimit) // Titles xRisenx		
#else
			if (m_cSkillMastery[SKILL_MANUFACTURING] >= m_pBuildItemList[i]->m_iSkillLimit)
#endif
			{
				iMatch = 0;
				m_pDispBuildItemList[iIndex] = new class CBuildItem;
				memcpy(m_pDispBuildItemList[iIndex]->m_cName, m_pBuildItemList[i]->m_cName, 20);

				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName1, m_pBuildItemList[i]->m_cElementName1, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName2, m_pBuildItemList[i]->m_cElementName2, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName3, m_pBuildItemList[i]->m_cElementName3, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName4, m_pBuildItemList[i]->m_cElementName4, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName5, m_pBuildItemList[i]->m_cElementName5, 20);
				memcpy(m_pDispBuildItemList[iIndex]->m_cElementName6, m_pBuildItemList[i]->m_cElementName6, 20);

				m_pDispBuildItemList[iIndex]->m_iElementCount[1] = m_pBuildItemList[i]->m_iElementCount[1];
				m_pDispBuildItemList[iIndex]->m_iElementCount[2] = m_pBuildItemList[i]->m_iElementCount[2];
				m_pDispBuildItemList[iIndex]->m_iElementCount[3] = m_pBuildItemList[i]->m_iElementCount[3];
				m_pDispBuildItemList[iIndex]->m_iElementCount[4] = m_pBuildItemList[i]->m_iElementCount[4];
				m_pDispBuildItemList[iIndex]->m_iElementCount[5] = m_pBuildItemList[i]->m_iElementCount[5];
				m_pDispBuildItemList[iIndex]->m_iElementCount[6] = m_pBuildItemList[i]->m_iElementCount[6];

				m_pDispBuildItemList[iIndex]->m_iSprH = m_pBuildItemList[i]->m_iSprH;
				m_pDispBuildItemList[iIndex]->m_iSprFrame = m_pBuildItemList[i]->m_iSprFrame;
				m_pDispBuildItemList[iIndex]->m_iMaxSkill = m_pBuildItemList[i]->m_iMaxSkill;
				m_pDispBuildItemList[iIndex]->m_iSkillLimit = m_pBuildItemList[i]->m_iSkillLimit;

				// ItemCount
				for (j = 0; j < MAXITEMS; j++)
					if (m_pItemList[j] != 0)
						iItemCount[j] = m_pItemList[j]->m_dwCount;
					else iItemCount[j] = 0;

				// Element1
				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName1, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[1];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[1] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP2;
							}
						}
				}

				CBIS_STEP2:;
				// Element2
				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName2, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[2];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[2] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP3;
							}
						}
				}

				CBIS_STEP3:;
				// Element3
				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName3, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[3];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[3] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP4;
							}
						}
				}

				CBIS_STEP4:;

				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName4, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[4];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[4] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP5;
							}
						}
				}

				CBIS_STEP5:;

				// Element5
				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName5, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[5];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[5] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP6;
							}
						}
				}

				CBIS_STEP6:;

				// Element6
				ZeroMemory(cTempName, sizeof(cTempName));
				memcpy(cTempName, m_pBuildItemList[i]->m_cElementName6, 20);
				iCount = m_pBuildItemList[i]->m_iElementCount[6];
				if (iCount == 0) iMatch++;
				else
				{
					for (j = 0; j < MAXITEMS; j++)
						if (m_pItemList[j] != 0)
						{
							if ((memcmp(m_pItemList[j]->m_cName, cTempName, 20) == 0) && (m_pItemList[j]->m_dwCount >= (uint32_t)(iCount)) &&
								(iItemCount[j] > 0))
							{
								iMatch++;
								m_pDispBuildItemList[iIndex]->m_bElementFlag[6] = true;
								iItemCount[j] -= iCount;
								goto CBIS_STEP7;
							}
						}
				}

				CBIS_STEP7:;

				if (iMatch == 6) m_pDispBuildItemList[iIndex]->m_bBuildEnabled = true;
				iIndex++;
			}
		}
	return true;
}

bool helbreath::_ItemDropHistory(char * ItemName)
{
	/*BOOL bFlag = FALSE;
	if (m_iItemDropCnt == 0 )
	{	strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
		m_iItemDropCnt++;
		return TRUE;
	}
	if ( (1 <= m_iItemDropCnt) && (20 >= m_iItemDropCnt) )
	{	for (int i = 0; i < m_iItemDropCnt; i++)
		{	if (strcmp(m_cItemDrop[i], ItemName) == 0)
			{	bFlag = TRUE;
				break;
		}	}
		if (bFlag)
		{	if (m_bItemDrop)
				return FALSE;
			else
				return TRUE;
		}

		if( 20 < m_iItemDropCnt )
		{	for (int i = 0; i < m_iItemDropCnt ; i++)
			strcpy(m_cItemDrop[i-1], ItemName);
			strcpy(m_cItemDrop[20], ItemName);
			m_iItemDropCnt = 21;
		}else
		{	strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
			m_iItemDropCnt++;
	}	}
	return TRUE;*/
	//BESK item drop rewritten
	bool bFound = false;
	for (int i = 0; i < m_iItemDropCnt; i++)
	{
		if (strcmp(m_cItemDrop[i], ItemName) == 0)
		{
			bFound = true;
			break;
		}
	}

	if (bFound == true)
	{//the item was already listed
		if (m_bItemDrop == true)//user doesnt want to be bothered for item names he already dropped
			return false;//dont show the user the confirm dlg
		else
			return true;
	}
	else
	{
		if (m_iItemDropCnt < NUM_ITEMDROPSLOTS)
		{
			strcpy(m_cItemDrop[m_iItemDropCnt], ItemName);
			m_iItemDropCnt++;
		}
		return true;
	}
}


bool helbreath::__bDecodeBuildItemContents(char * pBuffer)
{
	char * pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iIndex = 0;
	class CStrTok * pStrTok;
	pContents = pBuffer;
	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			switch (cReadModeA)
			{
				case 1:
					switch (cReadModeB)
					{
						case 1:
							ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
							memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
							cReadModeB = 2;
							break;
						case 2:
							m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
							cReadModeB = 3;
							break;
						case 3: // m_cElementName1
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName1, sizeof(m_pBuildItemList[iIndex]->m_cElementName1));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName1, token, strlen(token));
							cReadModeB = 4;
							break;
						case 4: // m_iElementCount1
							m_pBuildItemList[iIndex]->m_iElementCount[1] = atoi(token);
							cReadModeB = 5;
							break;
						case 5: // m_cElementName2
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName2, sizeof(m_pBuildItemList[iIndex]->m_cElementName2));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName2, token, strlen(token));
							cReadModeB = 6;
							break;
						case 6: // m_iElementCount2
							m_pBuildItemList[iIndex]->m_iElementCount[2] = atoi(token);
							cReadModeB = 7;
							break;
						case 7: // m_cElementName3
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName3, sizeof(m_pBuildItemList[iIndex]->m_cElementName3));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName3, token, strlen(token));
							cReadModeB = 8;
							break;
						case 8: // m_iElementCount3
							m_pBuildItemList[iIndex]->m_iElementCount[3] = atoi(token);
							cReadModeB = 9;
							break;
						case 9: // m_cElementName4
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName4, sizeof(m_pBuildItemList[iIndex]->m_cElementName4));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName4, token, strlen(token));
							cReadModeB = 10;
							break;
						case 10: // m_iElementCount4
							m_pBuildItemList[iIndex]->m_iElementCount[4] = atoi(token);
							cReadModeB = 11;
							break;
						case 11: // m_cElementName5
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName5, sizeof(m_pBuildItemList[iIndex]->m_cElementName5));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName5, token, strlen(token));
							cReadModeB = 12;
							break;
						case 12: // m_iElementCount5
							m_pBuildItemList[iIndex]->m_iElementCount[5] = atoi(token);
							cReadModeB = 13;
							break;
						case 13: // m_cElementName6
							ZeroMemory(m_pBuildItemList[iIndex]->m_cElementName6, sizeof(m_pBuildItemList[iIndex]->m_cElementName6));
							memcpy(m_pBuildItemList[iIndex]->m_cElementName6, token, strlen(token));
							cReadModeB = 14;
							break;
						case 14: // m_iElementCount6
							m_pBuildItemList[iIndex]->m_iElementCount[6] = atoi(token);
							cReadModeB = 15;
							break;

						case 15:
							m_pBuildItemList[iIndex]->m_iSprH = atoi(token);
							cReadModeB = 16;
							break;

						case 16:
							m_pBuildItemList[iIndex]->m_iSprFrame = atoi(token);
							cReadModeB = 17;
							break;

						case 17:
							m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							iIndex++;
							break;
					}
					break;

				default:
					break;
			}
		}
		else
		{
			if (memcmp(token, "BuildItem", 9) == 0)
			{
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
		}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}


bool helbreath::_bCheckCurrentBuildItemStatus()
{
	int i, iCount2, iMatch, iIndex, iItemIndex[7];
	int iCount;
	int iItemCount[7];
	char cTempName[21];
	bool bItemFlag[7];

	iIndex = m_dialogBoxes[26].cStr[0];

	if (m_pBuildItemList[iIndex] == 0) return false;

	iItemIndex[1] = m_dialogBoxes[26].sV1;
	iItemIndex[2] = m_dialogBoxes[26].sV2;
	iItemIndex[3] = m_dialogBoxes[26].sV3;
	iItemIndex[4] = m_dialogBoxes[26].sV4;
	iItemIndex[5] = m_dialogBoxes[26].sV5;
	iItemIndex[6] = m_dialogBoxes[26].sV6;

	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1)
			iItemCount[i] = m_pItemList[iItemIndex[i]]->m_dwCount;
		else iItemCount[i] = 0;
	iMatch = 0;
	for (i = 1; i <= 6; i++) bItemFlag[i] = false;

	// Element1
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName1, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[1];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP2;
			}
		}
	}

	CCBIS_STEP2:;

	// Element2
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName2, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[2];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP3;
			}
		}
	}

	CCBIS_STEP3:;


	// Element3
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName3, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[3];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP4;
			}
		}
	}

	CCBIS_STEP4:;

	// Element4
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName4, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[4];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP5;
			}
		}
	}

	CCBIS_STEP5:;

	// Element5
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName5, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[5];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP6;
			}
		}
	}

	CCBIS_STEP6:;

	// Element6
	ZeroMemory(cTempName, sizeof(cTempName));
	memcpy(cTempName, m_pDispBuildItemList[iIndex]->m_cElementName6, 20);
	iCount = m_pDispBuildItemList[iIndex]->m_iElementCount[6];
	if (iCount == 0) iMatch++;
	else
	{
		for (i = 1; i <= 6; i++)
		{
			if ((iItemIndex[i] != -1) && (memcmp(m_pItemList[iItemIndex[i]]->m_cName, cTempName, 20) == 0) &&
				(m_pItemList[iItemIndex[i]]->m_dwCount >= (uint32_t)(iCount)) &&
				(iItemCount[i] > 0) && (bItemFlag[i] == false))
			{
				iMatch++;
				iItemCount[i] -= iCount;
				bItemFlag[i] = true;
				goto CCBIS_STEP7;
			}
		}
	}

	CCBIS_STEP7:;

	iCount = 0;
	for (i = 1; i <= 6; i++)
		if (m_pDispBuildItemList[iIndex]->m_iElementCount[i] != 0) iCount++;
	iCount2 = 0;
	for (i = 1; i <= 6; i++)
		if (iItemIndex[i] != -1) iCount2++;
	if ((iMatch == 6) && (iCount == iCount2)) return true;
	return false;
}

void helbreath::NoticementHandler(char * pData)
{
	char * cp;
	FILE * pFile;
	uint16_t * wp;
	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	switch (*wp)
	{
		case MSGTYPE_CONFIRM:
			break;
		case MSGTYPE_REJECT:
			cp = (char *)(pData + INDEX2_MSGTYPE + 2);
			pFile = fopen("data\\shops\\contents1000.txt", "wt");
			if (pFile == 0) return;
			fwrite(cp, strlen(cp), 1, pFile);
			fclose(pFile);
			m_dialogBoxes[18].m_X = 20;
			m_dialogBoxes[18].m_Y = 65;
			EnableDialogBox(18, 1000, 0, 0);
			break;
	}
	AddEventList(MSG_NOTIFY_HELP, 10);
	if (m_iLevel < 42) EnableDialogBox(35, 0, 0, 0);

}

int helbreath::_iGetFOE(int iStatus)
{
	if (m_adminLevel > 1) return 1;	// GMHelper

	Side foeSide = (Side)(iStatus >> 28);

	if (m_iPKCount != 0) return -1;
	if (iStatus & STATUS_PK) return -2;
	if (m_iIlusionOwnerH != 0) return -1;

	if (foeSide == HOSTILE)
		return -1;
	else if (foeSide == NEUTRAL || m_side == NEUTRAL)
		return 0;
	else if (foeSide == m_side)
		return 1;

	return -1;
}

void helbreath::_SetIlusionEffect(int iOwnerH)
{
	char cDir;

	m_iIlusionOwnerH = iOwnerH;

	m_cName_IE = {};
	m_pMapData->GetOwnerStatusByObjectID(iOwnerH, &m_cIlusionOwnerType, &cDir, &m_sAppr1_IE, &m_sAppr2_IE, &m_sAppr3_IE, &m_sAppr4_IE, &m_sHeadApprValue_IE, &m_sBodyApprValue_IE, &m_sArmApprValue_IE, &m_sLegApprValue_IE, &m_iStatus_IE, &m_iApprColor_IE, m_cName_IE); // Re-Coding Sprite xRisenx

	if (!m_cIlusionOwnerType)
	{
		m_cIlusionOwnerType = 1;
	}
	if (m_iStatus_IE & STATUS_INVISIBILITY)
	{
		m_iStatus_IE = m_iStatus_IE & (STATUS_ALL - STATUS_INVISIBILITY);
	}
}

void helbreath::ResponsePanningHandler(char * pData)
{
	char * cp, cDir;
	short * sp, sX, sY;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	switch (cDir)
	{
		case 1: m_sViewDstY -= 32; m_sPlayerY--; break;
		case 2: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX += 32; m_sPlayerX++; break;
		case 3: m_sViewDstX += 32; m_sPlayerX++; break;
		case 4: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX += 32; m_sPlayerX++; break;
		case 5: m_sViewDstY += 32; m_sPlayerY++; break;
		case 6: m_sViewDstY += 32; m_sPlayerY++; m_sViewDstX -= 32; m_sPlayerX--; break;
		case 7: m_sViewDstX -= 32; m_sPlayerX--; break;
		case 8: m_sViewDstY -= 32; m_sPlayerY--; m_sViewDstX -= 32; m_sPlayerX--; break;
	}

	m_pMapData->ShiftMapData(cDir);
	_ReadMapData(sX, sY, cp);

	m_bIsRedrawPDBGS = true;

	m_bIsObserverCommanded = false;
}

bool helbreath::bReadItemNameConfigFile()
{
	FILE * pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "=\n";
	int iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFileA("data\\shops\\ItemName.cfg", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen("data\\shops\\ItemName.cfg", "rt");
	if (pFile == 0) return false;
	else
	{
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);
		while (token != 0)
		{

			if (cReadModeA != 0)
			{
				switch (cReadModeA)
				{
					case 1:
						switch (cReadModeB)
						{
							case 1:
								m_pItemNameList[iIndex] = new class CItemName;
								strcpy(m_pItemNameList[iIndex]->m_cOriginName, token);
								cReadModeB = 2;
								break;

							case 2:
								strcpy(m_pItemNameList[iIndex]->m_cName, token);
								cReadModeA = 0;
								cReadModeB = 0;
								iIndex++;
								break;
						}
				}
			}
			else
			{
				if (memcmp(token, "Item", 4) == 0)
				{
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = strtok(0, seps);
		}
		delete[] cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void helbreath::DrawDialogBox_Map()
{
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	double dV1, dV2, dV3;
	int    tX, tY, szX, szY, dX, dY;

	sX = m_dialogBoxes[22].m_X;
	sY = m_dialogBoxes[22].m_Y;

	szX = 0;
	szY = 0;

	switch (m_dialogBoxes[22].sV1)
	{
		case 1:
			switch (m_dialogBoxes[22].sV2)
			{
				case 0: // aresden
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 0, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 0, dwTime);
					dX = 19;
					dY = 20;
					szX = 260;
					szY = 260;
					break;

				case 1: // elvine
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS1]->PutTransSprite2(sX, sY, 1, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS1]->PutSpriteFast(sX, sY, 1, dwTime);
					dX = 20;
					dY = 18;
					szX = 260;
					szY = 260;
					break;

				case 2: // middleland
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 0, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 0, dwTime);
					dX = 11;
					dY = 31;
					szX = 280;
					szY = 253;
					break;

				case 3: // default
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS2]->PutTransSprite2(sX, sY, 1, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS2]->PutSpriteFast(sX, sY, 1, dwTime);
					dX = 52;
					dY = 42;
					szX = 200;
					szY = 200;
					break;

				case 4:
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 0, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 0, dwTime);
					dX = 40;
					dY = 40;
					szX = 220;
					szY = 220;
					break;

				case 5:
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS3]->PutTransSprite2(sX, sY, 1, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS3]->PutSpriteFast(sX, sY, 1, dwTime);
					dX = 40;
					dY = 40;
					szX = 220;
					szY = 220;
					break;

				case 6: // aresden
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 0, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 0, dwTime);
					dX = 40;
					dY = 40;
					szX = 220;
					szY = 220;
					break;

				case 7: // elvine
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS4]->PutTransSprite2(sX, sY, 1, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS4]->PutSpriteFast(sX, sY, 1, dwTime);
					dX = 40;
					dY = 40;
					szX = 220;
					szY = 220;
					break;
				case 8: // aresden
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 0, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 0, dwTime);
					dX = 40;
					dY = 32;
					szX = 220;
					szY = 220;
					break;

				case 9: // elvine
					if (m_bDialogTrans)
						m_pSprite[SPRID_INTERFACE_NEWMAPS5]->PutTransSprite2(sX, sY, 1, dwTime);
					else m_pSprite[SPRID_INTERFACE_NEWMAPS5]->PutSpriteFast(sX, sY, 1, dwTime);
					dX = 40;
					dY = 38;
					szX = 220;
					szY = 220;
					break;

			}

			dV1 = (double)m_pMapData->m_sMapSizeX;
			dV2 = (double)m_sPlayerX;
			dV3 = (dV2 * (double)szX) / dV1;
			tX = (int)dV3 + dX;

			dV1 = (double)m_pMapData->m_sMapSizeY;
			if (dV1 == 752) dV1 = 680;
			dV2 = (double)m_sPlayerY;
			dV3 = (dV2 * (double)szY) / dV1;
			tY = (int)dV3 + dY;


			//m_pSprite[SPRID_INTERFACE_MAPS1]->PutSpriteFast(sX +tX, sY +tY, 4, dwTime);
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX + tX, sY + tY, 43);
			fmt::format_to(G_cTxt, "%d,%d", m_sPlayerX, m_sPlayerY);
			PutString_SprFont3(sX + 10 + tX - 5, sY + 10 + tY - 6, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
			break;
	}
}
/*********************************************************************************************************************
**  void CGame::NotifyMsg_SetExchangeItem(char *pData)		(snoopy)												**
**  description			:: Recieve a msg from gserver and sets the item												**
**********************************************************************************************************************/

void helbreath::DlgBoxClick_Help()
{
	char onButton = m_dialogBoxes[35].OnButton();

	if (onButton > 0 && onButton < 16)
		DisableDialogBox(18);

	switch (onButton)
	{
		case 1:
			EnableDialogBox(18, 1000, 0, 0);
			break;
		case 2:
			EnableDialogBox(18, 900, 0, 0);
			break;
		case 3:
			EnableDialogBox(18, 901, 0, 0);
			break;
		case 4:
			EnableDialogBox(18, 902, 0, 0);
			break;
		case 5:
			EnableDialogBox(18, 903, 0, 0);
			m_bIsF1HelpWindowEnabled = true;
			break;
		case 6:
			EnableDialogBox(18, 904, 0, 0); //
			break;
		case 7:
			EnableDialogBox(18, 905, 0, 0); //
			break;
		case 8:
			EnableDialogBox(18, 906, 0, 0); //
			break;
		case 9:
			EnableDialogBox(18, 907, 0, 0); //
			break;
		case 10:
			EnableDialogBox(18, 908, 0, 0); //
			break;
		case 11:
			EnableDialogBox(18, 909, 0, 0); //
			break;
		case 12:
			EnableDialogBox(18, 910, 0, 0); //
			break;
		case 13:
			EnableDialogBox(18, 911, 0, 0); // FAQ
			break;
		case 14:
			EnableDialogBox(18, 912, 0, 0); //
			break;
		case 15:
			PlaySound('E', 14, 5);
			DisableDialogBox(35);
	}
}

void helbreath::DlgBoxClick_Mailbox()
{
	CDialogBox & dlg = m_dialogBoxes[DIALOG_MAILBOX];
	char onButton = dlg.OnButton();

	switch (dlg.GetMode())
	{
		case 0:
			if (onButton == 1)
			{
				// send mail
				if (m_dialogBoxes[DIALOG_MAILBOX].bFlag)
				{
					AddEventList(NOTIFY_MSG_HANDLER88, CHAT_GM);
					break;
				}

				if (GetItemCount("Gold") < SEND_MAIL_COST)
				{
					AddEventList(NOTIFY_MSG_HANDLER83, CHAT_GM);
					break;
				}

				ZeroMemory(dlg.cStr, sizeof(dlg.cStr)); // to
				ZeroMemory(dlg.cStr2, sizeof(dlg.cStr2)); // title
				ZeroMemory(dlg.txt, sizeof(dlg.txt)); // msg
				dlg.sV1 = -1;
				dlg.bFlag = false;
				dlg.vvec.clear(); // items
				dlg.SetMode(1);

				m_stMCursor.sX = dlg.GetButton(1).left + 1;
				m_stMCursor.sY = dlg.GetButton(1).top + 1;
				DlgBoxClick_Mailbox();
			}
			else if (onButton >= 3 && onButton < 3 + 16)
			{
				uint32_t listHit = onButton - 3 + dlg.sView;

				if (listHit >= m_mails.size())
					break;

				if (!m_mails[m_mails.size() - 1 - listHit]->msg)
					bSendCommand(MSGID_REQ_MAILDATA, 0, 0, m_mails[m_mails.size() - 1 - listHit]->id);

				dlg.sV1 = m_mails.size() - 1 - listHit;
				dlg.SetMode(2);
			}
			break;

		case 1:
			EndInputString();
			if (dlg.bFlag)
				break;

			switch (onButton)
			{
				case 1: // to:
					StartInputString(dlg.GetButton(1).left + 20, dlg.GetButton(1).top - 1, 11, dlg.cStr);
					break;

				case 2: // title:
					StartInputString(dlg.GetButton(2).left + 30, dlg.GetButton(2).top - 1, 31, dlg.cStr2);
					break;

				case 3: // msg:
					StartInputString(dlg.GetButton(3).left, dlg.GetButton(3).top + 15, sizeof(dlg.txt), dlg.txt, false, dlg.GetButton(3).right);
					break;

				case 4: // attach items:
					dlg.SetMode(3);
					break;

				case 5: // send
					if (GetItemCount("Gold") < SEND_MAIL_COST + dlg.vvec.size() * SEND_MAIL_ITEM_COST)
					{
						AddEventList(NOTIFY_MSG_HANDLER87, CHAT_GM);
						break;
					}

					bSendCommand(MSGID_REQ_SENDMAIL);
					dlg.bFlag = true;
					break;

				case 6: // cancel
					for (std::vector<MailItemSend>::iterator it = dlg.vvec.begin();
						it != dlg.vvec.end();
						++it)
					{
						m_bIsItemDisabled[(*it).index] = false;
					}
					dlg.vvec.clear();
					dlg.SetMode(0);
					break;
			}
			break;

		case 2:
			switch (onButton)
			{
				case 4: // attached items
					if (m_mails[dlg.sV1]->items.size() == 0)
						break;

					dlg.SetMode(4);
					break;

				case 5: // delete
					EnableDialogBox(DIALOG_YESNO, 1);
					break;

				case 6: // back
					dlg.sV1 = -1;
					dlg.SetMode(0);
					break;
			}
			break;

		case 3:
			if (onButton >= 1 && onButton <= 10 && onButton <= dlg.vvec.size())
			{
				// item detach
				m_bIsItemDisabled[dlg.vvec[onButton - 1].index] = false;
				dlg.vvec.erase(dlg.vvec.begin() + onButton - 1);
			}
			else if (onButton == 11)
			{
				// back
				dlg.SetMode(1);
			}
			else if (onButton == 12)
			{
				// cancel
				for (std::vector<MailItemSend>::iterator it = dlg.vvec.begin();
					it != dlg.vvec.end();
					++it)
				{
					m_bIsItemDisabled[(*it).index] = false;
				}
				dlg.vvec.clear();
				dlg.SetMode(1);
			}
			break;

		case 4:
			if (onButton == 15)
			{
				// back
				dlg.SetMode(2);
			}
			else if (onButton >= 1 && onButton <= m_mails[dlg.sV1]->items.size())
			{
				if (_iGetTotalItemNum() >= 75)
				{ // Bag Fix xRisenx
					AddEventList(DLGBOX_CLICK_BANK1, 10);
					return;
				}
				dlg.sV2 = onButton - 1;
				bSendCommand(MSGID_REQ_RETRIEVEMAILITEM);

				dlg.SetMode(5);
			}
			break;
	}
}

void helbreath::ReceiveGuildBoard(char * data)
{
	uint16_t nposts;

	Pop(data, nposts);
	for (int i = 0; i < nposts; i++)
	{
		uint32_t id;
		Pop(data, id);

		string title;
		Pop(data, title);

		string sender;
		Pop(data, sender);

		Date d;
		Pop(data, d.month);
		Pop(data, d.day);

		m_gldBoard.push_back(new Mail(id, title, sender, d));
	}
}

void helbreath::ReceiveMailbox(char * data)
{
	uint16_t nmails;

	Pop(data, nmails);
	for (int i = 0; i < nmails; i++)
	{
		uint32_t id;
		Pop(data, id);

		string title;
		Pop(data, title);

		string sender;
		Pop(data, sender);

		Date d;
		Pop(data, d.month);
		Pop(data, d.day);

		m_mails.push_back(new Mail(id, title, sender, d));
	}
}

void helbreath::ReceiveMailData(char * data)
{
	uint32_t mailid;

	Pop(data, mailid);

	int idx = -1;

	for (int i = 0; i < m_mails.size(); i++)
	{
		if (m_mails[i]->id == mailid)
		{
			idx = i;
			break;
		}
	}

	if (idx != -1 && !m_mails[idx]->msg)
	{
		m_mails[idx]->msg = new string;
		Pop(data, *m_mails[idx]->msg);
	}

	uint8_t nitems;
	Pop(data, nitems);

	for (int i = 0; i < nitems; i++)
	{
		CItem * item = new CItem;

		Pop(data, item->m_cName);
		Pop(data, item->m_dwCount);
		Pop(data, (uint8_t &)item->m_cItemType);
		Pop(data, (uint8_t &)item->m_cEquipPos);
		Pop(data, (uint16_t &)item->m_sLevelLimit);
		Pop(data, (uint8_t &)item->m_cGenderLimit);
		Pop(data, item->m_wCurLifeSpan);
		Pop(data, item->m_wWeight);
		Pop(data, (uint16_t &)item->m_sSprite);
		Pop(data, (uint16_t &)item->m_sSpriteFrame);
		Pop(data, (uint32_t &)item->m_ItemColor);
		Pop(data, (uint16_t &)item->m_sItemSpecEffectValue2);
		Pop(data, item->m_dwAttribute);
		for (int i = 0; i < MAXITEMSOCKETS; i++)
			Pop(data, item->m_sockets[i]);
		Pop(data, item->ItemUniqueID);

		item->m_sX = 40;
		item->m_sY = 30;

		m_mails[idx]->items.push_back(item);
	}
}

void helbreath::ReceiveGuildBoardPost(char * data)
{
	uint32_t mailid;

	Pop(data, mailid);

	int idx = -1;

	for (int i = 0; i < m_gldBoard.size(); i++)
	{
		if (m_gldBoard[i]->id == mailid)
		{
			idx = i;
			break;
		}
	}

	if (idx != -1 && !m_gldBoard[idx]->msg)
	{
		m_gldBoard[idx]->msg = new string;
		Pop(data, *m_gldBoard[idx]->msg);
	}
}

void helbreath::CreateScreenShot()
{
    int i;
    FILE * pFile;
    char cFn[256];
    char ServerName[128];
    char SStime[32], SStime2[32], SStime3[32]; // Added SStime2,3 xRisenx
    SYSTEMTIME SysTime;                        // Added New Details xRisenx
    GetLocalTime(&SysTime);
    ZeroMemory(ServerName, sizeof(ServerName));
    ZeroMemory(SStime, sizeof(SStime));

    fmt::format_to(SStime, "Helbreath Xtreme");
    fmt::format_to(SStime2, "%02d / %02d / %02d", SysTime.wMonth, SysTime.wDay, SysTime.wYear);
    fmt::format_to(SStime3, "%02d : %02d : %02d", SysTime.wHour, SysTime.wMinute, SysTime.wSecond);

    time_t t = time(0); // get time now
    struct tm * now = localtime(&t);

    //driver->beginScene(false, false);
    // 	PutAlignedString(GetWidth()-180, GetWidth(), 10, SStime, Color(255,255, 255, 255)); //ScreenShot time
    // 	PutAlignedString(GetWidth()-180, GetWidth(), 30, SStime2, Color(255,255, 255, 255)); //ScreenShot time
    // 	PutAlignedString(GetWidth()-180, GetWidth(), 50, SStime3, Color(255,255, 255, 255)); //ScreenShot time
    _text.setFont(_font.at("default"));
    _text.setString(SStime);
    _text.setFillColor(sf::Color::White);
    sf::FloatRect bounds = _text.getLocalBounds();
    _text.setPosition(float(GetWidth() - 180), 10);
    _text.setCharacterSize(12);

    sf::Texture tex;
    sf::RenderTexture rtex;
    tex.create(window.getSize().x, window.getSize().y);
    rtex.create(window.getSize().x, window.getSize().y);
    tex.update(window);

    sf::Sprite sprite;
    sprite.setTexture(tex);

    rtex.draw(sprite);
    rtex.draw(_text);
    _text.setString(SStime2);
    _text.setPosition(float(GetWidth() - 180), 30);
    rtex.draw(_text);
    _text.setString(SStime3);
    _text.setPosition(float(GetWidth() - 180), 50);
    rtex.draw(_text);

    //PutAlignedString(GetWidth() - 180, GetWidth(), GetHeight()-50, ss.str(), Color(255, 255, 255, 255)); //ScreenShot time
    //driver->endScene();
    //IImage * screenshot = driver->createScreenShot();

    _mkdir("screenshots");
    for (i = 0; i < 1000; i++)
    {
        ZeroMemory(cFn, sizeof(cFn));
        char tempstr[300];
        fmt::format_to(tempstr, "screenshots\\HelShot%04d%02d%02d_%02d%02d%02d.jpg",
            (now->tm_year + 1900), (now->tm_mon + 1), now->tm_mday,
            now->tm_hour, now->tm_min, now->tm_sec);
        fmt::format_to(cFn, "screenshots\\HelShot%04d%02d%02d_%02d%02d%02d.jpg",
            (now->tm_year + 1900), (now->tm_mon + 1), now->tm_mday,
            now->tm_hour, now->tm_min, now->tm_sec);
        //		   fmt::format_to(cFn, "SAVE\\Helbreath Xtreme SS #%d.bmp", i);

        if (_access(cFn, 0) == -1)
        {

            sf::Image img = rtex.getTexture().copyToImage();
            img.flipVertically();
            img.saveToFile(tempstr);

            fmt::format_to(G_cTxt, NOTIFYMSG_CREATE_SCREENSHOT1, cFn);
            AddEventList(G_cTxt, 10);
            return;
        }
    }
    AddEventList(NOTIFYMSG_CREATE_SCREENSHOT2, 10);
}

void helbreath::ReserveFightzoneResponseHandler(char * pData)
{
	uint16_t * wpResult;
	char * cp;
	int * ip;
	wpResult = (uint16_t *)(pData + INDEX2_MSGTYPE);
	switch (*wpResult)
	{
		case MSGTYPE_CONFIRM:
			AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER1, 10);
			m_dialogBoxes[7].SetMode(14);
			m_iFightzoneNumber = m_iFightzoneNumberTemp;
			break;

		case MSGTYPE_REJECT:
			cp = (char *)(pData + INDEX2_MSGTYPE + 2);
			ip = (int *)cp;
			cp += 4;
			AddEventList(RESERVE_FIGHTZONE_RESPONSE_HANDLER2, 10);
			m_iFightzoneNumberTemp = 0;

			if (*ip == 0)
			{
				m_dialogBoxes[7].SetMode(15);
			}
			else if (*ip == -1)
			{
				m_dialogBoxes[7].SetMode(16);
			}
			else if (*ip == -2)
			{
				m_dialogBoxes[7].SetMode(17);
			}
			else if (*ip == -3)
			{
				m_dialogBoxes[7].SetMode(21);
			}
			else if (*ip == -4)
			{
				m_dialogBoxes[7].SetMode(22);
			}
			break;
	}
}

void helbreath::RetrieveItemHandler(char * pData)
{
	char * cp, /*cBankItemIndex,*/ cItemIndex, cTxt[120];
	short cBankItemIndex;
	uint16_t * wp;
	int j;

	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	if (*wp != MSGTYPE_REJECT)
	{
		cp = (char *)(pData + INDEX2_MSGTYPE + 2);
		cBankItemIndex = *cp;
		cp++;
		cItemIndex = *cp;
		cp++;

		if (m_pBankList[cBankItemIndex] != 0)
		{

			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pBankList[cBankItemIndex], cStr1, cStr2, cStr3);

			ZeroMemory(cTxt, sizeof(cTxt));
			fmt::format_to(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//""You took out %s."
			AddEventList(cTxt, 10);

			if (m_pBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_CONSUME ||
				m_pBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_ARROW)
			{
				if (!m_pItemList[cItemIndex]) goto RIH_STEP2;
				delete m_pBankList[cBankItemIndex];
				m_pBankList[cBankItemIndex] = 0;

				for (j = 0; j < MAXBANKITEMS - 1; j++)
				{
					if (m_pBankList[j + 1] && !m_pBankList[j])
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
			else
			{
				RIH_STEP2:;
				if (m_pItemList[cItemIndex]) return;
				short nX, nY;
				nX = 40;
				nY = 30;
				for (j = 0; j < MAXITEMS; j++)
				{
					if (m_pItemList[j] && memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0)
					{
						nX = m_pItemList[j]->m_sX + 1;
						nY = m_pItemList[j]->m_sY + 1;
						break;
					}
				}
				m_pItemList[cItemIndex] = m_pBankList[cBankItemIndex];
				m_pItemList[cItemIndex]->m_sX = nX;
				m_pItemList[cItemIndex]->m_sY = nY;
				bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemIndex, nX, nY, 0, 0);

				for (j = 0; j < MAXITEMS; j++)
					if (m_cItemOrder[j] == -1)
					{
						m_cItemOrder[j] = cItemIndex;
						break;
					}
				m_bIsItemEquipped[cItemIndex] = false;
				m_bIsItemDisabled[cItemIndex] = false;
				m_pBankList[cBankItemIndex] = 0;
				for (j = 0; j < MAXBANKITEMS - 1; j++)
				{
					if ((m_pBankList[j + 1] != 0) && (m_pBankList[j] == 0))
					{
						m_pBankList[j] = m_pBankList[j + 1];
						m_pBankList[j + 1] = 0;
					}
				}
			}
		}
	}
	m_dialogBoxes[14].SetMode(0);
}

void helbreath::EraseItem(char cItemID)
{
	int i;
	char cStr1[64], cStr2[64], cStr3[64];
	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));
	for (i = 0; i < 6; i++)
	{
		if (m_sShortCut[i] == cItemID)
		{
			GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
			if (i < 3) fmt::format_to(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 1);
			else fmt::format_to(G_cTxt, ERASE_ITEM, cStr1, cStr2, cStr3, i + 7);
			AddEventList(G_cTxt, 10);
			m_sShortCut[i] = -1;
		}
	}

	if (cItemID == m_sRecentShortCut)
		m_sRecentShortCut = -1;
	// ItemOrder
	for (i = 0; i < MAXITEMS; i++)
		if (m_cItemOrder[i] == cItemID)
			m_cItemOrder[i] = -1;
	for (i = 1; i < MAXITEMS; i++)
		if ((m_cItemOrder[i - 1] == -1) && (m_cItemOrder[i] != -1))
		{
			m_cItemOrder[i - 1] = m_cItemOrder[i];
			m_cItemOrder[i] = -1;
		}
	// ItemList
	delete m_pItemList[cItemID];
	m_pItemList[cItemID] = 0;
	m_bIsItemEquipped[cItemID] = false;
	m_bIsItemDisabled[cItemID] = false;
	_iCalcTotalWeight();
}

void helbreath::DlgBoxDoubleClick_Character()
{
	char cEquipPoiStatus[MAXITEMEQUIPPOS], cItemID = -1;
	short sX, sY, sSprH, sFrame;
	int i;
	if (m_bIsDialogEnabled[17] == true) return;

	short msX = m_stMCursor.sX;
	short msY = m_stMCursor.sY;

	sX = m_dialogBoxes[1].m_X;
	sY = m_dialogBoxes[1].m_Y;

	for (i = 0; i < MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 41, sY + 137, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 100, sY + 185, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_HEAD];
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 45, sY + 143, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BACK];
		}
		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_PANTS];
		}
		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_ARMS];
		}
		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BOOTS];
		}
		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_BODY];
		}
		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_FULLBODY];
		}
		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 84, sY + 175, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_LHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_RHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_TWOHAND];
		}
		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 35, sY + 120, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_NECK];
		}
		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 32, sY + 193, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_RFINGER];
		}
		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 100, sY + 185, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_LFINGER];
		}
		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 72, sY + 139, sFrame, msX, msY))
				cItemID = cEquipPoiStatus[EQUIPPOS_HEAD];
		}
	}

	if (cItemID == -1 || m_pItemList[cItemID] == 0) return;
	if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_EAT) || (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_ARROW) || (m_pItemList[cItemID]->m_dwCount > 1)) return;
	if ((m_bIsDialogEnabled[11] == true) && (m_bIsDialogEnabled[23] == false) && (m_dialogBoxes[39].sV3 == 24))
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_REPAIRITEM, 0, cItemID, m_dialogBoxes[39].sV3, 0, m_pItemList[cItemID]->m_cName, m_dialogBoxes[39].sV4);
	else
	{
		if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
		{
			char cStr1[64], cStr2[64], cStr3[64];
			GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
			ZeroMemory(G_cTxt, sizeof(G_cTxt));
			fmt::format_to(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);//"
			AddEventList(G_cTxt, 10);
			if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
			else PlaySound('E', 29, 0);

			// Remove Angelic Stats
			if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
				&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
			{
				char cItemID = m_stMCursor.sSelectedObjectID;
				if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(STR)", 19) == 0)
				{
					m_angelStat[STAT_STR] = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(DEX)", 19) == 0)
				{
					m_angelStat[STAT_DEX] = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(INT)", 19) == 0)
				{
					m_angelStat[STAT_INT] = 0;
				}
				else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(MAG)", 19) == 0)
				{
					m_angelStat[STAT_MAG] = 0;
				}
			}
			bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
			m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
			m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
			m_stMCursor.cSelectedObjectType = 0;
			m_stMCursor.sSelectedObjectID = 0;
		}
	}
}

void helbreath::AddMapPing(MapPing ping)
{
	PlaySound('E', 14, 5);
	m_mapPings.push_back(ping);
}

Point helbreath::GetGuideMapPos(uint32_t x, uint32_t y)
{
	Point p;
	short sX = m_dialogBoxes[9].m_X;
	short sY = m_dialogBoxes[9].m_Y;
	short szX = m_dialogBoxes[9].sSizeX;
	short szY = m_dialogBoxes[9].sSizeY;

	if (sX < 20) sX = 0;
	if (sY < 20) sY = 0;
	//if( sX > 640-128-20 ) sX = 640-128;
	if (sX > GetWidth() - 128 - 20) sX = GetWidth() - 128; // 800x600 Resolution xRisenx
	//if( sY > 427-128-20 ) sY = 427-128;
	if (sY > GetHeight() - 53 - 128 - 20) sY = GetHeight() - 53 - 128; // 800x600 Resolution xRisenx
	if (m_bZoomMap)
	{
		p.x = m_sPlayerX - 64;
		p.y = m_sPlayerY - 64;
		if (p.x < 0) p.x = 0;
		if (p.y < 0) p.y = 0;
		if (p.x > m_pMapData->m_sMapSizeX - 128) p.x = m_pMapData->m_sMapSizeX - 128;
		if (p.y > m_pMapData->m_sMapSizeY - 128) p.y = m_pMapData->m_sMapSizeY - 128;
		p.x = p.x + x - sX;
		p.y = p.y + y - sY;
	}
	else
	{
		p.x = (m_pMapData->m_sMapSizeX * (x - sX)) / 128;
		p.y = (m_pMapData->m_sMapSizeX * (y - sY)) / 128;
	}

	return p;
}

void helbreath::DlgBoxDoubleClick_GuideMap()
{
	short si = m_stMCursor.sCursorFrame;
	if (si != 0) return;
	if (m_cMapIndex < 0) return;

	Point p = GetGuideMapPos(m_stMCursor.sX, m_stMCursor.sY);

	if (p.x < 20 || p.y < 20) return;
	if (p.x > m_pMapData->m_sMapSizeX - 20 || p.y > m_pMapData->m_sMapSizeY - 20) return;
	m_sCommX = p.x;
	m_sCommY = p.y;

	if (m_bCtrlPressed)
	{
		fmt::format_to(G_cTxt, "/tp %s %u %u", m_cMapName, m_sCommX, m_sCommY);
		bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, G_cTxt);
		return;
	}

	if (m_bRunningMode && m_iSP > 0)
		m_cCommand = OBJECTRUN;
	else m_cCommand = OBJECTMOVE;
	GetPlayerTurn();
}

void helbreath::DlgBoxClick_SysMenu()
{
	char onButton = m_dialogBoxes[19].OnButton();
	switch (onButton)
	{
		case 1:
			m_cDetailLevel = 0;
			AddEventList(NOTIFY_MSG_DETAIL_LEVEL_LOW, 10);
			PlaySound('E', 14, 5);
			break;
		case 2:
			m_cDetailLevel = 1;
			AddEventList(NOTIFY_MSG_DETAIL_LEVEL_MEDIUM, 10);
			PlaySound('E', 14, 5);
			break;
		case 3:
			m_cDetailLevel = 2;
			AddEventList(NOTIFY_MSG_DETAIL_LEVEL_HIGH, 10);
			PlaySound('E', 14, 5);
			break;
		case 4:
			if (m_bSoundFlag)
			{
				if (m_bSoundStat == true)
				{
					//DIRECTXm_pESound[38]->bStop();
					m_bSoundStat = false;
					AddEventList(NOTIFY_MSG_SOUND_OFF, 10);
				}
				else
				{
					m_bSoundStat = true;
					AddEventList(NOTIFY_MSG_SOUND_ON, 10);
				}
			}
			break;
		case 5:
			if (m_bSoundFlag)
			{
				if (m_bMusicStat == true) 	// Music Off
				{
					m_bMusicStat = false;
					AddEventList(NOTIFY_MSG_MUSIC_OFF, 10);
					if (m_bSoundFlag)
					{
						// 					if (m_pBGM != NULL)
						// 					{
						// 						m_pBGM->bStop();
						// 						delete m_pBGM;
						// 						m_pBGM = NULL;
						// 					}//DIRECTX
					}
				}
				else // Music On
				{
					if (m_bSoundFlag)
					{
						m_bMusicStat = true;
						AddEventList(NOTIFY_MSG_MUSIC_ON, 10);
						StartBGM();
					}
				}
			}
			break;
		case 6:
			if (m_bWhisper == true)
			{
				m_bWhisper = false;
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10);
			}
			else
			{
				m_bWhisper = true;
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10);
			}
			break;
		case 7:
			if (m_bShout == true)
			{
				m_bShout = false;
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10);
			}
			else
			{
				m_bShout = true;
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10);
			}
			break;
		case 8://Transparency Change
			m_bDialogTrans = !m_bDialogTrans;
			break;
		case 9:
			if (m_bIsDialogEnabled[9]) DisableDialogBox(9);//Guide Map Toggle
			else EnableDialogBox(9, 0, 0, 0, 0);
			break;
		case 14:
			if (m_bIsDialogEnabled[59]) DisableDialogBox(59);
			else EnableDialogBox(59, 0, 0, 0, 0);
			break;
	}

	if (m_bForceDisconn) return;

	switch (onButton)
	{
		case 10:
			if (!m_bSkillUsingStatus)
			{
				if (m_cLogOutCount == -1)

#ifdef _DEBUG
					m_cLogOutCount = 1;
#else
					m_cLogOutCount = 11;
#endif
				else
				{
					m_cLogOutCount = -1;
					AddEventList(DLGBOX_CLICK_SYSMENU2, 10);
					DisableDialogBox(19);
				}
				PlaySound('E', 14, 5);
			}
			else
			{
				AddEventList(SKILL_LOGOUT, 10);
				DisableDialogBox(19);
			}
			break;
		case 11:
			if ((m_iHP <= 0) && (m_cRestartCount == -1))
			{
				m_cRestartCount = 5;
				m_dwRestartCountTime = unixtime();
				DisableDialogBox(19);
				fmt::format_to(G_cTxt, DLGBOX_CLICK_SYSMENU1, m_cRestartCount); // "Restarting game....%d"
				AddEventList(G_cTxt, 10);
				PlaySound('E', 14, 5);
			}
			break;
	}
}

void helbreath::DrawNpcName(short sX, short sY, short sOwnerType, int iStatus)
{
	char cTxt[42], cTxt2[64];
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	int iAdd = 0;
#ifdef MonsterDetails
	int iNameLength = 0;
#endif

	GetNpcName(sOwnerType, cTxt);

	if ((iStatus & STATUS_BERSERK) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & STATUS_FROZEN) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"
	PutString2(sX, sY, cTxt, 255, 255, 255);

	iAdd += 14;

#ifdef MonsterDetails
	iNameLength = sizeof(cTxt);

	//PutString2(sX + (iNameLength * 2), sY, "Test Text", 255,255,255);

	//iAdd += 14;

	switch (sOwnerType)
	{
		case 10: // slime
		//case 97: // slime king
		//case 98: // slime prince
			PutString2(sX, sY + iAdd, "Slime-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 31: // demon
		//case 95: // black demon
		case 49: // hellclaw
		case 27: // hellhound
		case 48: // Stalker
		case 62: // Dire Boar
		case 71: // Centaurus
		case 78: // Minotaur
			PutString2(sX, sY + iAdd, "Demon-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 66: // wyvern
		case 70: // barlog
		case 73: // fire wyvern
		case 114: // Eternal Dragon
			PutString2(sX, sY + iAdd, "Dragon-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 14: // Orc / Magic Orc
		case 77: // Master Mage Orc
			PutString2(sX, sY + iAdd, "Orc-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 12: // stone golem
		case 23: // clay golem
		case 65: // ice golem
			PutString2(sX, sY + iAdd, "Golem-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 60: // Cannibal plant
		case 76: // giant plant
		case 80: // tentocle
			PutString2(sX, sY + iAdd, "Plant-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 13: // cyclops
		case 29: // ogre
		case 59: // ettin
		case 58: // mountain giant
		case 16: // Giant Ant
		case 57: // Giant Frog
		case 17: // Giant Scorpion
		case 74: // Giant Crayfish
		case 75: // Giant Lizard
		case 81: // Abby
		case 72: // claw-turtle
			PutString2(sX, sY + iAdd, "Giant-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 18: // zombie
		case 11: // skeleton
		case 30: // liche
		case 33: // Werewolf
		case 54: // Dark-Elf
		case 52: // Gargoyle
			PutString2(sX, sY + iAdd, "Undead-Type", 130, 130, 130);
			iAdd += 14;
			break;
		case 61: // Rudolph
		case 63: // Frost
		case 53: // Beholder
		case 79: // Nizie
		case 32: // Unicorn
		case 56: // Cat
		case 55: // Rabbit
		case 50: // Tigerworm
			PutString2(sX, sY + iAdd, "Mystic-Type", 130, 130, 130);
			iAdd += 14;
			break;
	}
#endif

	if (m_bIsObserverMode == true) PutString2(sX, sY + iAdd, cTxt, 50, 50, 255);
	else if (m_bIsConfusion || (m_iIlusionOwnerH != 0))
	{
		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy(cTxt, DRAW_OBJECT_NAME87);
		PutString2(sX, sY + iAdd, cTxt, 150, 150, 150);
	}
	else
	{
		switch (_iGetFOE(iStatus))
		{
			case -2:
				PutString2(sX, sY + iAdd, DRAW_OBJECT_NAME90, 255, 0, 0);
				break;
			case -1:
				PutString2(sX, sY + iAdd, DRAW_OBJECT_NAME90, 255, 0, 0);
				break;
			case 0:
				PutString2(sX, sY + iAdd, DRAW_OBJECT_NAME88, 50, 50, 255);
				break;
			case 1:
				PutString2(sX, sY + iAdd, DRAW_OBJECT_NAME89, 30, 255, 30);
				break;
		}
	}

#ifdef MonsterDetails
	//iAdd += 14;
#endif

	iAdd += 14;

	switch ((iStatus & 0x0F00) >> 8)
	{
		case 0: break;
		case 1: strcpy(cTxt2, DRAW_OBJECT_NAME52); break;//"Clairvoyant"
		case 2: strcpy(cTxt2, DRAW_OBJECT_NAME53); break;//"Destruction of Magic Protection"
		case 3: strcpy(cTxt2, DRAW_OBJECT_NAME54); break;//"Anti-Physical Damage"
		case 4: strcpy(cTxt2, DRAW_OBJECT_NAME55); break;//"Anti-Magic Damage"
		case 5: strcpy(cTxt2, DRAW_OBJECT_NAME56); break;//"Poisonous"
		case 6: strcpy(cTxt2, DRAW_OBJECT_NAME57); break;//"Critical Poisonous"
		case 7: strcpy(cTxt2, DRAW_OBJECT_NAME58); break;//"Explosive"
		case 8: strcpy(cTxt2, DRAW_OBJECT_NAME59); break;//"Critical Explosive"
		case 9: strcpy(cTxt2, DRAW_OBJECT_NAME59B); break;//"Highly Trained"
		case 10: strcpy(cTxt2, DRAW_OBJECT_NAME59G); break;//"Elite"
		case 11: strcpy(cTxt2, DRAW_OBJECT_NAME59D); break;//"Mighty"
		case 12: strcpy(cTxt2, DRAW_OBJECT_NAME59E); break;//"Crippled"
		case 13: strcpy(cTxt2, DRAW_OBJECT_NAME59F); break;//"Shaman"
		case 14: strcpy(cTxt2, DRAW_OBJECT_NAME59C); break;//"Swift"
	}
	if (m_Misc.bCheckIMEString(cTxt2)) PutString_SprFont3(sX, sY + iAdd, cTxt2, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
	else PutString2(sX, sY + iAdd, cTxt2, 240, 240, 70);

#ifdef _DEBUG
	fmt::format_to(G_cTxt, "Status: 0x%.8X ", iStatus);
	PutString2(sX + 70, sY + (14 * 0), G_cTxt, 30, 255, 30);
#endif
}

void helbreath::DrawObjectName(short sX, short sY, char * pName, int iStatus)
{
	char cTxt[64], cTxt2[64];
	short sR, sG, sB;
	int i, iGuildIndex, iFOE, iAddY = 0;
	bool bPK;

	iFOE = _iGetFOE(iStatus);
	Side side = (Side)((iStatus & STATUS_SIDE) >> 28);
	if (iFOE < 0)
	{
		sR = 255; sG = 0; sB = 0;
	}
	else if (iFOE == 0)
	{
		sR = 50; sG = 50; sB = 255;
	}
	else
	{
		sR = 30; sG = 200; sB = 30;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTxt2, sizeof(cTxt2));

	if (m_iIlusionOwnerH == 0)
	{
		if (m_bIsCrusadeMode && m_adminLevel == 0)
		{
			if (_tmp_wObjectID >= 10000) strcpy(cTxt, NPC_NAME_MERCENARY);
			else
			{
				if (iFOE == -1) fmt::format_to(cTxt, "%d", _tmp_wObjectID);
				else strcpy(cTxt, pName);
			}
		}
		else
		{
			fmt::format_to(cTxt, "%s", pName);
		}

		if (m_iPartyStatus)
		{
			for (i = 0; i < m_stPartyMember.size(); i++)
			{
				if (m_stPartyMember[i]->cName.compare(pName) == 0)
				{
					strcat(cTxt, BGET_NPC_NAME23);
					break;
				}
			}
		}
	}
	else strcpy(cTxt, "?????");

	if ((iStatus & STATUS_BERSERK) != 0) strcat(cTxt, DRAW_OBJECT_NAME50);//" Berserk"
	if ((iStatus & STATUS_FROZEN) != 0) strcat(cTxt, DRAW_OBJECT_NAME51);//" Frozen"

	PutString2(sX, sY, cTxt, 255, 255, 255);
	ZeroMemory(cTxt, sizeof(cTxt));

	if (player_name == pName)
	{
		if (m_iGuildRank != GUILDRANK_NONE)
		{
			fmt::format_to(G_cTxt, "%s %s", m_cGuildName, GetGuildRankName(m_iGuildRank));
			PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
			iAddY = 14;
		}
		if (m_iPKCount != 0)
		{
			bPK = true;
			//sR = 255; sG = 0; sB = 0;
		}
		else
		{
			bPK = false;
			//sR = 30; sG = 200; sB = 30;
		}

		side = m_side;
	}
	else
	{
		side = (Side)((iStatus & STATUS_SIDE) >> 28);

		if (iStatus & STATUS_PK) bPK = true;
		else bPK = false;

		if ((m_bIsCrusadeMode == false || iFOE >= 0) && m_iIlusionOwnerH == 0)
		{
			if (FindGuildName(pName, &iGuildIndex) == true)
			{
				if (m_stGuildName[iGuildIndex].cGuildName[0] != 0)
				{
					if (strcmp(m_stGuildName[iGuildIndex].cGuildName, "NONE") != 0)
					{
						if (m_stGuildName[iGuildIndex].iGuildRank != GUILDRANK_NONE)
						{
							fmt::format_to(G_cTxt, "%s %s", m_stGuildName[iGuildIndex].cGuildName,
								GetGuildRankName(m_stGuildName[iGuildIndex].iGuildRank));
							PutString2(sX, sY + 14, G_cTxt, 180, 180, 180);
							m_stGuildName[iGuildIndex].dwRefTime = m_dwCurTime;
							iAddY = 14;
						}
					}
					else
					{
						m_stGuildName[iGuildIndex].dwRefTime = 0;
					}
				}
			}
			else bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQGUILDNAME, 0, _tmp_wObjectID, iGuildIndex, 0, 0);
		}
	}

	strcpy(cTxt, sideName[side]);

	if (side != NEUTRAL && !bPK)
		strcat(cTxt, MSG_COMBATANT);

	if (bPK)
		strcat(cTxt, MSG_PK);

	PutString2(sX, sY + 14 + iAddY, cTxt, sR, sG, sB);

	iAddY += 14;
	// Owner Rank
	if (strcmp(pName, "xRisenx") == 0)
	{
		sR = 255; sG = 153; sB = 0;
		strcpy(cTxt, "Owner");

		PutString2(sX, sY + 14 + iAddY, cTxt, sR, sG, sB);

		iAddY += 14;
	}
	// GM Helper Rank
	if (strcmp(pName, "ShadowWarr") == 0 || strcmp(pName, "ShadowEvil") == 0 ||
		strcmp(pName, "Cracka") == 0 || strcmp(pName, "dub") == 0)
	{
		sR = 255; sG = 153; sB = 0;
		strcpy(cTxt, "GM Helper");

		PutString2(sX, sY + 14 + iAddY, cTxt, sR, sG, sB);

		iAddY += 14;
	}

#ifdef TitleClient
	//iAddY += 14;

	int iTitleIndex;
	if (FindTitleName(pName, &iTitleIndex) == true)
	{
		if (m_stTitles[iTitleIndex].cSubject[0] != 0)
		{//BESK: maybe we should be using strlen here instead of checking the first char for nonzero value?
			if (strcmp(m_stTitles[iTitleIndex].cSubject, "NONE") != 0)
			{
				GetTitleName(m_stTitles[iTitleIndex].cSubject, m_stTitles[iTitleIndex].iRank, cTxt);
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				fmt::format_to(G_cTxt, "%s", cTxt);
				PutString2(sX, sY + 14 + iAddY, G_cTxt, 255, 255, 204);
				m_stTitles[iTitleIndex].dwRefTime = m_dwCurTime;
				iAddY += 14;
			}
			if ((m_bIsCrusadeMode == true))
			{
				ZeroMemory(G_cTxt, sizeof(G_cTxt));
				switch (m_stTitles[iTitleIndex].iCrusadeT)
				{
					case 1: fmt::format_to(G_cTxt, "Soldier"); break;
					case 2: fmt::format_to(G_cTxt, "Constructor"); break;
					case 3: fmt::format_to(G_cTxt, "Commander"); break;
					default: ZeroMemory(G_cTxt, sizeof(G_cTxt)); break;
				}
				PutString2(sX, sY + 14 + iAddY, G_cTxt, 0, 200, 200);
				iAddY += 14;
			}
			//else if (_tmp_cFlag == 30 || _tmp_cFlag == 31) {
			//
			//	fmt::format_to(G_cTxt, "Flag Carrier");
			//	PutString2(sX, sY+14 +iAddY, G_cTxt, 0,200,200);
			//	iAddY += 14;
			//}
			//else if (_tmp_cFlag > 0 && _tmp_cFlag <= 20)
			//{
			//	if (_tmp_cFlag > 0 && _tmp_cFlag < 5)
			//		fmt::format_to(G_cTxt, "Wanted (1)");
			//	else if (_tmp_cFlag >= 5 && _tmp_cFlag < 10)
			//		fmt::format_to(G_cTxt, "Wanted (2)");
			//	else if (_tmp_cFlag >= 10 && _tmp_cFlag < 15)
			//		fmt::format_to(G_cTxt, "Wanted (3)");
			//	else if (_tmp_cFlag >= 15 && _tmp_cFlag < 20)
			//		fmt::format_to(G_cTxt, "Wanted (4)");
			//	else if (_tmp_cFlag == 20)
			//		fmt::format_to(G_cTxt, "Wanted (5)");
			//	PutString2(sX, sY+14 +iAddY, G_cTxt, 0,200,200);
			//	iAddY += 14;
			//}
		}
	}
	else
	{
		//AddEventList("request title", 10);
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQTITLE, 0, _tmp_wObjectID, iTitleIndex, 0, 0);
	}
#endif

	//if(strcpy(m_cMapName, ARENAMAP) == 0)
	//{
	//   strcpy(cTxt, "Enemy");
	//   PutString2(sX, sY+14 +iAddY, cTxt, 255, 0, 0);
	//}
	//else
	//{
	//   PutString2(sX, sY+14 +iAddY, cTxt, sR, sG, sB);
	//   iAddY += 14;
	//}
	// Add m_adminLevel
	/*if(m_adminLevel == 1)
	{
		sR = 0;
		sG = 255;
		sB = 115;
		strcpy(cTxt, "GM Helper");
		PutString2(sX, sY+14 +iAddY, cTxt, sR, sG, sB);
		iAddY += 14;
	}*/

#ifdef _DEBUG
	fmt::format_to(G_cTxt, "Status: 0x%.8X ", iStatus);
	PutString2(sX + 70, sY + (14 * 0), G_cTxt, 30, 255, 30);
#endif
}

bool helbreath::FindGuildName(char * pName, int * ipIndex)
{
	int i, iRet = 0;
	uint32_t dwTmpTime;
	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		if (memcmp(m_stGuildName[i].cCharName, pName, 10) == 0)
		{
			m_stGuildName[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return true;
		}
	}
	dwTmpTime = m_stGuildName[0].dwRefTime;
	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		if (m_stGuildName[i].dwRefTime < dwTmpTime)
		{
			iRet = i;
			dwTmpTime = m_stGuildName[i].dwRefTime;
		}
	}
	ZeroMemory(m_stGuildName[iRet].cGuildName, sizeof(m_stGuildName[iRet].cGuildName));
	memcpy(m_stGuildName[iRet].cCharName, pName, 10);
	m_stGuildName[iRet].dwRefTime = m_dwCurTime;
	m_stGuildName[iRet].iGuildRank = -1;
	*ipIndex = iRet;
	return false;
}

void helbreath::DrawVersion(bool bAuthor)
{
	uint64_t dwTime = unixtime();
	uint16_t  wR, wG, wB;

	//	m_Misc.ColorTransfer(//DIRECTX m_DDraw.m_cPixelFormat,Color(255,140, 140, 140), &wR, &wG, &wB);

	m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(12, GetHeight() - 74, 19, wR, wG, wB, dwTime); // Added +120 to support 800x600 Resolution xRisenx
	// Upper Version
	/*fmt::format_to(G_cTxt, "%d", UPPER_VERSION);
	PutString_SprNum(36, 463, G_cTxt, 140, 140, 140);*/
	fmt::format_to(G_cTxt, "%d", UPPER_VERSION);
	PutString_SprNum(34, 463 + 63, G_cTxt, 140, 140, 140);
	// .
	m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(40, GetHeight() - 74, 18, wR, wG, wB, dwTime); // Added +120 to support 800x600 Resolution xRisenx
	// Lower Version
	/*fmt::format_to(G_cTxt, "%d", LOWER_VERSION);
	PutString_SprNum(46, 463, G_cTxt, 140, 140, 140);*/
	fmt::format_to(G_cTxt, "%d%d", LOWER_VERSION, PATCH_VERSION);
	PutString_SprNum(44, 463 + 63, G_cTxt, 140, 140, 140);
	if (bAuthor == false) return;
}

char helbreath::GetOfficialMapName(char const * const pMapName, char * pName)
{	// MapIndex
	if (strcmp(pMapName, "middleland") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME28);	// Middleland
		return 4;
	}
	else if (strcmp(pMapName, "huntzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME31);	// Death Valley
		return 0;
	}
	else if (strcmp(pMapName, "huntzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME29);	// Rocky Highland
		return 1;
	}
	else if (strcmp(pMapName, "elvuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME57);	// Eldiniel Garden
		return 2;
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME24);	// Elvine City
		return 3;
	}
	else if (strcmp(pMapName, "elvfarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME2);	// Elvine Farm
		return 5;
	}
	else if (strcmp(pMapName, "arefarm") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME1);	// Aresden Farm
		return 6;
	}
	else if (strcmp(pMapName, "default") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME3);	// Beginner Zone
		return 7;
	}
	else if (strcmp(pMapName, "huntzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME32);	// Silent Wood
		return 8;
	}
	else if (strcmp(pMapName, "huntzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME30);	// Eternal Field
		return 9;
	}
	else if (strcmp(pMapName, "areuni") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME56);	// Aresien Garden
		return 10;
	}
	else if (strcmp(pMapName, "aresden") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME22);	// Aresden City
		return 11;
	}
	else if (strcmp(pMapName, "dglv2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME25);	// Dungeon L2
		return 12;
	}
	else if (strcmp(pMapName, "dglv3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME26);	// Dungeon L3
		return 13;
	}
	else if (strcmp(pMapName, "dglv4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME53);	// Dungeon L4
		return 14;
	}
	else if (strcmp(pMapName, "elvined1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME23);	// Elvine Dungeon
		return 15;
	}
	else if (strcmp(pMapName, "aresdend1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME21);	// Aresden Dungeon
		return 16;
	}
	else if (strcmp(pMapName, "bisle") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME27);	// Bleeding Island
		return 17;
	}
	else if (strcmp(pMapName, "toh1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME60);	// Tower of Hell 1
		return 18;
	}
	else if (strcmp(pMapName, "toh2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME61);	// Tower of Hell 2
		return 19;
	}
	else if (strcmp(pMapName, "toh3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME62);	// Tower of Hell 3
		return 20;
	}
	else if (strcmp(pMapName, "middled1x") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME58);	// Middleland Mine
		return 21;
	}
	else if (strcmp(pMapName, "middled1n") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME59);	// Middleland Dungeon
		return 22;
	}
	else if (strcmp(pMapName, "2ndmiddle") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME65);	// Promiseland
		return 23;
	}
	else if (strcmp(pMapName, "icebound") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME66);	// Ice Map
		return 24;
		// Snoopy:
	}
	else if (strcmp(pMapName, "druncncity") == 0) // Snoopy: Apocalypse maps
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME70);
		return 25;
	}
	else if (strcmp(pMapName, "inferniaA") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME71);
		return 26;
	}
	else if (strcmp(pMapName, "inferniaB") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME72);
		return 27;
	}
	else if (strcmp(pMapName, "maze") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME73);
		return -1; //28;
	}
	else if (strcmp(pMapName, "procella") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME74);
		return 29;
	}
	else if (strcmp(pMapName, "abaddon") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME75);
		return 30;
	}
	else if (strcmp(pMapName, "BtField") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME76);
		return 35;
	}
	else if (strcmp(pMapName, "GodH") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME77);
		return 36;
	}
	else if (strcmp(pMapName, "HRampart") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME78);
		return 37;
	}
	else if (strcmp(pMapName, "cityhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME35);	// Aresden Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "cityhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME36);	// Elvine Cityhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME37);	// Aresden Guildhall
		return -1;
	}
	else if (strcmp(pMapName, "gldhall_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME38);	// Elvine Guildhall
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_1", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME33);	// Aresden Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "bsmith_2", 8) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME34);	// Elvine Blacksmith
		return -1;
	}
	else if (memcmp(pMapName, "gshop_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME39);	// Aresden Shop
		return -1;
	}
	else if (memcmp(pMapName, "gshop_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME40);	// Elvine Shop
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_1", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME43);	// Aresden Warehouse
		return -1;
	}
	else if (memcmp(pMapName, "wrhus_2", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME44);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "arewrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME45);	// Aresden Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "elvwrhus") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME46);	// Elvine Warehouse
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME41);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "wzdtwr_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME42);	// Magic Tower
		return -1;
	}
	else if (strcmp(pMapName, "cath_1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME47);	// Aresien Church
		return -1;
	}
	else if (strcmp(pMapName, "cath_2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME48);	// Eldiniel Church
		return -1;
	}
	else if (memcmp(pMapName, "resurr", 6) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME54);	// Revival Zone
		return -1;
	}
	else if (strcmp(pMapName, "arebrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME4);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME5);	// Aresden Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "arebrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME6);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "arebrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME7);	// Aresden Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk11") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME8);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk12") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME9);	// Elvine Barrack 1
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk21") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME10);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "elvbrk22") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME11);	// Elvine Barrack 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME12);	// Arena 1
		return -1;
	}
	else if (strcmp(pMapName, "fightzone2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME13);	// Arena 2
		return -1;
	}
	else if (strcmp(pMapName, "fightzone3") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME14);	// Arena 3
		return -1;
	}
	else if (strcmp(pMapName, "fightzone4") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME15);	// Arena 4
		return -1;
	}
	else if (strcmp(pMapName, "fightzone5") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME16);	// Arena 5
		return -1;
	}
	else if (strcmp(pMapName, "fightzone6") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME17);	// Arena 6
		return -1;
	}
	else if (strcmp(pMapName, "fightzone7") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME18);	// Arena 7
		return -1;
	}
	else if (strcmp(pMapName, "fightzone8") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME19);	// Arena 8
		return -1;
	}
	else if (strcmp(pMapName, "fightzone9") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME20);	// Arena 9
		return -1;
	}
	else if (strcmp(pMapName, "arejail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME63);	// Aresden Jail
		return -1;
	}
	else if (strcmp(pMapName, "elvjail") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME64);	// Elvine Jail
		return -1;
	}
	else if (memcmp(pMapName, "CmdHall", 7) == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME79);
		return -1;
	}
	else if (strcmp(pMapName, "Barracks1") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME80);
		return -1;
	}
	else if (strcmp(pMapName, "Barracks2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME81);
		return -1;
	}
	else if (strcmp(pMapName, "Bsmith") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME82);
		return -1;
	}
	else if (strcmp(pMapName, "default2") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME83);
		return -1;
	}
	else if (strcmp(pMapName, "astoria") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME84);
		return 44;
	}
	// Fantasy Maps xRisenx
	else if (strcmp(pMapName, "safeshop") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME85);
		return -1;
	}
	//else if (strcmp(pMapName, "pvpbarrack") == 0)
	//{
		//strcpy(pName, GET_OFFICIAL_MAP_NAME86);
		//return -1;
	//}
	//else if (strcmp(pMapName, "darkcrypt") == 0)
	//{
		//strcpy(pName, GET_OFFICIAL_MAP_NAME87);
		//return -1;
	//}
	//else if (strcmp(pMapName, "pvpbar2") == 0)
	//{
		//strcpy(pName, GET_OFFICIAL_MAP_NAME88);
		//return -1;
	//}
	else if (strcmp(pMapName, "arebar") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME86);
		return -1;
	}
	else if (strcmp(pMapName, "elvbar") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME87);
		return -1;
	}
	else if (strcmp(pMapName, "outlands") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME88);
		return 31;
	}
	else if (strcmp(pMapName, "catacombs") == 0)
	{
		strcpy(pName, GET_OFFICIAL_MAP_NAME89);
		return 32;
	}
	//else if (strcmp(pMapName, "GladArena") == 0)
	//{
	//	strcpy(pName, GET_OFFICIAL_MAP_NAME90); // Gladiator Arena xRisenx
	//	return 32;
	//}
	else
	{
		strcpy(pName, pMapName);
		toupper(pName[0]);
		return -1;
	}
}

bool helbreath::bCheckLocalChatCommand(char const * const pMsg)
{
	class  CStrTok * pStrTok = 0;
	char * token, cBuff[256], cTxt[120], cName[12];
	char   seps[] = " \t\n";

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	strcpy(cBuff, pMsg);
	if (memcmp(cBuff, "/showframe", 10) == 0 || memcmp(cBuff, "/fps", 4) == 0)
	{
		m_bShowFPS = !m_bShowFPS;
		return true;
	}
	else if (memcmp(cBuff, "/showtime", 9) == 0)
	{
		m_showTime = !m_showTime;
		return true;
	}
	else if (memcmp(cBuff, "/timestamp", 10) == 0)
	{
		if (!m_showTimeStamp)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND10, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND11, 10);
		m_showTimeStamp = !m_showTimeStamp;
		return true;
	}
	else if (memcmp(cBuff, "/showgrid", 9) == 0 || memcmp(cBuff, "/grid", 5) == 0)
	{
		m_showGrid = !m_showGrid;
		return true;
	}
	else if (memcmp(cBuff, "/showalldmg", 11) == 0)
	{
		if (!m_showAllDmg)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND12, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND13, 10);
		m_showAllDmg = !m_showAllDmg;
		return true;
	}
	else if (memcmp(cBuff, "/bigitems", 9) == 0)
	{
		if (!m_bigItems)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND14, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND15, 10);
		m_bigItems = !m_bigItems;
		return true;
	}
	else if (memcmp(cBuff, "/ekscreenshot", 13) == 0)
	{
		if (!m_ekScreenshot)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND16, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND17, 10);
		m_ekScreenshot = !m_ekScreenshot;
		return true;
	}
	else if (memcmp(cBuff, "/notifyme", 9) == 0)
	{
		if (!m_tabbedNotification)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND18, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND19, 10);
		m_tabbedNotification = !m_tabbedNotification;
		return true;
	}
	else if (memcmp(cBuff, "/manufill", 9) == 0)
	{
		if (!m_manuAutoFill)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND20, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND21, 10);
		m_manuAutoFill = !m_manuAutoFill;
		return true;
	}
	else if (memcmp(cBuff, "/enabletogglescreen", 19) == 0)
	{
		m_bToggleScreen = true;
		return true;
	}
	else if (memcmp(cBuff, "/whon", 5) == 0)
	{
		m_bWhisper = true;
		AddEventList(BCHECK_LOCAL_CHAT_COMMAND6, 10);// Enable to listen to whispers."
		return true;
	}
	else if (memcmp(cBuff, "/whoff", 6) == 0)
	{
		m_bWhisper = false;
		AddEventList(BCHECK_LOCAL_CHAT_COMMAND7, 10);//
		return true;
	}
	else if (memcmp(cBuff, "/shon", 5) == 0)
	{
		m_bShout = true;
		AddEventList(BCHECK_LOCAL_CHAT_COMMAND8, 10); //Enalbe to chat in public."
		return true;
	}
	else if (memcmp(cBuff, "/shoff", 6) == 0)
	{
		m_bShout = false;
		AddEventList(BCHECK_LOCAL_CHAT_COMMAND9, 10); //Unable to chat in public."
		return true;
	}
	if (memcmp(cBuff, "/tooff", 6) == 0)
	{
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != 0)
		{
			if (strlen(token) <= 10)
			{
				strcpy(cName, token);
				if (player_name == cName)
				{
					AddEventList(BCHECK_LOCAL_CHAT_COMMAND2, 10);
					if (pStrTok != 0) delete pStrTok;
					return true;
				}
				else if (m_MuteList.find(string(cName)) == m_MuteList.end())
				{
					fmt::format_to(cTxt, BCHECK_LOCAL_CHAT_COMMAND3, token);
					AddEventList(cTxt, 10);
					m_MuteList.insert(string(cName));
					SaveMuteList();
				}
			}
			else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);
		}
		if (pStrTok != 0) delete pStrTok;
		return true;
	}
	else if (memcmp(cBuff, "/toon", 5) == 0)
	{
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != 0)
		{
			if (strlen(token) <= 10)
			{
				if (m_MuteList.erase(string(token)))
				{
					fmt::format_to(cTxt, BCHECK_LOCAL_CHAT_COMMAND1, token);
					AddEventList(cTxt, 10);
					SaveMuteList();
				}
			}
			else AddEventList(BCHECK_LOCAL_CHAT_COMMAND5, 10);
		}
		if (pStrTok != 0) delete pStrTok;
		return true;
	}
	else if (memcmp(cBuff, "/showquest", 10) == 0)
	{
		if (!m_displayQuest)
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND22, 10);
		else
			AddEventList(BCHECK_LOCAL_CHAT_COMMAND23, 10);
		m_displayQuest = !m_displayQuest;
		return true;
	}
#ifdef _DEBUG
	if (memcmp(cBuff, "/showdlg", 8) == 0)
	{
		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != 0)
		{
			int dlg = atoi(token);
			token = pStrTok->pGet();
			if (token != 0)
			{
				EnableDialogBox(dlg, atoi(token), 0, 0);
				m_dialogBoxes[dlg].SetMode(atoi(token));
			}
		}
		if (pStrTok != 0) delete pStrTok;
		return true;
	}
	else if (memcmp(cBuff, "/showbtns", 9) == 0)
	{
		m_showBtns = !m_showBtns;
		return true;
	}

#endif

	return false;
}

bool helbreath::bCheckItemOperationEnabled(char cItemID)
{
	if (m_pItemList[cItemID] == 0) return false;
	if (m_cCommand < 0) return false;
	if (m_bIsTeleportRequested == true) return false;
	if (m_bIsItemDisabled[cItemID] == true) return false;

	if ((m_pItemList[cItemID]->m_sSpriteFrame == 155) && (m_bUsingSlate == true))
	{
		if ((m_cMapIndex == 35) || (m_cMapIndex == 36) || (m_cMapIndex == 37))
		{
			AddEventList(MSG_NOTIFY_SLATE_WRONG_MAP, 10); // "You cannot use it right here."
			return false;
		}
		AddEventList(MSG_NOTIFY_SLATE_ALREADYUSING, 10); // Already Using Another Slate
		return false;
	}

	if (m_bIsDialogEnabled[17] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[20] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[23] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[26] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[27] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[31] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	if (m_bIsDialogEnabled[4] == true)
	{
		AddEventList(BCHECK_ITEM_OPERATION_ENABLE1, 10);
		return false;
	}

	return true;
}

void helbreath::ClearSkillUsingStatus()
{
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(CLEAR_SKILL_USING_STATUS1, 10);//"
		DisableDialogBox(24);
		DisableDialogBox(26);
		if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/)
		{
			m_cCommand = OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
		}
	}
	m_bSkillUsingStatus = false;
}


void helbreath::NpcTalkHandler(char * pData)
{
	char * cp, cRewardName[21], cTargetName[21], cTemp[21], cTxt[250];
	short * sp, sType, sResponse;
	int     iAmount, iIndex, iContribution, iX, iY, iRange;
	int     iTargetType, iTargetCount, iQuestionType;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	sp = (short *)cp;
	sType = *sp;
	cp += 2;
	sp = (short *)cp;
	sResponse = *sp;
	cp += 2;
	sp = (short *)cp;
	iAmount = *sp;
	cp += 2;
	sp = (short *)cp;
	iContribution = *sp;
	cp += 2;
	sp = (short *)cp;
	iTargetType = *sp;
	cp += 2;
	sp = (short *)cp;
	iTargetCount = *sp;
	cp += 2;
	sp = (short *)cp;
	iX = *sp;
	cp += 2;
	sp = (short *)cp;
	iY = *sp;
	cp += 2;
	sp = (short *)cp;
	iRange = *sp;
	cp += 2;
	ZeroMemory(cRewardName, sizeof(cRewardName));
	memcpy(cRewardName, cp, 20);
	cp += 20;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	memcpy(cTargetName, cp, 20);
	cp += 20;
	EnableDialogBox(21, sResponse, sType, 0);

	if ((sType >= 1) && (sType <= 100))
	{
		iIndex = m_dialogBoxes[21].sV1;
		m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
		iIndex++;
		iQuestionType = 0;
		switch (sType)
		{
			case 1: //Monster Hunt
				ZeroMemory(cTemp, sizeof(cTemp));
				GetNpcName(iTargetType, cTemp);
				ZeroMemory(cTxt, sizeof(cTxt));
				fmt::format_to(cTxt, NPC_TALK_HANDLER16, iTargetCount, cTemp);
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				if (memcmp(cTargetName, "NONE", 4) == 0)
				{
					strcpy(cTxt, NPC_TALK_HANDLER17);//"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				else
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					GetOfficialMapName(cTargetName, cTemp);
					fmt::format_to(cTxt, NPC_TALK_HANDLER18, cTemp);//"Map : %s"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;

					if (iX != 0)
					{
						ZeroMemory(cTxt, sizeof(cTxt));
						fmt::format_to(cTxt, NPC_TALK_HANDLER19, iX, iY, iRange);//"Position: %d,%d within %d blocks"
						m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
						iIndex++;
					}

					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, NPC_TALK_HANDLER20, iContribution);//"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				iQuestionType = 1;
				break;

			case 7: //
				ZeroMemory(cTxt, sizeof(cTxt));
				m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER21, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				if (memcmp(cTargetName, "NONE", 4) == 0)
				{
					strcpy(cTxt, NPC_TALK_HANDLER22);
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				else
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					GetOfficialMapName(cTargetName, cTemp);
					fmt::format_to(cTxt, NPC_TALK_HANDLER23, cTemp);
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;

					if (iX != 0)
					{
						ZeroMemory(cTxt, sizeof(cTxt));
						fmt::format_to(cTxt, NPC_TALK_HANDLER24, iX, iY, iRange);
						m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
						iIndex++;
					}

					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, NPC_TALK_HANDLER25, iContribution);
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				iQuestionType = 1;
				break;

			case 10: // Crusade
				ZeroMemory(cTxt, sizeof(cTxt));
				m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER26, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				strcpy(cTxt, NPC_TALK_HANDLER27);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				strcpy(cTxt, NPC_TALK_HANDLER28);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				strcpy(cTxt, NPC_TALK_HANDLER29);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				strcpy(cTxt, NPC_TALK_HANDLER30);//"
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				strcpy(cTxt, " ");
				m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
				iIndex++;

				ZeroMemory(cTxt, sizeof(cTxt));
				if (memcmp(cTargetName, "NONE", 4) == 0)
				{
					strcpy(cTxt, NPC_TALK_HANDLER31);//"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				else
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					GetOfficialMapName(cTargetName, cTemp);
					fmt::format_to(cTxt, NPC_TALK_HANDLER32, cTemp);//"
					m_pMsgTextList2[iIndex] = new class CMsg(0, cTxt, 0);
					iIndex++;
				}
				iQuestionType = 2;
				break;
		}

		switch (iQuestionType)
		{
			case 1:
				m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
				iIndex++;
				m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER33, 0);//"
				iIndex++;
				m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER34, 0);//"
				iIndex++;
				m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
				iIndex++;
				break;

			case 2:
				m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
				iIndex++;
				m_pMsgTextList2[iIndex] = new class CMsg(0, NPC_TALK_HANDLER35, 0);//"
				iIndex++;
				m_pMsgTextList2[iIndex] = new class CMsg(0, "  ", 0);
				iIndex++;
				break;

			default: break;
		}
	}
}

void helbreath::GetNpcName(short sType, char * pName)
{
	switch (sType)
	{
		case 10: strcpy(pName, NPC_NAME_SLIME); break;
		case 11: strcpy(pName, NPC_NAME_SKELETON); break;
		case 12: strcpy(pName, NPC_NAME_STONEGOLEM); break;
		case 13: strcpy(pName, NPC_NAME_CYCLOPS); break;
		case 14: strcpy(pName, NPC_NAME_ORC); break;
		case 15: strcpy(pName, NPC_NAME_SHOP_KEEPER); break;
		case 16: strcpy(pName, NPC_NAME_GIANTANT); break;
		case 17: strcpy(pName, NPC_NAME_GIANTSCORPION); break;
		case 18: strcpy(pName, NPC_NAME_ZOMBIE); break;
		case 19: strcpy(pName, NPC_NAME_MAGICIAN); break;
		case 20: strcpy(pName, NPC_NAME_WAREHOUSE_KEEPER); break;
		case 21: strcpy(pName, NPC_NAME_GUARD); break;
		case 22: strcpy(pName, NPC_NAME_SNAKE); break;
		case 23: strcpy(pName, NPC_NAME_CLAYGOLEM); break;
		case 24: strcpy(pName, NPC_NAME_BLACKSMITH_KEEPER); break;
		case 25: strcpy(pName, NPC_NAME_CITYHALL_OFFICER); break;
		case 26: strcpy(pName, NPC_NAME_GUILDHALL_OFFICER); break;
		case 27: strcpy(pName, NPC_NAME_HELHOUND); break;
		case 28: strcpy(pName, NPC_NAME_TROLL); break;
		case 29: strcpy(pName, NPC_NAME_OGRE); break;
		case 30: strcpy(pName, NPC_NAME_LICHE); break;
		case 31: strcpy(pName, NPC_NAME_DEMON); break;
		case 32: strcpy(pName, NPC_NAME_UNICORN); break;
		case 33: strcpy(pName, NPC_NAME_WEREWOLF); break;
		case 34: strcpy(pName, NPC_NAME_DUMMY); break;
		case 35: strcpy(pName, NPC_NAME_ENERGYSPHERE); break;
		case 36:
			if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_ARROWGUARDTOWER_CK);
			else strcpy(pName, NPC_NAME_ARROWGUARDTOWER);
			break;
		case 37:
			if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_CANNONGUARDTOWER_CK);
			else strcpy(pName, NPC_NAME_CANNONGUARDTOWER);
			break;
		case 38:
			if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_MANACOLLECTOR_CK);
			else strcpy(pName, NPC_NAME_MANACOLLECTOR);
			break;
		case 39:
			if (_tmp_sAppr2 != 0) strcpy(pName, NPC_NAME_DETECTOR_CK);
			else strcpy(pName, NPC_NAME_DETECTOR);
			break;
		case 40: strcpy(pName, NPC_NAME_ENERGYSHIELD); break;
		case 41: strcpy(pName, NPC_NAME_GRANDMAGICGENERATOR); break;
		case 42: strcpy(pName, NPC_NAME_MANASTONE); break;
		case 43: strcpy(pName, NPC_NAME_LIGHTWARBEETLE); break;
		case 44: strcpy(pName, NPC_NAME_GODSHANDKNIGHT); break;
		case 45: strcpy(pName, NPC_NAME_GODSHANDKNIGHT_CK); break;
		case 46: strcpy(pName, NPC_NAME_TEMPLEKNIGHT); break;
		case 47: strcpy(pName, NPC_NAME_BATTLEGOLEM); break;
		case 48: strcpy(pName, NPC_NAME_STALKER); break;
		case 49: strcpy(pName, NPC_NAME_HELLCLAW); break;
		case 50: strcpy(pName, NPC_NAME_TIGERWORM); break;
		case 51: strcpy(pName, NPC_NAME_CATAPULT); break;
		case 52: strcpy(pName, NPC_NAME_GARGOYLE); break;
		case 53: strcpy(pName, NPC_NAME_BEHOLDER); break;
		case 54: strcpy(pName, NPC_NAME_DARKELF); break;
		case 55: strcpy(pName, NPC_NAME_RABBIT); break;
		case 56: strcpy(pName, NPC_NAME_CAT); break;
		case 57: strcpy(pName, NPC_NAME_FROG); break;
		case 58: strcpy(pName, NPC_NAME_MOUNTAIN_GIANT); break;
		case 59: strcpy(pName, NPC_NAME_ETTIN); break;
		case 60: strcpy(pName, NPC_NAME_CANNIBAL); break;
		case 61: strcpy(pName, NPC_NAME_RUDOLPH); break;
		case 62: strcpy(pName, NPC_NAME_DIREBOAR); break;
		case 63: strcpy(pName, NPC_NAME_FROST); break;
		case 64:
		{
			switch ((_tmp_sAppr2 & 0xFF00) >> 8)
			{
				case 1:	strcpy(pName, NPC_NAME_WATERMELON);	break;
				case 2: strcpy(pName, NPC_NAME_PUMPKIN); break;
				case 3: strcpy(pName, NPC_NAME_GARLIC); break;
				case 4: strcpy(pName, NPC_NAME_BARLEY); break;
				case 5:	strcpy(pName, NPC_NAME_CARROT); break;
				case 6: strcpy(pName, NPC_NAME_RADISH); break;
				case 7: strcpy(pName, NPC_NAME_CORN); break;
				case 8: strcpy(pName, NPC_NAME_BFLOWER); break;
				case 9: strcpy(pName, NPC_NAME_MELON); break;
				case 10: strcpy(pName, NPC_NAME_TOMATO); break;
				case 11: strcpy(pName, NPC_NAME_GRAPPE); break;
				case 12: strcpy(pName, NPC_NAME_BLUEGRAPPE); break;
				case 13: strcpy(pName, NPC_NAME_MUSHROM); break;
				case 14: strcpy(pName, NPC_NAME_GINSENG); break;
				default: strcpy(pName, NPC_NAME_CROP); break;
			}
		}
		break;
		case 65: strcpy(pName, NPC_NAME_ICEGOLEM); break;
		case 66: strcpy(pName, NPC_NAME_WYVERN); break;
		case 67: strcpy(pName, NPC_NAME_MCGAFFIN); break;
		case 68: strcpy(pName, NPC_NAME_PERRY); break;
		case 69: strcpy(pName, NPC_NAME_DEVLIN); break;

		case 70: strcpy(pName, NPC_NAME_DRAGON); break;
		case 71: strcpy(pName, NPC_NAME_CENTAUR); break;
		case 72: strcpy(pName, NPC_NAME_CLAWTUR); break;
		case 73: strcpy(pName, NPC_NAME_FIREWYV); break;
		case 74: strcpy(pName, NPC_NAME_GICRAYF); break;
		case 75: strcpy(pName, NPC_NAME_GILIZAR); break;
		case 76: strcpy(pName, NPC_NAME_GITREE); break;
		case 77: strcpy(pName, NPC_NAME_MASTORC); break;
		case 78: strcpy(pName, NPC_NAME_MINAUS); break;
		case 79: strcpy(pName, NPC_NAME_NIZIE); break;

		case 80: strcpy(pName, NPC_NAME_TENTOCL); break;
		case 81: strcpy(pName, NPC_NAME_ABADDON); break;
		case 82: strcpy(pName, NPC_NAME_SORCERS); break;
		case 83: strcpy(pName, NPC_NAME_ATK); break;
		case 84: strcpy(pName, NPC_NAME_MASTELF); break;
		case 85: strcpy(pName, NPC_NAME_DSK); break;
		case 86: strcpy(pName, NPC_NAME_HBT); break;
		case 87: strcpy(pName, NPC_NAME_CT); break;
		case 88: strcpy(pName, NPC_NAME_BARBAR); break;
		case 89: strcpy(pName, NPC_NAME_AGC); break;
		case 90: strcpy(pName, NPC_NAME_GAIL); break;
		case 91: strcpy(pName, NPC_NAME_GATE); break;
		case 102: strcpy(pName, NPC_NAME_GUILD_WAREHOUSE_KEEPER); break;
		case 103: strcpy(pName, NPC_NAME_ASTORIASHIELD); break;
			//case 95: strcpy(pName, NPC_NAME_ORCLORD); break; // Orc Lord
		case 104: strcpy(pName, NPC_NAME_DARKUNICORN); break; // DarkUnicorn
		case 105: strcpy(pName, NPC_NAME_BLACKDEMON); break;// Black Demon
		case 106: strcpy(pName, NPC_NAME_EARTHWYV); break;// Earth Wyvern
		case 107: strcpy(pName, NPC_NAME_WINDWYV); break;// Wind Wyvern
		case 108: strcpy(pName, NPC_NAME_DARKWYV); break;// Dark Wyvern
		case 109: strcpy(pName, NPC_NAME_GRASSWYV); break;// Grass Wyvern
		case 110: strcpy(pName, NPC_NAME_SKYWYV); break;// Sky Wyvern
		case 111: strcpy(pName, NPC_NAME_SEAWYV); break;// Sea Wyvern
		case 112: strcpy(pName, NPC_NAME_METALWYV); break;// Metal Wyvern
		case 113: strcpy(pName, NPC_NAME_VOIDWYV); break;// Void Wyvern
		case 114: strcpy(pName, NPC_NAME_ETERNALDRAGON); break;// Eternal Dragon
		case 122: strcpy(pName, NPC_NAME_ENRAGEDTROLL); break;// Enraged Troll
		case 123: strcpy(pName, NPC_NAME_ENRAGEDCYCLOPS); break;// Enraged Cyclops
		case 124: strcpy(pName, NPC_NAME_ENRAGEDSTALKER); break;// Enraged Stalker
		case 125: strcpy(pName, NPC_NAME_ENRAGEDGARGOYLE); break;// Enraged Gagoyle
		case 126: strcpy(pName, NPC_NAME_ENRAGEDHELLCLAW); break;// Enraged Hellclaw
		case 127: strcpy(pName, NPC_NAME_ENRAGEDTIGERWORM); break;// Enraged Tigerworm

		//case 110: strcpy(pName, NPC_NAME_AIRLEMENTAL); break;
	}
}
std::vector<string> * helbreath::GetItemName(CItem * item, bool isWH)
{
	m_itemColor = Color(255, 255, 255, 255);

	static std::vector<string> lines;
	lines.clear();

	string str("");

	if (strcmp(item->m_cName, "ScrollofRenown") == 0)
	{
		bool foundName = false;
		for (int i = 0; i < MAXITEMNAMES; i++)
		{
			if (m_pItemNameList[i] && strcmp(m_pItemNameList[i]->m_cOriginName, item->m_cName) == 0)
			{
				foundName = true;
				str = m_pItemNameList[i]->m_cName;
				break;
			}
		}

		if (!foundName)
		{
			str = item->m_cName;
		}
		fmt::format_to(G_cTxt, " (%d)", item->m_dwAttribute);
		str += G_cTxt;
		lines.push_back(str);

		fmt::format_to(G_cTxt, GET_ITEM_NAME39, item->m_dwAttribute);
		lines.push_back(G_cTxt);
		return &lines;
	}

	if (item->m_dwCount > 1 && !item->IsManued())
	{
		fmt::format_to(G_cTxt, "%u ", item->m_dwCount);
		str.append(G_cTxt);
	}

	if (item->IsVortexed())
	{
		str.append("Vortexed ");
		m_itemColor = Color(255, 132, 132, 180);
	}

	switch (GetNibble(item->m_dwAttribute, 5))
	{
		case 1: str.append(GET_ITEM_NAME3); break; // Critical
		case 2: str.append(GET_ITEM_NAME4); break; // Poisoning
		case 3: str.append(GET_ITEM_NAME5); break; // Righteous
		case 4: break;
		case 5: str.append(GET_ITEM_NAME6); break; // Agile
		case 6: str.append(GET_ITEM_NAME7); break; // Light
		case 7: str.append(GET_ITEM_NAME8); break; // Sharp
		case 8: str.append(GET_ITEM_NAME9); break; // Strong
		case 9: str.append(GET_ITEM_NAME10); break; // Ancient
		case 10: str.append(GET_ITEM_NAME11); break; // Special
		case 11: str.append(GET_ITEM_NAME12); break; // Mana Converting
		case 12: str.append(GET_ITEM_NAME13); break; // Critical
		case 13: str.append(GET_ITEM_NAME40); break; // Flawless Sharp
		case 14: str.append(GET_ITEM_NAME41); break; // Flawless Ancient
	}

	bool foundName = false;
	for (int i = 0; i < MAXITEMNAMES; i++)
	{
		if (m_pItemNameList[i] && strcmp(m_pItemNameList[i]->m_cOriginName, item->m_cName) == 0)
		{
			foundName = true;
			str.append(m_pItemNameList[i]->m_cName);
			break;
		}
	}

	if (!foundName)
	{
		str.append(item->m_cName);
	}

	if (GetNibble(item->m_dwAttribute, 7))
	{
		fmt::format_to(G_cTxt, "+%u", GetNibble(item->m_dwAttribute, 7));
		str.append(G_cTxt);
	}

	uint32_t nsockets = item->GetMaxSockets();
	if (nsockets > 0)
	{
		if (item->IsVortexed())
		{
			// don't take into consideration vortex gem
			nsockets--;
		}
		fmt::format_to(G_cTxt, " (%u/%u)", item->GetNUsedSockets(), nsockets);
		str.append(G_cTxt);
	}

	lines.push_back(str);
	str.clear();

	G_cTxt[0] = 0;

	// Item Display - ShadowEvil
	HandleItemDescription(item);		// ShadowEvil - Handles item description so GetItemName isn't so clutter'd

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	/*
EQUIPPOS_NONE
EQUIPPOS_HEAD
EQUIPPOS_BODY
EQUIPPOS_ARMS
EQUIPPOS_PANTS
EQUIPPOS_BOOTS
EQUIPPOS_NECK
EQUIPPOS_LHAND
EQUIPPOS_RHAND
EQUIPPOS_TWOHAND
EQUIPPOS_RFINGER
EQUIPPOS_LFINGER
EQUIPPOS_BACK
EQUIPPOS_FULLBODY
*/

// Item Display - ShadowEvil
	int iTmp[15];
	ZeroMemory(iTmp, sizeof(iTmp));
	char m_cItemNameTemp1[22], m_cItemNameTemp2[22];
	ZeroMemory(m_cItemNameTemp2, sizeof(m_cItemNameTemp2));
	strcpy(m_cItemNameTemp2, item->m_cName);
	switch (item->m_cEquipPos)
	{
		case EQUIPPOS_HEAD:
		case EQUIPPOS_BODY:
		case EQUIPPOS_ARMS:
		case EQUIPPOS_PANTS:
		case EQUIPPOS_BOOTS:
		case EQUIPPOS_LHAND:
			for (int i = 0; i < MAXITEMSTATS; i++)
			{
				ZeroMemory(m_cItemNameTemp1, sizeof(m_cItemNameTemp1));
				//m_cItemNameTemp1 = m_pBuildItemListStats[i]->m_cName;
				strcpy(m_cItemNameTemp1, m_pBuildItemListStats[i]->m_cName);
				if (strncmp(m_cItemNameTemp1, m_cItemNameTemp2, strlen(m_cItemNameTemp1)) == 0)
				{
					iTmp[0] = m_pBuildItemListStats[i]->m_sItemEffectValue1;	// Defense
					iTmp[1] = m_pBuildItemListStats[i]->m_sItemEffectValue2;	// Phsyical Absorb??
					break;
				}
			}
			fmt::format_to(G_cTxt, ITEM_DESCRIPTION3, iTmp[0]);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			fmt::format_to(G_cTxt, ITEM_DESCRIPTION4, iTmp[1]);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			break;
		case EQUIPPOS_RHAND:
		case EQUIPPOS_TWOHAND:
			for (int i = 0; i < MAXITEMSTATS; i++)
			{
				ZeroMemory(m_cItemNameTemp1, sizeof(m_cItemNameTemp1));
				//m_cItemNameTemp1 = m_pBuildItemListStats[i]->m_cName;
				strcpy(m_cItemNameTemp1, m_pBuildItemListStats[i]->m_cName);
				if (strncmp(m_cItemNameTemp1, m_cItemNameTemp2, strlen(m_cItemNameTemp1)) == 0)
				{
					iTmp[0] = m_pBuildItemListStats[i]->m_sItemEffectValue1;	// Damage 1
					iTmp[1] = m_pBuildItemListStats[i]->m_sItemEffectValue2;	// Damage 2
					iTmp[2] = m_pBuildItemListStats[i]->m_sItemEffectValue3;	// Damage 3
					iTmp[3] = m_pBuildItemListStats[i]->m_sItemEffectValue4;	// Damage 4
					iTmp[4] = m_pBuildItemListStats[i]->m_sItemEffectValue5;	// Damage 5
					iTmp[5] = m_pBuildItemListStats[i]->m_sItemEffectValue6;	// Damage 6
					iTmp[6] = m_pBuildItemListStats[i]->m_wWeight / 100;		// Min Swing
					iTmp[7] = m_pBuildItemListStats[i]->m_cSpeed * 13;			// Max Swing
					break;
				}
			}
			fmt::format_to(G_cTxt, ITEM_DESCRIPTION1, iTmp[0], iTmp[1], iTmp[2]);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			fmt::format_to(G_cTxt, ITEM_DESCRIPTION2, iTmp[3], iTmp[4], iTmp[5]);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			fmt::format_to(G_cTxt, ITEM_DESCRIPTION5, iTmp[6], iTmp[7]);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			break;
		case EQUIPPOS_NECK:
		case EQUIPPOS_RFINGER:
		case EQUIPPOS_LFINGER:
		case EQUIPPOS_BACK:
		case EQUIPPOS_FULLBODY:
		case EQUIPPOS_NONE:
			break;
	}
	// Item Display - ShadowEvil - END

	/*if(item->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST)
	{
		if(!strcmp(item->m_cName, "VortexGem"))
		{
			str = GET_ITEM_NAME38;
			lines.push_back( str );
			str.clear();
		}
		else
		{
			for(int j = 0; j < MAXITEMNAMES; j++)
			{
				if(m_pItemNameList[j] && strcmp(m_pItemNameList[j]->m_cOriginName, item->m_cName) == 0)
				{
					item->GetGemAttr(G_cTxt);
					if(!G_cTxt[0]) break;

					str.append( G_cTxt );
					lines.push_back(str);
					str.clear();

					str.append( GET_ITEM_NAME37 );
					lines.push_back(str);
					str.clear();
					G_cTxt[0] = NULL;
					break;
				}
			}
		}
	}*/

	for (int i = 0; i < MAXITEMSOCKETS; i++)
	{
		if (item->m_sockets[i] == SG_NONE || item->m_sockets[i] == SG_VORTEXGEM)
			continue;

		std::unordered_map<uint8_t, const char *>::iterator iter = g_socketMap.find(item->m_sockets[i]);
		if (iter == g_socketMap.end())
			continue;

		for (int j = 0; j < MAXITEMNAMES; j++)
		{
			if (m_pItemNameList[j] && strcmp(m_pItemNameList[j]->m_cOriginName, iter->second) == 0)
			{
				str.append(m_pItemNameList[j]->m_cName);
				str.append(": ");
				item->GetGemAttr(G_cTxt, item->m_sockets[i]);
				str.append(G_cTxt);
				lines.push_back(str);
				str.clear();
				G_cTxt[0] = 0;
				break;
			}
		}
	}

	if (item->IsManued())
	{
		m_itemColor = Color(255, 172, 95, 95);
		if (item->m_cItemType == ITEMTYPE_MATERIAL)
		{
			fmt::format_to(G_cTxt, GET_ITEM_NAME1, item->m_sItemSpecEffectValue2);		//"Purity: %d%%"
		}
		else
		{
			if (item->m_cEquipPos == EQUIPPOS_LFINGER)
			{
				fmt::format_to(G_cTxt, GET_ITEM_NAME2, item->m_sItemSpecEffectValue2);	//"Completion:
			}
			else
			{
				fmt::format_to(G_cTxt, GET_ITEM_NAME2, item->m_sItemSpecEffectValue2 + 100);	//"Completion: +100
			}
		}
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	G_cTxt[0] = 0;
	uint32_t value = GetNibble(item->m_dwAttribute, 4);

	if (GetNibble(item->m_dwAttribute, 5) && !item->IsVortexed())
	{
		m_itemColor = Color(255, 0, 200, 0);	// Solid green
	}

	switch (GetNibble(item->m_dwAttribute, 5))
	{
		case 1:
			fmt::format_to(G_cTxt, GET_ITEM_NAME14, value);
			break;
		case 2:
			fmt::format_to(G_cTxt, GET_ITEM_NAME15, value * 5);
			break;
		case 3:
			break;
		case 4: break;
		case 5:
			strcpy(G_cTxt, GET_ITEM_NAME16);
			break;
		case 6:
			fmt::format_to(G_cTxt, GET_ITEM_NAME17, value * 4);
			break;
		case 7:
			strcpy(G_cTxt, GET_ITEM_NAME18);
			break;
		case 8:
			fmt::format_to(G_cTxt, GET_ITEM_NAME19, value * 7);
			break;
		case 9:
			strcpy(G_cTxt, GET_ITEM_NAME20);
			break;
		case 10:
			fmt::format_to(G_cTxt, GET_ITEM_NAME21, value * 3);
			break;
		case 11:
			fmt::format_to(G_cTxt, GET_ITEM_NAME22, value);
			break;
		case 12:
			fmt::format_to(G_cTxt, GET_ITEM_NAME23, value);
			break;
	}

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	for (int i = 0; i < MAXITEMNAMES; i++)
	{
		if (m_pItemNameList[i] && strcmp(m_pItemNameList[i]->m_cOriginName, item->m_cName) == 0)
		{
			foundName = true;
			str.append(m_pItemNameList[i]->m_cName);
			break;
		}
	}

	G_cTxt[0] = 0;
	value = GetNibble(item->m_dwAttribute, 2);
	switch (GetNibble(item->m_dwAttribute, 3))
	{
		case 1:
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME24, value);
			isValue(value);
			value = 0;
			break;//PR
		case 2://Hit Prob
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME25, value);
			isValue(value);
			value = 0;
			break;
		case 3://DR
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME26, value);
			isValue(value);
			value = 0;
			break;
		case 4://HP rec
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME27, value);
			isValue(value);
			value = 0;
			break;
		case 5://SP rec
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME28, value);
			isValue(value);
			value = 0;
			break;
		case 6://MP rec
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME29, value);
			isValue(value);
			value = 0;
			break;
		case 7://MR
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME30, value);
			isValue(value);
			value = 0;
			break;
		case 8:  fmt::format_to(G_cTxt, GET_ITEM_NAME31, value * 3); value = 0; break;//PA
		case 9:  fmt::format_to(G_cTxt, GET_ITEM_NAME32, value * 2); value = 0; break;//Magic Abs Reduced from 39% to 26% MAX xRisenx
		case 10: fmt::format_to(G_cTxt, GET_ITEM_NAME33, value); value = 0; break;//Rep
		case 11://Exp
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME34, value);
			isValue(value);
			value = 0;
			break;
		case 12://Gold +%
			value *= 10;
			fmt::format_to(G_cTxt, GET_ITEM_NAME35, value);
			isValue(value);
			value = 0;
			break;
	}

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	if (item->m_sLevelLimit != 0 && !item->IsManued())
	{
		fmt::format_to(G_cTxt, "%s: %d", DRAW_DIALOGBOX_SHOP24, item->m_sLevelLimit);
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	if (item->m_cEquipPos != EQUIPPOS_NONE && item->m_wWeight >= 1100)
	{
		int _wWeight = 0;
		if (item->m_wWeight % 100) _wWeight = 1;
		fmt::format_to(G_cTxt, DRAW_DIALOGBOX_SHOP15, item->m_wWeight / 100 + _wWeight);
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	if ((strcmp(item->m_cName, "ZemstoneofSacrifice") == 0) || (strcmp(item->m_cName, "AcientTablet") == 0))
	{
		m_itemColor = Color(255, 145, 250, 255);	// Light baby blue
		fmt::format_to(G_cTxt, UPDATE_SCREEN_ONGAME15, item->m_wCurLifeSpan);
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}
	else if (item->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST)
	{
		fmt::format_to(G_cTxt, UPDATE_SCREEN_ONGAME15, item->m_wCurLifeSpan);
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}
	else if (item->m_cEquipPos != EQUIPPOS_NONE)
	{
		fmt::format_to(G_cTxt, UPDATE_SCREEN_ONGAME10, item->m_wCurLifeSpan);
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	if (isWH == false)
	{
		int iLoc = 0;
		for (int iTmp = 0; iTmp < MAXITEMS; iTmp++)
		{
			if (m_pItemList[iTmp] != 0)
			{
				if (strcmp(m_pItemList[iTmp]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName) == 0)
					iLoc++;
			}
		}
		if (iLoc > 1)
		{
			fmt::format_to(G_cTxt, MSG_TOTAL_NUMBER, iLoc);
			str = G_cTxt;
			lines.push_back(str);
			str.clear();
			//PutString(m_stMCursor.sX, m_stMCursor.sY + 40, G_cTxt,Color(255,150,150,150), FALSE, 1);
		}
	}
	return &lines;
}

std::vector<string> * helbreath::GetItemName(char * cItemName, uint32_t attr, uint8_t sockets[MAXITEMSOCKETS], uint32_t count)
{
	m_itemColor = Color(255, 255, 255, 255);

	static std::vector<string> lines;
	lines.clear();

	string str("");

	if (strcmp(cItemName, "ScrollofRenown") == 0)
	{
		bool foundName = false;
		for (int i = 0; i < MAXITEMNAMES; i++)
		{
			if (m_pItemNameList[i] && strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0)
			{
				foundName = true;
				str = m_pItemNameList[i]->m_cName;
				break;
			}
		}

		if (!foundName)
		{
			str = cItemName;
		}

		fmt::format_to(G_cTxt, " (%d)", attr);
		str += G_cTxt;
		lines.push_back(str);

		fmt::format_to(G_cTxt, GET_ITEM_NAME39, attr);
		lines.push_back(G_cTxt);
		return &lines;
	}

	if (count > 1 && !(attr & 1))
	{
		fmt::format_to(G_cTxt, "%u ", count);
		str.append(G_cTxt);
	}

	if (sockets[0] == SG_VORTEXGEM)
	{
		str.append("Vortexed ");
		m_itemColor = Color(255, 132, 132, 180);
	}

	switch (GetNibble(attr, 5))
	{
		case 1: str.append(GET_ITEM_NAME3);   break;
		case 2: str.append(GET_ITEM_NAME4);   break;
		case 3: str.append(GET_ITEM_NAME5);   break;
		case 4: break;
		case 5: str.append(GET_ITEM_NAME6);   break;
		case 6: str.append(GET_ITEM_NAME7);   break;
		case 7: str.append(GET_ITEM_NAME8);   break;
		case 8: str.append(GET_ITEM_NAME9);   break;
		case 9: str.append(GET_ITEM_NAME10);  break;
		case 10: str.append(GET_ITEM_NAME11); break;
		case 11: str.append(GET_ITEM_NAME12); break;
		case 12: str.append(GET_ITEM_NAME13); break;
		case 13: str.append(GET_ITEM_NAME40); break; // Flawless Sharp
		case 14: str.append(GET_ITEM_NAME41); break; // Flawless Ancient
	}

	bool foundName = false;
	for (int i = 0; i < MAXITEMNAMES; i++)
	{
		if (m_pItemNameList[i] && strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0)
		{
			foundName = true;
			str.append(m_pItemNameList[i]->m_cName);
			break;
		}
	}

	if (!foundName)
	{
		str.append(cItemName);
	}

	if (GetNibble(attr, 7))
	{
		fmt::format_to(G_cTxt, "+%u", GetNibble(attr, 7));
		str.append(G_cTxt);
	}

	lines.push_back(str);
	str.clear();

	G_cTxt[0] = 0;

	if (strcmp(cItemName, "RingofOgrepower") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 40, LNG_DAMAGE);
	}
	else if (strcmp(cItemName, "RingofDemonpower") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 50, LNG_DAMAGE);
	}
	else if (strcmp(cItemName, "RingofDragonpower") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 60, LNG_DAMAGE);
	}
	else if (strcmp(cItemName, "RingoftheXelima") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 70, LNG_DAMAGE);
	}
	else if (strcmp(cItemName, "RingoftheAbaddon") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 100, LNG_DAMAGE);
	}
	else if (strcmp(cItemName, "RingofWizard") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 5, LNG_MAGICDAMAGE);
	}
	else if (strcmp(cItemName, "RingofMage") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 10, LNG_MAGICDAMAGE);
	}
	else if (strcmp(cItemName, "RingofGrandMage") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 15, LNG_MAGICDAMAGE);
	}
	else if (strcmp(cItemName, "RingofArchmage") == 0)
	{
		fmt::format_to(G_cTxt, "+%i %s", 20, LNG_MAGICDAMAGE);
	}

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	/*if(!strcmp(cItemName, "VortexGem"))
	{
		str = GET_ITEM_NAME38;
		lines.push_back( str );
		str.clear();
	}
	else
	{
		for(int j = 0; j < MAXITEMNAMES; j++)
		{
			if(m_pItemNameList[j] && strcmp(m_pItemNameList[j]->m_cOriginName, cItemName) == 0)
			{
				CItem item;
				strcpy(item.m_cName, cItemName);
				item.GetGemAttr(G_cTxt);
				if(!G_cTxt[0]) break;

				str.append( G_cTxt );
				lines.push_back(str);
				str.clear();

				str.append( GET_ITEM_NAME37 );
				lines.push_back(str);
				str.clear();
				G_cTxt[0] = NULL;
				break;
			}
		}
	}*/

	for (int i = 0; i < MAXITEMSOCKETS; i++)
	{
		if (sockets[i] == SG_NONE || sockets[i] == SG_VORTEXGEM)
			continue;

		std::unordered_map<uint8_t, const char *>::iterator iter = g_socketMap.find(sockets[i]);
		if (iter == g_socketMap.end())
			continue;

		for (int j = 0; j < MAXITEMNAMES; j++)
		{
			if (m_pItemNameList[j] && strcmp(m_pItemNameList[j]->m_cOriginName, iter->second) == 0)
			{
				str.append(m_pItemNameList[j]->m_cName);
				str.append(": ");
				CItem item;
				item.GetGemAttr(G_cTxt, sockets[i]);
				str.append(G_cTxt);
				lines.push_back(str);
				str.clear();
				G_cTxt[0] = 0;
				break;
			}
		}
	}

	if (attr & 1)
	{
		m_itemColor = Color(255, 172, 172, 95);
	}

	G_cTxt[0] = 0;
	uint32_t value = GetNibble(attr, 4);

	if (GetNibble(attr, 5) && sockets[0] != SG_VORTEXGEM)
	{
		m_itemColor = Color(255, 90, 220, 90);
	}

	switch (GetNibble(attr, 5))
	{
		case 1: fmt::format_to(G_cTxt, GET_ITEM_NAME14, value); break;
		case 2: fmt::format_to(G_cTxt, GET_ITEM_NAME15, value * 5); break;
		case 3: break;
		case 4: break;
		case 5: strcpy(G_cTxt, GET_ITEM_NAME16); break;
		case 6: fmt::format_to(G_cTxt, GET_ITEM_NAME17, value * 4); break;
		case 7: strcpy(G_cTxt, GET_ITEM_NAME18); break;
		case 8: fmt::format_to(G_cTxt, GET_ITEM_NAME19, value * 7); break;
		case 9: strcpy(G_cTxt, GET_ITEM_NAME20); break;
		case 10: fmt::format_to(G_cTxt, GET_ITEM_NAME21, value * 3); break;
		case 11: fmt::format_to(G_cTxt, GET_ITEM_NAME22, value); break;
		case 12: fmt::format_to(G_cTxt, GET_ITEM_NAME23, value); break;
	}

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	G_cTxt[0] = 0;
	value = GetNibble(attr, 2);
	switch (GetNibble(attr, 3))
	{
		case 1:  fmt::format_to(G_cTxt, GET_ITEM_NAME24, value * 10); break;//PR
		case 2:  fmt::format_to(G_cTxt, GET_ITEM_NAME25, value * 10); break;//Hit Prob
		case 3:  fmt::format_to(G_cTxt, GET_ITEM_NAME26, value * 15); break;//DR // 130 -> 195 
		case 4:  fmt::format_to(G_cTxt, GET_ITEM_NAME27, value * 10); break;//HP rec
		case 5:  fmt::format_to(G_cTxt, GET_ITEM_NAME28, value * 10); break;//SP rec
		case 6:  fmt::format_to(G_cTxt, GET_ITEM_NAME29, value * 10); break;//MP rec
		case 7:  fmt::format_to(G_cTxt, GET_ITEM_NAME30, value * 15); break;//MR // 130 -> 195 
		case 8:  fmt::format_to(G_cTxt, GET_ITEM_NAME31, value * 3); break;//PA
		case 9:  fmt::format_to(G_cTxt, GET_ITEM_NAME32, value * 2); break;  // Magic Abs Reduced from 39% to 26% MAX xRisenx
		case 10: fmt::format_to(G_cTxt, GET_ITEM_NAME33, value);   break;//Rep
		case 11: fmt::format_to(G_cTxt, GET_ITEM_NAME34, value * 10); break;//Exp
		case 12: fmt::format_to(G_cTxt, GET_ITEM_NAME35, value * 10); break;//Gold +%
	}

	if (G_cTxt[0])
	{
		str = G_cTxt;
		lines.push_back(str);
		str.clear();
	}

	return &lines;
}

void helbreath::GetItemName(CItem * pItem, char * pStr1, char * pStr2, char * pStr3)
{
	int i;
	char cTxt[256], cTxt2[256], cName[51];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));

	strcpy(cName, pItem->m_cName);
	for (i = 0; i < MAXITEMNAMES; i++)
		if ((m_pItemNameList[i] != 0) && (strcmp(m_pItemNameList[i]->m_cOriginName, pItem->m_cName) == 0))
		{
			strcpy(cName, m_pItemNameList[i]->m_cName);
			break;
		}

	/* if (0 == memcmp(pItem->m_cName,"AcientTablet", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"NecklaceOf", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"DarkElfBow", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"The_Devastator", 14)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"DemonSlayer", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"LightingBlade", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"RubyRing", 8)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Ringof", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"MagicWand(M.Shield)", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"MagicWand(MS30-LLF)", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Merien", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"BerserkWand", 11)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"ResurWand", 9)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Blood", 5)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Swordof", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"StoneOf", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"ZemstoneofSacrifice", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"StormBringer", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Aresden", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Elvine", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Excaliber", 9)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Xelima", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"Kloness", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"aHeroOf", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(pItem->m_cName,"eHeroOf", 7)) m_bIsSpecial = TRUE;*/

	if ((pItem->m_dwAttribute & 0x00000001) != 0)
	{
		m_bIsSpecial = true;
		strcpy(pStr1, cName);
		if (pItem->m_cItemType == ITEMTYPE_MATERIAL)
			fmt::format_to(pStr2, GET_ITEM_NAME1, pItem->m_sItemSpecEffectValue2);		//"Purity: %d%%"
		else
		{	// Crafting Magins completion fix
			if (pItem->m_cEquipPos == EQUIPPOS_LFINGER)
			{
				fmt::format_to(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2);	//"Completion:
			}
			else
			{
				fmt::format_to(pStr2, GET_ITEM_NAME2, pItem->m_sItemSpecEffectValue2 + 100);	//"Completion: +100
			}
		}
	}
	else
	{
		if (pItem->m_dwCount == 1)
			fmt::format_to(G_cTxt, "%s", cName);
		else
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, pItem->m_dwCount, cName);//"%d %s"
		strcpy(pStr1, G_cTxt);
	}

	if ((pItem->m_dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		dwType2 = (pItem->m_dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (pItem->m_dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1)
			{
				case 1: strcpy(cTxt, GET_ITEM_NAME3);   break;
				case 2: strcpy(cTxt, GET_ITEM_NAME4);   break; // "Poisoning "
				case 3: strcpy(cTxt, GET_ITEM_NAME5);   break; // "Righteous "
				case 4: break;
				case 5: strcpy(cTxt, GET_ITEM_NAME6);   break; // "Agile "
				case 6: strcpy(cTxt, GET_ITEM_NAME7);   break;
				case 7: strcpy(cTxt, GET_ITEM_NAME8);   break;
				case 8: strcpy(cTxt, GET_ITEM_NAME9);   break;
				case 9: strcpy(cTxt, GET_ITEM_NAME10);  break;
				case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
				case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
				case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
				case 13: strcpy(cTxt, GET_ITEM_NAME40); break; // Flawless Sharp
				case 14: strcpy(cTxt, GET_ITEM_NAME41); break; // Flawless Ancient
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1)
			{
				case 1: fmt::format_to(cTxt, GET_ITEM_NAME14, dwValue1); break; // "Critical Hit Damage+%d"
				case 2: fmt::format_to(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break; // "Poison Damage+%d"
				case 3: break;
				case 4: break;
				case 5: strcpy(cTxt, GET_ITEM_NAME16); break; // "Attack Speed -1"
				case 6: fmt::format_to(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
				case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
				case 8: fmt::format_to(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
				case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
				case 10: fmt::format_to(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
				case 11: fmt::format_to(cTxt, GET_ITEM_NAME22, dwValue1); break;
				case 12: fmt::format_to(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);
		}

		if (dwType2 != 0)
		{
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType2)
			{
				case 1:  fmt::format_to(cTxt, GET_ITEM_NAME24, dwValue2 * 10); break;//PR
				case 2:  fmt::format_to(cTxt, GET_ITEM_NAME25, dwValue2 * 10); break;//Hit Prob
				case 3:  fmt::format_to(cTxt, GET_ITEM_NAME26, dwValue2 * 15); break;//DR // 130 -> 195 
				case 4:  fmt::format_to(cTxt, GET_ITEM_NAME27, dwValue2 * 10); break;//HP rec
				case 5:  fmt::format_to(cTxt, GET_ITEM_NAME28, dwValue2 * 10); break;//SP rec
				case 6:  fmt::format_to(cTxt, GET_ITEM_NAME29, dwValue2 * 10); break;//MP rec
				case 7:  fmt::format_to(cTxt, GET_ITEM_NAME30, dwValue2 * 15); break;//MR // 130 -> 195 
				case 8:  fmt::format_to(cTxt, GET_ITEM_NAME31, dwValue2 * 3); break;//PA
				case 9:  fmt::format_to(cTxt, GET_ITEM_NAME32, dwValue2 * 2); break; // Magic Abs Reduced from 39% to 26% MAX xRisenx
				case 10: fmt::format_to(cTxt, GET_ITEM_NAME33, dwValue2);   break;//Rep
				case 11: fmt::format_to(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;//Exp
				case 12: fmt::format_to(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;//Gold +%
			}
			strcpy(pStr3, cTxt);
		}
	}

	dwValue3 = (pItem->m_dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char *)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			fmt::format_to(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else
		{
			ZeroMemory(cTxt, sizeof(cTxt));
			fmt::format_to(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}

void helbreath::GetItemName(char * cItemName, uint32_t dwAttribute, char * pStr1, char * pStr2, char * pStr3)
{
	int i;
	char cTxt[256], cTxt2[256], cName[51];
	uint32_t dwType1, dwType2, dwValue1, dwValue2, dwValue3;

	m_bIsSpecial = false;
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(pStr1, sizeof(pStr1));
	ZeroMemory(pStr2, sizeof(pStr2));
	ZeroMemory(pStr3, sizeof(pStr3));

	strcpy(cName, cItemName);
	for (i = 0; i < MAXITEMNAMES; i++)
		if ((m_pItemNameList[i] != 0) && (strcmp(m_pItemNameList[i]->m_cOriginName, cItemName) == 0))
		{
			strcpy(cName, m_pItemNameList[i]->m_cName);
			break;
		}

	/* if (0 == memcmp(cItemName,"AcientTablet", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"NecklaceOf", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"DarkElfBow", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"DarkExecutor", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"The_Devastator", 14)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"DemonSlayer", 10)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"LightingBlade", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"RubyRing", 8)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"SapphireRing", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Ringof", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"MagicNecklace", 13)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"MagicWand(M.Shield)", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"MagicWand(MS30-LLF)", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Merien", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"BerserkWand", 11)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"ResurWand", 9)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Blood", 5)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Swordof", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"StoneOf", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"ZemstoneofSacrifice", 19)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"StormBringer", 12)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Aresden", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Elvine", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"EmeraldRing", 11)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Excaliber", 9)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Xelima", 6)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"Kloness", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"aHeroOf", 7)) m_bIsSpecial = TRUE;
else if (0 == memcmp(cItemName,"eHeroOf", 7)) m_bIsSpecial = TRUE;*/
	strcpy(pStr1, cName);

	if ((dwAttribute & 0x00F0F000) != 0)
	{
		m_bIsSpecial = true;
		dwType1 = (dwAttribute & 0x00F00000) >> 20;
		dwValue1 = (dwAttribute & 0x000F0000) >> 16;
		dwType2 = (dwAttribute & 0x0000F000) >> 12;
		dwValue2 = (dwAttribute & 0x00000F00) >> 8;
		if (dwType1 != 0)
		{
			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1)
			{
				case 1: strcpy(cTxt, GET_ITEM_NAME3); break;
				case 2: strcpy(cTxt, GET_ITEM_NAME4); break;
				case 3: strcpy(cTxt, GET_ITEM_NAME5); break;
				case 4: break;
				case 5: strcpy(cTxt, GET_ITEM_NAME6); break;
				case 6: strcpy(cTxt, GET_ITEM_NAME7); break;
				case 7: strcpy(cTxt, GET_ITEM_NAME8); break;
				case 8: strcpy(cTxt, GET_ITEM_NAME9); break;
				case 9: strcpy(cTxt, GET_ITEM_NAME10); break;
				case 10: strcpy(cTxt, GET_ITEM_NAME11); break;
				case 11: strcpy(cTxt, GET_ITEM_NAME12); break;
				case 12: strcpy(cTxt, GET_ITEM_NAME13); break;
				case 13: strcpy(cTxt, GET_ITEM_NAME40); break; // Flawless Sharp
				case 14: strcpy(cTxt, GET_ITEM_NAME41); break; // Flawless Ancient
			}
			strcat(cTxt, pStr1);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			switch (dwType1)
			{
				case 1: fmt::format_to(cTxt, GET_ITEM_NAME14, dwValue1); break;
				case 2: fmt::format_to(cTxt, GET_ITEM_NAME15, dwValue1 * 5); break;
				case 3: break;
				case 4: break;
				case 5: strcpy(cTxt, GET_ITEM_NAME16); break;
				case 6: fmt::format_to(cTxt, GET_ITEM_NAME17, dwValue1 * 4); break;
				case 7: strcpy(cTxt, GET_ITEM_NAME18); break;
				case 8: fmt::format_to(cTxt, GET_ITEM_NAME19, dwValue1 * 7); break;
				case 9: strcpy(cTxt, GET_ITEM_NAME20); break;
				case 10: fmt::format_to(cTxt, GET_ITEM_NAME21, dwValue1 * 3); break;
				case 11: fmt::format_to(cTxt, GET_ITEM_NAME22, dwValue1); break;
				case 12: fmt::format_to(cTxt, GET_ITEM_NAME23, dwValue1); break;
			}
			strcat(pStr2, cTxt);

			if (dwType2 != 0)
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				switch (dwType2)
				{
					case 1:  fmt::format_to(cTxt, GET_ITEM_NAME24, dwValue2 * 10);  break;
					case 2:  fmt::format_to(cTxt, GET_ITEM_NAME25, dwValue2 * 10);  break;
					case 3:  fmt::format_to(cTxt, GET_ITEM_NAME26, dwValue2 * 15);  break; // 130 -> 195 
					case 4:  fmt::format_to(cTxt, GET_ITEM_NAME27, dwValue2 * 10);  break;
					case 5:  fmt::format_to(cTxt, GET_ITEM_NAME28, dwValue2 * 10);  break;
					case 6:  fmt::format_to(cTxt, GET_ITEM_NAME29, dwValue2 * 10);  break;
					case 7:  fmt::format_to(cTxt, GET_ITEM_NAME30, dwValue2 * 15);  break; // 130 -> 195 
					case 8:  fmt::format_to(cTxt, GET_ITEM_NAME31, dwValue2 * 3);  break;
					case 9:  fmt::format_to(cTxt, GET_ITEM_NAME32, dwValue2 * 2);  break; // Magic Abs Reduced from 39% to 26% MAX xRisenx
					case 10: fmt::format_to(cTxt, GET_ITEM_NAME33, dwValue2);    break;
					case 11: fmt::format_to(cTxt, GET_ITEM_NAME34, dwValue2 * 10); break;
					case 12: fmt::format_to(cTxt, GET_ITEM_NAME35, dwValue2 * 10); break;
				}
				strcpy(pStr3, cTxt);
			}
		}
	}

	dwValue3 = (dwAttribute & 0xF0000000) >> 28;
	if (dwValue3 > 0)
	{
		if (pStr1[strlen(pStr1) - 2] == '+')
		{
			dwValue3 = atoi((char *)(pStr1 + strlen(pStr1) - 1)) + dwValue3;
			ZeroMemory(cTxt, sizeof(cTxt));
			memcpy(cTxt, pStr1, strlen(pStr1) - 2);
			ZeroMemory(cTxt2, sizeof(cTxt2));
			fmt::format_to(cTxt2, "%s+%d", cTxt, dwValue3);
			ZeroMemory(pStr1, sizeof(pStr1));
			strcpy(pStr1, cTxt2);
		}
		else
		{
			ZeroMemory(cTxt, sizeof(cTxt));
			fmt::format_to(cTxt, "+%d", dwValue3);
			strcat(pStr1, cTxt);
		}
	}
}
void helbreath::PointCommandHandler(int indexX, int indexY, char cItemID)
{
	char cTemp[31];
	if ((m_iPointCommandType >= 100) && (m_iPointCommandType < 200))
	{
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_MAGIC, 0, indexX, indexY, m_iPointCommandType, 0);
	}
	else if ((m_iPointCommandType >= 0) && (m_iPointCommandType < 50))
	{
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_USEITEM, 0, m_iPointCommandType, indexX, indexY, cTemp, cItemID);

		if (m_pItemList[m_iPointCommandType]->m_cItemType == ITEMTYPE_USE_SKILL)
			m_bSkillUsingStatus = true;
		else if (m_pItemList[m_iPointCommandType]->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST &&
			m_pItemList[m_iPointCommandType]->m_wCurLifeSpan > 1) // prevent exhausting by client
			m_pItemList[m_iPointCommandType]->m_wCurLifeSpan--;
	}
	else if (m_iPointCommandType == 200)
	{
		if ((strlen(m_cMCName) == 0) || (m_cMCName == player_name) || (m_cMCName[0] == '_'))
		{
			m_dialogBoxes[32].SetMode(0);
			PlaySound('E', 14, 5);

			AddEventList(POINT_COMMAND_HANDLER1, 10);
		}
		else
		{
			m_dialogBoxes[32].SetMode(3);
			PlaySound('E', 14, 5);
			ZeroMemory(m_dialogBoxes[32].cStr, sizeof(m_dialogBoxes[32].cStr));
			strcpy(m_dialogBoxes[32].cStr, m_cMCName);
			bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQUEST_JOINPARTY, 0, 1, 0, 0, m_cMCName);
			return;
		}
	}
	else if (m_iPointCommandType == 250)
	{
		for (int i = 0; i < m_iTotalFriends; i++) //Can't add friend twice
			if (strcmp(friendsList[i].friendName, m_cMCName) == 0)
			{
				AddEventList("You cannot add the same player twice.", 10);
				PlaySound('E', 24, 5);
				return;
			}

		if ((strlen(m_cMCName) == 0) || (m_cMCName == player_name) || (m_cMCName[0] == '_'))
		{
			PlaySound('E', 24, 5);
		}
		else
		{
			PlaySound('E', 14, 5);
			memcpy(friendsList[m_iTotalFriends].friendName, m_cMCName, 10);
			m_iTotalFriends++;
			m_dialogBoxes[43].sV1 = 0;
			SaveFriendList();
			UpdateFriendsStatus();
		}
	}
}


void helbreath::DrawHeldenianStats()
{
	fmt::format_to(G_cTxt, "Towers Left | Flags | Kills | Deaths");
	PutString_SprFont3(5, 135, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
	fmt::format_to(G_cTxt, "%10s | %2d | %2d | %3d | %3d", sideName[ARESDEN], m_iHeldenianAresdenLeftTower, m_iHeldenianAresdenFlags, m_iHeldenianAresdenKill, m_iHeldenianAresdenDead);
	PutString_SprFont3(10, 155, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
	fmt::format_to(G_cTxt, "%10s | %2d | %2d | %3d | %3d", sideName[ELVINE], m_iHeldenianElvineLeftTower, m_iHeldenianElvineFlags, m_iHeldenianElvineKill, m_iHeldenianElvineDead);
	PutString_SprFont3(13, 170, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
}

void helbreath::StartBGM()
{
	if (m_bSoundFlag == false)
	{
		// 		if (m_pBGM != NULL)
		// 		{	m_pBGM->bStop();
		// 			delete m_pBGM;
		// 			m_pBGM = NULL;
		// 		}//DIRECTX
		return;
	}
	char cWavFileName[32];
	ZeroMemory(cWavFileName, sizeof(cWavFileName));
	if (m_bIsXmas == true) strcpy(cWavFileName, "music\\Carol.wav");
	else
	{
		if (memcmp(m_cCurLocation, "aresden", 7) == 0) strcpy(cWavFileName, "music\\aresden.wav");
		else if (memcmp(m_cCurLocation, "elvine", 6) == 0) strcpy(cWavFileName, "music\\elvine.wav");
		else if (memcmp(m_cCurLocation, "dglv", 4) == 0) strcpy(cWavFileName, "music\\dungeon.wav");
		else if (memcmp(m_cCurLocation, "middled1", 8) == 0) strcpy(cWavFileName, "music\\dungeon.wav");
		else if (memcmp(m_cCurLocation, "middleland", 10) == 0) strcpy(cWavFileName, "music\\middleland.wav");
		// Snoopy: new musics
		else if (memcmp(m_cCurLocation, "druncncity", 10) == 0) strcpy(cWavFileName, "music\\druncncity.wav");
		else if (memcmp(m_cCurLocation, "inferniaA", 9) == 0) strcpy(cWavFileName, "music\\middleland.wav");
		else if (memcmp(m_cCurLocation, "inferniaB", 9) == 0) strcpy(cWavFileName, "music\\middleland.wav");
		else if (memcmp(m_cCurLocation, "maze", 4) == 0) strcpy(cWavFileName, "music\\dungeon.wav");
		else if (memcmp(m_cCurLocation, "abaddon", 7) == 0) strcpy(cWavFileName, "music\\abaddon.wav");
		else if (strcmp(m_cCurLocation, "istria") == 0) strcpy(cWavFileName, "music\\istria.wav");
		else if (strcmp(m_cCurLocation, "astoria") == 0) strcpy(cWavFileName, "music\\astoria.wav");
		else strcpy(cWavFileName, "music\\MainTm.wav");
	}

	// 	if (m_pBGM != NULL)
	// 	{	if( strcmp( m_pBGM->m_cWavFileName, cWavFileName ) == 0 ) return;
	// 		m_pBGM->bStop();
	// 		delete m_pBGM;
	// 		m_pBGM = NULL;
	// 	}//DIRECTX
	int iVolume = (m_cMusicVolume - 100) * 20;
	if (iVolume > 0) iVolume = 0;
	if (iVolume < -10000) iVolume = -10000; //iVolume == Volume
// 	m_pBGM = new class CSoundBuffer(m_DSound.m_lpDS, m_DSound.m_DSCaps, cWavFileName, TRUE);
// 	m_pBGM->Play(TRUE, 0, iVolume);//DIRECTX
}

void helbreath::MotionResponseHandler(char * pData)
{
	uint16_t * wp, wResponse;
	short * sp, sX, sY;
	char * cp, cDir;
	int * ip, iPreHP;
	//						          0 3        4 5						 6 7		8 9		   10	    11
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | OBJECTMOVE_CONFIRM(2) | Loc-X(2) | Loc-Y(2) | Dir(1) | MapData ...
	// Confirm Code(4) | MsgSize(4) | MsgID(4) | OBJECTMOVE_REJECT(2)  | Loc-X(2) | Loc-Y(2)
	wp = (uint16_t *)(pData + INDEX2_MSGTYPE);
	wResponse = *wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	switch (wResponse)
	{
		case OBJECTMOTION_CONFIRM:
			m_cCommandCount--;
			break;

		case OBJECTMOTION_ATTACK_CONFIRM:
			m_cCommandCount--;
			break;

		case OBJECTMOTION_REJECT:
			bSendCommand(MSGID_CONFIRMBUMP);
			if (m_iHP <= 0) return;

			sp = (short *)cp;
			m_sPlayerX = *sp;
			cp += 2;

			sp = (short *)cp;
			m_sPlayerY = *sp;
			cp += 2;

			m_cCommand = OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;

			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
				m_iPlayerStatus, player_name,
				OBJECTSTOP, 0, 0, 0, 0, 5);
			m_cCommandCount = 0;
			m_bIsGetPointingMode = false;
			//m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
			//m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;
			m_sViewDstX = m_sViewPointX = (m_sPlayerX - 12) * 32; // 800x600 Resolution xRisenx Center Char xRisenx
			m_sViewDstY = m_sViewPointY = (m_sPlayerY - 9) * 32; // 800x600 Resolution xRisenx Center Char xRisenx

			m_bIsRedrawPDBGS = true;
			break;

		case OBJECTMOVE_CONFIRM:
			sp = (short *)cp;
			sX = *sp;
			cp += 2;
			sp = (short *)cp;
			sY = *sp;
			cp += 2;
			cDir = *cp;
			cp++;
			m_iSP = m_iSP - *cp;
			cp++;
			if (m_iSP < 0) m_iSP = 0;

			iPreHP = m_iHP;
			ip = (int *)cp;
			m_iHP = *ip;
			cp += 4;

			if (m_iHP != iPreHP)
			{
				if (m_iHP < iPreHP)
				{
					fmt::format_to(G_cTxt, NOTIFYMSG_HP_DOWN, iPreHP - m_iHP);
					AddEventList(G_cTxt, 10);
					m_dwDamagedTime = unixtime();
					if ((m_cLogOutCount > 0) && (m_bForceDisconn == false))
					{
						m_cLogOutCount = -1;
						AddEventList(MOTION_RESPONSE_HANDLER2, 10);
					}
				}
				else
				{
					fmt::format_to(G_cTxt, NOTIFYMSG_HP_UP, m_iHP - iPreHP);
					AddEventList(G_cTxt, 10);
				}
			}
			m_pMapData->ShiftMapData(cDir);
			_ReadMapData(sX, sY, cp);
			m_bIsRedrawPDBGS = true;
			m_cCommandCount--;
			break;

		case OBJECTMOVE_REJECT:
			if (m_iHP <= 0) return;
			wp = (uint16_t *)cp;
			if (m_sPlayerObjectID != *wp) return;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerX = *sp;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerY = *sp;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerType = *sp;
			cp += 2;
			m_cPlayerDir = *cp;
			cp++;
			//memcpy(cName, cp, 10);
			cp += 10;
			sp = (short *)cp;
			m_sPlayerAppr1 = *sp;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerAppr2 = *sp;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerAppr3 = *sp;
			cp += 2;
			sp = (short *)cp;
			m_sPlayerAppr4 = *sp;
			cp += 2;
			ip = (int *)cp;
			m_iPlayerApprColor = *ip;
			cp += 4;
			sp = (short *)cp; // This is right as i used no armor when i crashed..
			m_sPlayerHeadApprValue = *sp; // Re-Coding Sprite xRisenx
			cp += 2;
			sp = (short *)cp;
			m_sPlayerBodyApprValue = *sp; // Re-Coding Sprite xRisenx
			cp += 2;
			sp = (short *)cp;
			m_sPlayerArmApprValue = *sp; // Re-Coding Sprite xRisenx
			cp += 2;
			sp = (short *)cp;
			m_sPlayerLegApprValue = *sp; // Re-Coding Sprite xRisenx
			cp += 2;
			ip = (int *)cp;
			m_iPlayerStatus = *ip;
			cp += 4;
			m_cCommand = OBJECTSTOP;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;
			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
				m_iPlayerStatus, player_name,
				OBJECTSTOP, 0, 0, 0,
				0, 11);
			m_cCommandCount = 0;
			m_bIsGetPointingMode = false;
			//m_sViewDstX = m_sViewPointX = (m_sPlayerX-10)*32;
			//m_sViewDstY = m_sViewPointY = (m_sPlayerY-7)*32;
			m_sViewDstX = m_sViewPointX = (m_sPlayerX - 12) * 32; // 800x600 Resolution xRisenx Center Char xRisenx
			m_sViewDstY = m_sViewPointY = (m_sPlayerY - 9) * 32; // 800x600 Resolution xRisenx Center Char xRisenx
			m_bIsPrevMoveBlocked = true;
			switch (m_sPlayerType)
			{
				case 1:
				case 2:
				case 3:
					PlaySound('C', 12, 0);
					break;
				case 4:
				case 5:
				case 6:
					PlaySound('C', 13, 0);
					break;
			}
			//m_bCommandAvailable = TRUE;
			break;
	}
}


void helbreath::CommandProcessor(short msX, short msY, short indexX, short indexY, char cLB, char cRB, char cMB)
{
    std::string cName;
	char   cDir, absX, absY, dlgID;
	short  sX, sY, sObjectType, tX, tY, dynObjectType;
	int iObjectStatus;
	int    iRet;
	uint32_t  dwTime = unixtime();
	static uint32_t lastPanTime = 0;
	uint16_t   wType = 0;
	int i;//, iFOE;
	char   cTxt[120];
#ifdef RemoveCritical
	uint32_t * dwp, dwDamage;
#endif
    std::string pDstName;
	short sDstOwnerType;
	int iDstOwnerStatus;

#ifdef RemoveCritical
	dwDamage = 0;
#endif
	bool  bGORet;
	// Fixed by Snoopy
	if ((m_bIsObserverCommanded == false) && (m_bIsObserverMode == true) && (dwTime - lastPanTime) > 100)
	{
		if ((msX == 0) && (msY == 0) && (m_sViewDstX > 32 * 21) && (m_sViewDstY > 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 8, 0, 0, 0, 0);
		else
			//if ((msX == 639) && (msY == 0) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY > 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 2, NULL, NULL, NULL, NULL);
			if ((msX == GetWidth() - 1) && (msY == 0) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * 21) && (m_sViewDstY > 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 2, 0, 0, 0, 0); // 800x600 Resolution xRisenx
			else
				//if ((msX == 639) && (msY == 479) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 4, NULL, NULL, NULL, NULL);
				if ((msX == GetWidth() - 1) && (msY == GetHeight() - 1) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * 21) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 4, 0, 0, 0, 0); // 800x600 Resolution xRisenx
				else
					//if ((msX == 0) && (msY == 479) && (m_sViewDstX > 32*21) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16) ) bSendCommand(MSGID_REQUEST_PANNING, NULL, 6, NULL, NULL, NULL, NULL);
					if ((msX == 0) && (msY == GetHeight() - 1) && (m_sViewDstX > 32 * 21) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 6, 0, 0, 0, 0); // 800x600 Resolution xRisenx
					else
						if ((msX == 0) && (m_sViewDstX > 32 * 21)) bSendCommand(MSGID_REQUEST_PANNING, 0, 7, 0, 0, 0, 0);
						else
							//if ((msX == 639) && (m_sViewDstX < 32*m_pMapData->m_sMapSizeX - 32*21)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 3, NULL, NULL, NULL, NULL);
							if ((msX == GetWidth() - 1) && (m_sViewDstX < 32 * m_pMapData->m_sMapSizeX - 32 * 21)) bSendCommand(MSGID_REQUEST_PANNING, 0, 3, 0, 0, 0, 0); // 800x600 Resolution xRisenx
							else
								if ((msY == 0) && (m_sViewDstY > 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 1, 0, 0, 0, 0);
								else
									//if ((msY == 479) && (m_sViewDstY < 32*m_pMapData->m_sMapSizeY - 32*16)) bSendCommand(MSGID_REQUEST_PANNING, NULL, 5, NULL, NULL, NULL, NULL);
									if ((msY == GetHeight() - 1) && (m_sViewDstY < 32 * m_pMapData->m_sMapSizeY - 32 * 16)) bSendCommand(MSGID_REQUEST_PANNING, 0, 5, 0, 0, 0, 0); // 800x600 Resolution xRisenx
									else return;
		lastPanTime = dwTime;
		m_bIsObserverCommanded = true;
		m_cArrowPressed = 0;
		return;
	}

	if (m_bIsObserverMode == true) return;

	m_altPressed = m_bSuperAttackMode = (GetAsyncKeyState(VK_MENU) >> 15) ? true : false;

	switch (m_stMCursor.cPrevStatus)
	{
		case CURSORSTATUS_NULL:
			if (cLB != 0)
			{
				iRet = _iCheckDlgBoxFocus(1);
				if (iRet == 1)
				{
					m_stMCursor.cPrevStatus = CURSORSTATUS_SELECTED;
					return;
				}
				else if (iRet == 0)
				{
					m_stMCursor.cPrevStatus = CURSORSTATUS_PRESSED;
					// Snoopy: Added Golden LevelUp
					//if ((msX >560) && (msX <620) && (msY>390) && (msY<405) && (m_iLU_Point >0))
					if ((msX >= GetWidth() - 90) && (msX <= GetWidth()) && (msY >= GetHeight() - 1) && (msY <= GetHeight() - 65) && (m_iLU_Point > 0)) // 800x600 Resolution xRisenx new location for levelup button
					{
						if (m_bIsDialogEnabled[12] != true)
						{
							EnableDialogBox(12, 0, 0, 0);
							PlaySound('E', 14, 5);
						}
						m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
						return;
					}
				}
				else if (iRet == -1)
				{
					return;
				}
			}
			else if (cRB != 0)
			{
				iRet = _iCheckDlgBoxFocus(2);
				if (iRet == 1) return;
			}
			break;
		case CURSORSTATUS_PRESSED:
			if (cLB == 0) // Normal Click
			{
				m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
			}
			break;
		case CURSORSTATUS_SELECTED:
			if (cLB == 0)
			{
				//DIRECTX//DIRECTX m_dInput.m_sZ = 0;
				dlgID = MouseOverDialog();

				if (dlgID != 0)
				{
					if (m_dialogBoxes[dlgID].HasDblClick() &&
						dwTime - m_stMCursor.dwSelectClickTime < DOUBLECLICKTIME
						&& abs(msX - m_stMCursor.sClickX) < 2 && abs(msY - m_stMCursor.sClickY) < 2)
					{
						m_stMCursor.dwSelectClickTime = m_stMCursor.dwSelectClickTime;
						m_dialogBoxes[dlgID].OnDblClick();
					}
					else
					{ //Need else?
						m_dialogBoxes[dlgID].OnClick();
					}
				}

				m_stMCursor.sClickX = msX;
				m_stMCursor.sClickY = msY;

				m_stMCursor.dwSelectClickTime = dwTime;
				m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
				if (m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_ITEM)
				{
					_bCheckDraggingItemRelease(dlgID);
					m_stMCursor.cSelectedObjectType = 0;
					m_stMCursor.sSelectedObjectID = 0;
				}
				return;
			}
			if (cLB != 0)
			{
				if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;

				if ((m_stMCursor.sPrevX != msX) || (m_stMCursor.sPrevY != msY))
				{
					m_stMCursor.cPrevStatus = CURSORSTATUS_DRAGGING;
					m_stMCursor.sPrevX = msX;
					m_stMCursor.sPrevY = msY;
					if ((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX) &&
						((m_stMCursor.sSelectedObjectID == 30) || (m_stMCursor.sSelectedObjectID == 29)))
					{
						m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
					}
					if ((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX) &&
						(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxes[7].GetMode() == 1))
					{
						EndInputString();
						m_dialogBoxes[7].SetMode(3);
					}
					// Query Drop Item Amount
					if ((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX) &&
						(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxes[17].GetMode() == 1))
						// Guild Menu
					{
						EndInputString();
						m_dialogBoxes[17].SetMode(20);
					}
					// guild contribute amount
					if (m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX &&
						m_stMCursor.sSelectedObjectID == 58 && m_dialogBoxes[58].GetMode() == 1)
					{
						EndInputString();
						m_dialogBoxes[58].SetMode(20);
					}
					return;
				}
				if ((m_cCommand == OBJECTMOVE) || (m_cCommand == OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
				return;
			}
			break;
		case CURSORSTATUS_DRAGGING:
			if (cLB != 0)
			{
				if ((m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true) && (m_cCommandCount == 0)) goto CP_SKIPMOUSEBUTTONSTATUS;

				if (m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX)
				{
					m_dialogBoxes[m_stMCursor.sSelectedObjectID].m_X = msX - m_stMCursor.sDistX;
					m_dialogBoxes[m_stMCursor.sSelectedObjectID].m_Y = msY - m_stMCursor.sDistY;
				}
				m_stMCursor.sPrevX = msX;
				m_stMCursor.sPrevY = msY;

				if ((m_cCommand == OBJECTMOVE) || (m_cCommand == OBJECTRUN)) goto MOTION_COMMAND_PROCESS;
				return;
			}
			if (cLB == 0)
			{
				switch (m_stMCursor.cSelectedObjectType)
				{
					case SELECTEDOBJTYPE_DLGBOX:
						if ((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX) &&
							(m_stMCursor.sSelectedObjectID == 7) && (m_dialogBoxes[7].GetMode() == 20))
						{
							sX = m_dialogBoxes[7].m_X;
							sY = m_dialogBoxes[7].m_Y;
							StartInputString(sX + 75, sY + 140, 21, m_cGuildName);
							m_dialogBoxes[7].SetMode(1);
						}

						if ((m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX) &&
							(m_stMCursor.sSelectedObjectID == 17) && (m_dialogBoxes[17].GetMode() == 20))
						{	// Query Drop Item Amount
							sX = m_dialogBoxes[17].m_X;
							sY = m_dialogBoxes[17].m_Y;
							StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
							m_dialogBoxes[17].SetMode(1);
						}

						// guild contribute amount
						if (m_stMCursor.cSelectedObjectType == SELECTEDOBJTYPE_DLGBOX &&
							m_stMCursor.sSelectedObjectID == 58 && m_dialogBoxes[58].GetMode() == 20)
						{
							sX = m_dialogBoxes[58].m_X;
							sY = m_dialogBoxes[58].m_Y;
							StartInputString(sX + 40, sY + 57, 11, m_cAmountString);
							m_dialogBoxes[58].SetMode(1);
						}

						if (m_stMCursor.sSelectedObjectID == 9)
						{
							//if( msX < 320 ) m_dialogBoxes[9].m_X = 0;
							if (msX < GetWidth() / 2) m_dialogBoxes[9].m_X = 0; // 800x600 Resolution xRisenx
							//else m_dialogBoxes[9].m_X = 640 - m_dialogBoxes[9].sSizeX;
							else m_dialogBoxes[9].m_X = GetWidth() - m_dialogBoxes[9].sSizeX; // 800x600 Resolution xRisenx
							//if( msY < 213 ) m_dialogBoxes[9].m_Y = 0;
							if (msY < 273) m_dialogBoxes[9].m_Y = 0; // 800x600 Resolution xRisenx
							//else m_dialogBoxes[9].m_Y = 427 - m_dialogBoxes[9].sSizeY;
							else m_dialogBoxes[9].m_Y = GetHeight() - 53 - m_dialogBoxes[9].sSizeY; // 800x600 Resolution xRisenx
						}

						m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
						m_stMCursor.cSelectedObjectType = 0;
						m_stMCursor.sSelectedObjectID = 0;
						break;

					case SELECTEDOBJTYPE_ITEM:
						dlgID = MouseOverDialog();
						if (dlgID && m_dialogBoxes[dlgID].HasDblClick() &&
							abs(m_stMCursor.sPrevX - msX) < 2 &&
							abs(m_stMCursor.sPrevY - msY) < 2 &&
							(dwTime - m_stMCursor.dwSelectClickTime) < DOUBLECLICKTIME)
						{
							m_dialogBoxes[dlgID].OnDblClick();
						}
						else
						{
							_bCheckDraggingItemRelease(dlgID);
						}
						m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
						m_stMCursor.cSelectedObjectType = 0;
						m_stMCursor.sSelectedObjectID = 0;
						break;

					default:
						m_stMCursor.cPrevStatus = CURSORSTATUS_NULL;
						m_stMCursor.cSelectedObjectType = 0;
						m_stMCursor.sSelectedObjectID = 0;
						break;
				}
				return;
			}
			break;
	}

	CP_SKIPMOUSEBUTTONSTATUS:;
	if (m_bCommandAvailable == false) return;
	if ((dwTime - m_dwCommandTime) < 300)
	{
        socketmode(0);
        close(1000, "speedhack");
        m_bEscPressed = false;
        PlaySound('E', 14, 5);
        if (m_bSoundFlag)
            m_pESound[38].stop();
        if ((m_bSoundFlag) && (m_bMusicStat == true))
        {
            m_pBGM.stop();
        }
        isItemLoaded = false;
        ChangeGameMode(GAMEMODE_ONMAINMENU);
        return;
	}
	if (m_iHP <= 0) return;

	if (m_sDamageMove != 0)
	{
		m_cCommand = OBJECTDAMAGEMOVE;
		goto MOTION_COMMAND_PROCESS;
	}

	if (m_pMapData->bIsTeleportLoc(m_sPlayerX, m_sPlayerY) == true && m_cCommandCount == 0)
		RequestTeleportAndWaitData();

	// indexX, indexY
	if (cLB != 0) // Mouse Left button
	{
		if (m_bIsGetPointingMode == true)
		{
			if ((m_sMCX != 0) || (m_sMCY != 0))
				PointCommandHandler(m_sMCX, m_sMCY);
			else PointCommandHandler(indexX, indexY);

			m_bCommandAvailable = false;
			m_dwCommandTime = unixtime();
			m_bIsGetPointingMode = false;
			return;
		}

		m_pMapData->bGetOwner(m_sMCX, m_sMCY - 1, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
		//m_pMapData->m_pData[dX][dY].m_sItemSprite
		if (m_cMCName == player_name && (sObjectType <= 6 || m_pMapData->m_pData[m_sPlayerX - m_pMapData->m_sPivotX][m_sPlayerY - m_pMapData->m_sPivotY].m_sItemSprite != 0))
		{//if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && ( sObjectType <= 6 || m_pMapData->m_pData[15][15].m_sItemSprite != 0 )) {
		 //if (memcmp(m_cMCName, m_cPlayerName, 10) == 0 && sObjectType <= 6){
			if ((m_sPlayerType >= 1) && (m_sPlayerType <= 6)/* && ((m_sPlayerAppr2 & 0xF000) == 0)*/)
			{
				m_cCommand = OBJECTGETITEM;
				m_sCommX = m_sPlayerX;
				m_sCommY = m_sPlayerY;
			}
		}
		else
		{
			if (m_cMCName == player_name) m_sMCY -= 1;
			if ((m_sMCX != 0) && (m_sMCY != 0)) // m_sMCX, m_sMCY
			{
				if (m_bCtrlPressed == true)
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
					if ((iObjectStatus & 0x10) != 0) return;
					if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;
					m_stMCursor.sCursorFrame = 3;
					absX = abs(m_sPlayerX - m_sMCX);
					absY = abs(m_sPlayerY - m_sMCY);
					if ((absX <= 1) && (absY <= 1))
					{
						wType = _iGetAttackType();
						m_cCommand = OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else if ((absX <= 3) && (absY <= 2) // strike on Big mobs & gate from a range
						&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
					{
						wType = _iGetAttackType();
						m_cCommand = OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
					}
					else // Pas au corp  corp
					{
						switch (_iGetWeaponSkillType())
						{
							case 6: // Bow
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
								break;

							case 5: // OpenHand
							case 7: // SS
								if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
									{
										if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
										{
											m_cCommand = OBJECTATTACKMOVE;
											wType = _iGetAttackType();
										}
										else
										{
											m_cCommand = OBJECTRUN;
											GetPlayerTurn();
										}
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
									}
									else
									{
										m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								else
								{
									if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
										&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
										m_cCommand = OBJECTRUN;	// Staminar
									else m_cCommand = OBJECTMOVE;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									GetPlayerTurn();
								}
								break;

							case 8: // LS
								if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() != 30)) // Crit without StormBlade
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() == 30))  // Crit with StormBlade (by Snoopy)
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 3) && (absY <= 3)
									&& (_iGetAttackType() == 5))  // Normal hit with StormBlade (by Snoopy)
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else // Swing
								{
									if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0))
										&& (_iGetAttackType() != 5)) // no Dash possible with StormBlade
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
										{
											if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
											{
												m_cCommand = OBJECTATTACKMOVE;
												wType = _iGetAttackType();
											}
											else
											{
												m_cCommand = OBJECTRUN;
												GetPlayerTurn();
											}
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else
										{
											m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
										}
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
											&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = OBJECTRUN;
										else m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								break;

							case 9: // Fencing
								if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
								{
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								else
								{
									if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
										{
											if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
											{
												m_cCommand = OBJECTATTACKMOVE;
												wType = _iGetAttackType();
											}
											else
											{
												m_cCommand = OBJECTRUN;
												GetPlayerTurn();
											}
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else
										{
											m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
										}
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = OBJECTRUN;
										else m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								break;

							case 10: // Axe
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
								{
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								else
								{
									if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
										{
											if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
											{
												m_cCommand = OBJECTATTACKMOVE;
												wType = _iGetAttackType();
											}
											else
											{
												m_cCommand = OBJECTRUN;
												GetPlayerTurn();
											}
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else
										{
											m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
										}
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = OBJECTRUN;
										else m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								break;
							case 14: // Hammer
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
								{
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								}
								else
								{
									if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)))
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
										{
											if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
											{
												m_cCommand = OBJECTATTACKMOVE;
												wType = _iGetAttackType();
											}
											else
											{
												m_cCommand = OBJECTRUN;
												GetPlayerTurn();
											}
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else
										{
											m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
										}
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = OBJECTRUN;
										else m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								break;
							case 21: // Wand
								if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
								{
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									wType = _iGetAttackType();
								} // Battle Mages xRisenx
								else if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
									&& (_iGetAttackType() == 30))  // Crit with StormBlade Using SB as base.
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
									//
								}
								//else if ( (absX <= 1) && (absY <= 3)
								//	&& (_iGetAttackType() == 5))  // Normal hit with StormBlade Using SB as base.
								//{	wType = _iGetAttackType();
								//	m_cCommand = OBJECTATTACK;
								//	m_sCommX = m_sMCX;
								//	m_sCommY = m_sMCY;
								//} // Battle Mages xRisenx
								else
								{
									if (((absX == 2) && (absY == 2)) || ((absX == 0) && (absY == 2)) || ((absX == 2) && (absY == 0)) && (_iGetAttackType() != 5))
									{ // && (_iGetAttackType() != 5) Battle Mages xRisenx
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
										{
											if (m_cSkillMastery[_iGetWeaponSkillType()] == 100)
											{
												m_cCommand = OBJECTATTACKMOVE;
												wType = _iGetAttackType();
											}
											else
											{
												m_cCommand = OBJECTRUN;
												GetPlayerTurn();
											}
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else
										{
											m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
										}
									}
									else
									{
										if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
											(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
											m_cCommand = OBJECTRUN;
										else m_cCommand = OBJECTMOVE;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										GetPlayerTurn();
									}
								}
								break;
						}
					}
				}
				else // CTRL not pressed
				{
					m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID, &dynObjectType);
					if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6)))
					{
						switch (sObjectType)
						{ 	// CLEROTH - NPC TALK
							case 15: // Jehovah - Changed so the shopkeeper reads case 8.
								EnableDialogBox(20, 8, 0, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 15;
								break;

							case 19: // Gandlf
								EnableDialogBox(20, 0, 16, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 19;
								break;

							case 20: // Howard
								EnableDialogBox(20, 0, 14, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 20;
								m_dialogBoxes[39].sV3 = 20;
								m_dialogBoxes[39].sV4 = m_wCommObjectID;
								m_dialogBoxes[39].sV5 = m_sMCX;
								m_dialogBoxes[39].sV6 = m_sMCY;
								break;

							case NPC_PRINCESS:
								EnableDialogBox(20, 0, 56, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 20;
								m_dialogBoxes[39].sV3 = 20;
								m_dialogBoxes[39].sV4 = m_wCommObjectID;
								m_dialogBoxes[39].sV5 = m_sMCX;
								m_dialogBoxes[39].sV6 = m_sMCY;
								break;

							case 24:
								EnableDialogBox(20, 7, 0, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 24;
								m_dialogBoxes[39].sV3 = 24;
								m_dialogBoxes[39].sV4 = m_wCommObjectID;
								m_dialogBoxes[39].sV5 = m_sMCX;
								m_dialogBoxes[39].sV6 = m_sMCY;
								break;

							case 25:
								EnableDialogBox(20, 9, 0, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 25;
								break;

							case 26: // Kennedy
								EnableDialogBox(20, 0, 7, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 26;
								break;

							case 21: // Guard
								if ((_iGetFOE(iObjectStatus) >= 0) && (!m_bIsCombatMode))
								{
									EnableDialogBox(20, 4, 0, 0);
									//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
									m_dialogBoxes[20].sV3 = 21;
								}
								break;
							case 67: // McGaffin
							case 68: // Perry
							case 69: // Devlin
								if (!m_bIsCombatMode)
								{
									EnableDialogBox(20, 4, 0, 0);
									//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
									m_dialogBoxes[20].sV3 = sObjectType;
								}
								break;

							case 90: // Snoopy: Gail
								EnableDialogBox(20, 6, 0, 0);
								//m_dialogBoxes[20].//CentreOverPoint(m_stMCursor.sX, m_stMCursor.sY);
								m_dialogBoxes[20].sV3 = 90;
								break;

							default: // Other mobs
								if (_iGetFOE(iObjectStatus) >= 0 && m_targetNeutral == false) break;
								if (iObjectStatus & STATUS_INVISIBILITY) break;
								if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
								absX = abs(m_sPlayerX - m_sMCX);
								absY = abs(m_sPlayerY - m_sMCY);
								if ((absX <= 1) && (absY <= 1))
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
									&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
								{
									wType = _iGetAttackType();
									m_cCommand = OBJECTATTACK;
									m_sCommX = m_sMCX;
									m_sCommY = m_sMCY;
								}
								else // Normal hit from a range.
								{
									switch (_iGetWeaponSkillType())
									{
										case 6: // Bow
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											wType = _iGetAttackType();
											break;

										case 5: // Boxe
										case 7: // SS
											if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0)
												&& (m_sPlayerType >= 1) && (m_sPlayerType <= 6))
												m_cCommand = OBJECTRUN;
											else m_cCommand = OBJECTMOVE;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											GetPlayerTurn();
											break;

										case 8: // LS
											if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
												&& (_iGetAttackType() != 30)) // Crit without StormBlade by Snoopy
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
												&& (_iGetAttackType() == 30)) // Crit with StormBlade by Snoopy
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else if ((absX <= 3) && (absY <= 3)
												&& (_iGetAttackType() == 5)) // Normal hit with StormBlade by Snoopy
											{
												m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else
											{
												if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
													(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
													m_cCommand = OBJECTRUN;
												else m_cCommand = OBJECTMOVE;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												GetPlayerTurn();
											}
											break;

										case 9: // Fencing
											if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else
											{
												if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
													(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
													m_cCommand = OBJECTRUN;
												else m_cCommand = OBJECTMOVE;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												GetPlayerTurn();
											}
											break;

										case 10: //
											if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else
											{
												if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
													(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
													m_cCommand = OBJECTRUN;
												else m_cCommand = OBJECTMOVE;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												GetPlayerTurn();
											}
											break;
										case 14: //
											if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											else
											{
												if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
													(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
													m_cCommand = OBJECTRUN;
												else m_cCommand = OBJECTMOVE;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												GetPlayerTurn();
											}
											break;
										case 21: // Wands
											if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (_iGetAttackType() != 30))
											{ // && (_iGetAttackType() != 30) Battle Mages xRisenx
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											} // Battle Mages xRisenx
											else if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
												&& (_iGetAttackType() == 30)) // Crit with blatte staffs Using SB as base.
											{
												if ((absX <= 1) && (absY <= 1) && (m_bShiftPressed || m_bRunningMode) && (m_iSP > 0))
													m_cCommand = OBJECTATTACKMOVE;
												else m_cCommand = OBJECTATTACK;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												wType = _iGetAttackType();
											}
											//else if ((absX <= 3) && (absY <= 3)
											//	   && (_iGetAttackType() == 5)) // Normal hit with battle staffs Using SB as base.
											//{	m_cCommand = OBJECTATTACK;
											//	m_sCommX = m_sMCX;
											//	m_sCommY = m_sMCY;
											//	wType = _iGetAttackType();
											//} // Battle Mages xRisenx
											else
											{
												if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
													(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
													m_cCommand = OBJECTRUN;
												else m_cCommand = OBJECTMOVE;
												m_sCommX = m_sMCX;
												m_sCommY = m_sMCY;
												GetPlayerTurn();
											}
											break;
									}
								}
								break;
						}
					}
					else if ((dynObjectType == DYNAMICOBJECT_MINERAL1 || dynObjectType == DYNAMICOBJECT_MINERAL2)
						&& ((m_sPlayerAppr2 & 0x0FF0) >> 4) == 25)
					{ //Weapon = PickAxe
						if (abs(m_sPlayerX - m_sMCX) <= 1 && abs(m_sPlayerY - m_sMCY) <= 1)
						{
							m_cCommand = OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
						}
						else
						{
							if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
								(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
								m_cCommand = OBJECTRUN;
							else m_cCommand = OBJECTMOVE;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							GetPlayerTurn();
						}
					}
					else
					{
						if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
							(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
							m_cCommand = OBJECTRUN;
						else m_cCommand = OBJECTMOVE;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						GetPlayerTurn();
					}
				}
			}
			else
			{
				if ((m_bShiftPressed || m_bRunningMode) && (m_iSP > 0) &&
					(m_sPlayerType >= 1) && (m_sPlayerType <= 6))
					m_cCommand = OBJECTRUN;
				else m_cCommand = OBJECTMOVE;
				m_sCommX = indexX;
				m_sCommY = indexY;
				GetPlayerTurn();
			}
		}
	}
	else if (cRB != 0/* && !m_altPressed*/) // Mouse Right button
	{
		m_cCommand = OBJECTSTOP;
		if (m_bIsGetPointingMode == true)
		{
			m_bIsGetPointingMode = false;
			AddEventList(COMMAND_PROCESSOR1, 10);
		}
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if ((m_sMCX != 0) && (m_sMCY != 0))
		{
			absX = abs(m_sPlayerX - m_sMCX);
			absY = abs(m_sPlayerY - m_sMCY);
			if (absX == 0 && absY == 0) return;

			if (m_bCtrlPressed == true)
			{
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID);
				if ((iObjectStatus & 0x10) != 0) return;
				if ((sObjectType == 15) || (sObjectType == 20) || (sObjectType == 24)) return;

				if ((absX <= 1) && (absY <= 1))
				{
					wType = _iGetAttackType();
					m_cCommand = OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
					&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
				{
					wType = _iGetAttackType();
					m_cCommand = OBJECTATTACK;
					m_sCommX = m_sMCX;
					m_sCommY = m_sMCY;
				}
				else
				{
					switch (_iGetWeaponSkillType())
					{
						case 6: // Bow
							m_cCommand = OBJECTATTACK;
							m_sCommX = m_sMCX;
							m_sCommY = m_sMCY;
							wType = _iGetAttackType();
							break;

						case 5: // Boxe
						case 7: // SS
							break;

						case 8: // LS
							if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() != 30)) // without StormBlade by Snoopy
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 3) && (absY <= 3)
								&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							break;

						case 9: // Fencing
							if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							break;

						case 10: //
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							break;

						case 14: //
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
							{
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							}
							break;
						case 21: // Wands
							if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (_iGetAttackType() != 30))
							{ // && (_iGetAttackType() != 30) Battle Mages xRisenx
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
								wType = _iGetAttackType();
							} // Battle Mages xRisenx
							else if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
								&& (_iGetAttackType() == 30)) // with stormBlade crit Using SB as base.
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							//else if (   (absX <= 3) && (absY <= 3)
							//	&& (_iGetAttackType() == 5)) // with BattleStaff no crit Using SB as base.
							//{	wType = _iGetAttackType();
							//	m_cCommand = OBJECTATTACK;
							//	m_sCommX = m_sMCX;
							//	m_sCommY = m_sMCY;
							//} // Battle Mages xRisenx
							break;
					}
				}
			}
			else // CTRL not pressed
			{
				absX = abs(m_sPlayerX - m_sMCX);
				absY = abs(m_sPlayerY - m_sMCY);
				m_pMapData->bGetOwner(m_sMCX, m_sMCY, cName, &sObjectType, &iObjectStatus, &m_wCommObjectID, &dynObjectType);
				if (sObjectType >= 10 || ((sObjectType >= 1) && (sObjectType <= 6)))
				{
					switch (sObjectType)
					{
						case NPC_SHOPKEEPER_W:
						case NPC_GANDLF:
						case NPC_HOWARD:
						case NPC_TOM:
						case NPC_WILLIAM:
						case NPC_KENNEDY:
						case NPC_PRINCESS:
						case NPC_GUARD:
						case NPC_MCGAFFIN:
						case NPC_PERRY:
						case NPC_DEVLIN:
						case NPC_GAIL:
							break;

						default: // All "normal mobs"
							if (_iGetFOE(iObjectStatus) >= 0 && m_targetNeutral == false) break;
							if (iObjectStatus & STATUS_INVISIBILITY) break;
							if ((sObjectType >= 1) && (sObjectType <= 6) && (m_bForceAttack == false)) break;
							if ((absX <= 1) && (absY <= 1))
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else if ((absX <= 2) && (absY <= 2) // strike on Big mobs & gate from a range
								&& ((sObjectType == 66) || (sObjectType == 73) || (sObjectType == 81) || (sObjectType == 91)))
							{
								wType = _iGetAttackType();
								m_cCommand = OBJECTATTACK;
								m_sCommX = m_sMCX;
								m_sCommY = m_sMCY;
							}
							else //
							{
								switch (_iGetWeaponSkillType())
								{
									case 6: // Bow
										m_cCommand = OBJECTATTACK;
										m_sCommX = m_sMCX;
										m_sCommY = m_sMCY;
										wType = _iGetAttackType();
										break;

									case 5: // Boxe
									case 7: // SS
										break;

									case 8: // LS
										if ((absX <= 3) && (absY <= 3) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
											&& (_iGetAttackType() != 30)) // crit without StormBlade by Snoopy
										{
											wType = _iGetAttackType();
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else if ((absX <= 5) && (absY <= 5) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
											&& (_iGetAttackType() == 30)) // with stormBlade crit by Snoopy
										{
											wType = _iGetAttackType();
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										else if ((absX <= 3) && (absY <= 3)
											&& (_iGetAttackType() == 5)) // with stormBlade no crit by Snoopy
										{
											wType = _iGetAttackType();
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										break;

									case 9: // fencing
										if ((absX <= 4) && (absY <= 4) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
										{
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											wType = _iGetAttackType();
										}
										break;

									case 10: //
										if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
										{
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											wType = _iGetAttackType();
										}
										break;
									case 14: // hammer
										if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true))
										{
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											wType = _iGetAttackType();
										}
										break;
									case 21: // Wands
										if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true) && (_iGetAttackType() != 30))
										{ // && (_iGetAttackType() != 30) Battle Mages xRisenx
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
											wType = _iGetAttackType();
										} // Battle Mages xRisenx
										else if ((absX <= 2) && (absY <= 2) && (m_iSuperAttackLeft > 0) && (m_bSuperAttackMode == true)
											&& (_iGetAttackType() == 30)) // with battlesstaffs crit Magn0S:: Using SB as base.
										{
											wType = _iGetAttackType();
											m_cCommand = OBJECTATTACK;
											m_sCommX = m_sMCX;
											m_sCommY = m_sMCY;
										}
										//else if (   (absX <= 3) && (absY <= 3)
										//	&& (_iGetAttackType() == 5)) // with Battlestafs no crit Magn0S:: Using SB as base.
										//{	wType = _iGetAttackType();
										//	m_cCommand = OBJECTATTACK;
										//	m_sCommX = m_sMCX;
										//	m_sCommY = m_sMCY;
										//} // Battle Mages xRisenx
										break;
								}
							}
							break;
					}
				}
				else if ((dynObjectType == DYNAMICOBJECT_MINERAL1 || dynObjectType == DYNAMICOBJECT_MINERAL2)
					&& ((m_sPlayerAppr2 & 0x0FF0) >> 4) == 25)
				{ //Weapon = PickAxe
					if (absX <= 1 && absY <= 1)
					{
						m_cCommand = OBJECTATTACK;
						m_sCommX = m_sMCX;
						m_sCommY = m_sMCY;
						wType = _iGetAttackType();
					}
				}

			}
		}
		else
		{
			cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, indexX, indexY);
			if (m_iHP <= 0) return;
			if (cDir == 0) return;
			if (m_cPlayerDir == cDir) return;
			ClearSkillUsingStatus();
			m_cPlayerDir = cDir;
			bSendCommand(MSGID_MOTION_STOP, 0, m_cPlayerDir, 0, 0, 0, 0);

			m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
				m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
				m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
				m_iPlayerStatus, player_name,
				m_cCommand, 0, 0, 0, 0,
				10);
			m_bCommandAvailable = false;
			m_dwCommandTime = unixtime();
			return;
		}
	}
	else if (cMB != 0)
	{

	}

	MOTION_COMMAND_PROCESS:;

	if (m_cCommand != OBJECTSTOP)
	{
		if (m_iHP <= 0) return;
		if (m_cCommandCount == 5) AddEventList(COMMAND_PROCESSOR2, 10, false);
		if (m_bCommandAvailable == false) return;
		if (m_cCommandCount >= 6) return;

		if (m_sPlayerType > 6)
		{
			switch (m_cCommand)
			{
				case OBJECTRUN:
				case OBJECTMAGIC:
				case OBJECTGETITEM:
					m_cCommand = OBJECTSTOP;
					break;
			}
		}

		ClearSkillUsingStatus();

		if (m_sDamageMove != 0)
		{
			m_cCommand = OBJECTDAMAGEMOVE;
			m_sCommX = m_sPlayerX;
			m_sCommY = m_sPlayerY;

			switch (m_sDamageMove)
			{
				case 1: m_sCommY--; break;
				case 2: m_sCommX++; m_sCommY--; break;
				case 3: m_sCommX++; break;
				case 4: m_sCommX++; m_sCommY++; break;
				case 5: m_sCommY++; break;
				case 6: m_sCommX--; m_sCommY++; break;
				case 7: m_sCommX--; break;
				case 8: m_sCommX--; m_sCommY--; break;
			}

#ifdef RemoveCritical
			for (i = 1; i < MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					if (dwDamage > 0)
						fmt::format_to(cTxt, "-%dPts", dwDamage); //pts
					else strcpy(cTxt, "Critical!");

					int iFontType;
					if ((dwDamage >= 0) && (dwDamage < 500))		iFontType = 21;
					else if ((dwDamage >= 500) && (dwDamage < 1250)) iFontType = 22;
					else if ((dwDamage >= 1250) || (dwDamage < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

					if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					break;
				}
#else
			for (i = 1; i < MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					if (m_sDamageMoveAmount > 0)
						fmt::format_to(cTxt, "-%d", m_sDamageMoveAmount); //pts
					else strcpy(cTxt, COMMAND_PROCESSOR6);

					int iFontType;
					if ((m_sDamageMoveAmount >= 0) && (m_sDamageMoveAmount < 12))		iFontType = 21;
					else if ((m_sDamageMoveAmount >= 12) && (m_sDamageMoveAmount < 40)) iFontType = 22;
					else if ((m_sDamageMoveAmount >= 40) || (m_sDamageMoveAmount < 0))	iFontType = 23;

					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;

					if (m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i) == false)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					break;
				}
#endif
			m_sDamageMove = 0;
		}

		switch (m_cCommand)
		{
			case OBJECTRUN:
			case OBJECTMOVE:
			case OBJECTDAMAGEMOVE:

				if (m_bParalyze) return;
				if (m_bHackMoveBlocked) return; // Anti Hack xRisenx
				bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID);

				if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
					m_cCommand = OBJECTSTOP;
				else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
					(bGORet == true) && (sDstOwnerType != 0))
					m_cCommand = OBJECTSTOP;
				else if ((abs(m_sPlayerX - m_sCommX) <= 2) && (abs(m_sPlayerY - m_sCommY) <= 2) &&
					(m_pMapData->m_tile[m_sCommX][m_sCommY].m_bIsMoveAllowed == false))
					m_cCommand = OBJECTSTOP;
				else
				{
					if (m_cCommand == OBJECTMOVE)
					{
						if (m_bRunningMode || m_bShiftPressed) m_cCommand = OBJECTRUN;
					}
					if (m_cCommand == OBJECTRUN)
					{
						if ((m_bRunningMode == false) && (m_bShiftPressed == false)) m_cCommand = OBJECTMOVE;
						if (m_iSP < 1) m_cCommand = OBJECTMOVE;
					}

					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, m_bIllusionMVT);

					if (cDir != 0)
					{
						if (m_cLogOutCount > 0 && !m_bForceDisconn)
						{
							m_cLogOutCount = -1;
							AddEventList(COMMAND_PROCESSOR7, 10);
						}
						m_cPlayerDir = cDir;
						bSendCommand(m_cCommand | MSGIDTYPE_MOTION, 0, cDir, 0, 0, 0, 0);

						switch (cDir)
						{
							case 1:	m_sPlayerY--; break;
							case 2:	m_sPlayerY--; m_sPlayerX++;	break;
							case 3:	m_sPlayerX++; break;
							case 4:	m_sPlayerX++; m_sPlayerY++;	break;
							case 5:	m_sPlayerY++; break;
							case 6:	m_sPlayerX--; m_sPlayerY++;	break;
							case 7:	m_sPlayerX--; break;
							case 8:	m_sPlayerX--; m_sPlayerY--;	break;
						}

#ifdef _DEBUG
						static int timez = unixtime();
						fmt::format_to(G_cTxt, "Move: %i", unixtime() - timez);
						AddEventList(G_cTxt);
						timez = unixtime();
#endif
						m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
							m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
							m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
							m_iPlayerStatus, player_name,
							m_cCommand, 0, 0, 0);
						m_bCommandAvailable = false;
						m_dwCommandTime = unixtime();
						m_iPrevMoveX = m_sPlayerX;
						m_iPrevMoveY = m_sPlayerY;
					}
				}

				if (m_cCommand == OBJECTDAMAGEMOVE)
				{
					m_bIsGetPointingMode = false;
					m_iPointCommandType = -1;
					m_stMCursor.sCursorFrame = 0;
					ClearSkillUsingStatus();
					m_cCommand = OBJECTSTOP;
				}
				break;

			case OBJECTATTACK:
				cDir = m_Misc.cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY);
				// Snoopy: Illusion movement
				if (m_bIllusionMVT == true)
				{
					cDir += 4;
					if (cDir > 8) cDir -= 8;
				}
				if (cDir != 0)
				{
					if ((wType == 2) || (wType == 25))
					{
						if (_bCheckItemByType(ITEMTYPE_ARROW) == false)
							wType = 0;
					}
					if (wType >= 20)
					{
						m_iSuperAttackLeft--;
						if (m_iSuperAttackLeft < 0) m_iSuperAttackLeft = 0;
					}
					m_cPlayerDir = cDir;
					bSendCommand(MSGID_MOTION_ATTACK, 0, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
					m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
						m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
						m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
						m_iPlayerStatus, player_name,
						OBJECTATTACK,
						m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
					m_bCommandAvailable = false;
					m_dwCommandTime = unixtime();
				}
				m_cCommand = OBJECTSTOP;
				break;

			case OBJECTATTACKMOVE:
				if (m_bParalyze) return;
				if (m_bHackMoveBlocked) return; // Anti Hack xRisenx
				bGORet = m_pMapData->bGetOwner(m_sCommX, m_sCommY, pDstName, &sDstOwnerType, &iDstOwnerStatus, &m_wCommObjectID);
				if ((m_sPlayerX == m_sCommX) && (m_sPlayerY == m_sCommY))
					m_cCommand = OBJECTSTOP;
				else if ((abs(m_sPlayerX - m_sCommX) <= 1) && (abs(m_sPlayerY - m_sCommY) <= 1) &&
					(bGORet == true) && (sDstOwnerType != 0))
					m_cCommand = OBJECTSTOP;
				else
				{
					cDir = cGetNextMoveDir(m_sPlayerX, m_sPlayerY, m_sCommX, m_sCommY, true, m_bIllusionMVT);

					if (cDir != 0)
					{
						m_cPlayerDir = cDir;
						bSendCommand(MSGID_MOTION_ATTACKMOVE, 0, cDir, m_sCommX, m_sCommY, wType, 0, m_wCommObjectID);
						switch (cDir)
						{
							case 1:	m_sPlayerY--; break;
							case 2:	m_sPlayerY--; m_sPlayerX++;	break;
							case 3:	m_sPlayerX++; break;
							case 4:	m_sPlayerX++; m_sPlayerY++;	break;
							case 5:	m_sPlayerY++; break;
							case 6:	m_sPlayerX--; m_sPlayerY++;	break;
							case 7:	m_sPlayerX--; break;
							case 8:	m_sPlayerX--; m_sPlayerY--;	break;
						}

						m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
							m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
							m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
							m_iPlayerStatus, player_name,
							m_cCommand, m_sCommX - m_sPlayerX, m_sCommY - m_sPlayerY, wType);
						m_bCommandAvailable = false;
						m_dwCommandTime = unixtime();
						m_iPrevMoveX = m_sPlayerX;
						m_iPrevMoveY = m_sPlayerY;
					}
				}
				m_cCommand = OBJECTSTOP;
				break;

			case OBJECTGETITEM:
				bSendCommand(MSGID_MOTION_GETITEM, 0, m_cPlayerDir, 0, 0, 0, 0);
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
					m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
					m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
					m_iPlayerStatus, player_name,
					OBJECTGETITEM, 0, 0, 0);
				m_bCommandAvailable = false;
				m_cCommand = OBJECTSTOP;
				break;

			case OBJECTMAGIC:
				bSendCommand(MSGID_MOTION_MAGIC, 0, m_cPlayerDir, m_iCastingMagicType, 0, 0, 0);
				m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
					m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
					m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
					m_iPlayerStatus, player_name,
					OBJECTMAGIC, m_iCastingMagicType, 0, 0);
				m_bCommandAvailable = false;
				m_dwCommandTime = unixtime();
				m_bIsGetPointingMode = true;
				m_cCommand = OBJECTSTOP;
				_RemoveChatMsgListByObjectID(m_sPlayerObjectID);
				for (i = 1; i < MAXCHATMSGS; i++)
					if (m_pChatMsgList[i] == 0)
					{
						ZeroMemory(cTxt, sizeof(cTxt));
						fmt::format_to(cTxt, "%s!", m_pMagicCfgList[m_iCastingMagicType]->m_cName);
						m_pChatMsgList[i] = new class CMsg(41, cTxt, unixtime());
						m_pChatMsgList[i]->m_iObjectID = m_sPlayerObjectID;
						m_pMapData->bSetChatMsgOwner(m_sPlayerObjectID, -10, -10, i);
						return;
					}
				break;

			default:
				break;
		}
	}
	// Gladiator Arena xRisenx
	/*if( _iGetFOE(iFocuiStatus) < 0 )
{
   m_stMCursor.sCursorFrame = 3;
}
else if(strcpy(m_cMapName, ARENAMAP) == 0){
   m_stMCursor.sCursorFrame = 3;
}*/
// Gladiator Arena xRisenx
}

void helbreath::DrawDialogBox_Bank()
{
	short sX, sY, szX;
	int  i, iTotalLines, iPointerLoc;
	double d1, d2, d3;
	uint32_t ItemColor;
	char cStr1[64], cStr2[64], cStr3[64];
	bool bFlag = false;

	char onButton = m_dialogBoxes[14].OnButton();
	sX = m_dialogBoxes[14].m_X;
	sY = m_dialogBoxes[14].m_Y;
	szX = m_dialogBoxes[14].sSizeX - 5;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));

	switch (m_dialogBoxes[14].GetMode())
	{
		case -1:
			PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, Color(255, 0, 0, 0));//"
			PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, Color(255, 0, 0, 0));//"
			break;

		case 0:
			for (i = 0; i < m_dialogBoxes[14].sV1; i++)
			{
				if (!m_pBankList[i + m_dialogBoxes[14].sView] || i + m_dialogBoxes[14].sView >= MAXBANKITEMS)
					continue;
				if (isItemLoaded == false)
				{
					_LoadItemContents();
					isItemLoaded = true;
				}
				std::vector<string> * lines = GetItemName(m_pBankList[i + m_dialogBoxes[14].sView], true);
				std::vector<string>::iterator iter = lines->begin(), end = lines->end();

				if (onButton == i + 1)
				{
					bFlag = true;

					if (iter != end)
					{
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), 255, 255, 255);
					}

					uint32_t maxWidth = 0;

					while (iter != end)
					{
						if (iter->size() > maxWidth)
							maxWidth = iter->size();

						++iter;
					}

					//DIRECTX m_DDraw.DrawShadowBox(sX + 70 - 3, sY + 25 - 1, sX + 70 + maxWidth * 5.5, sY + 25 + 13*lines->size());

					iter = lines->begin();

					int iLoc = 0;
					if (iter != end)
					{
						PutString(sX + 70, sY + 25, iter->c_str(), m_itemColor, false, 1);
						iLoc += 13;
						++iter;
					}

					while (iter != end)
					{
						PutString(sX + 70, sY + 25 + iLoc, iter->c_str(), Color(255, 150, 150, 150), false, 1);
						iLoc += 13;
						++iter;
					}

					ItemColor = m_pBankList[i + m_dialogBoxes[14].sView]->m_ItemColor;
					if (ItemColor == 0)
					{
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxes[14].sView]->m_sSprite]->PutSpriteFast(sX + 40, sY + 68, m_pBankList[i + m_dialogBoxes[14].sView]->m_sSpriteFrame, m_dwCurTime);
					}
					else
					{
						if (m_pBankList[i + m_dialogBoxes[14].sView]->m_cEquipPos == EQUIPPOS_LHAND
							|| m_pBankList[i + m_dialogBoxes[14].sView]->m_cEquipPos == EQUIPPOS_RHAND
							|| m_pBankList[i + m_dialogBoxes[14].sView]->m_cEquipPos == EQUIPPOS_TWOHAND)
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxes[14].sView]->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, m_pBankList[i + m_dialogBoxes[14].sView]->m_sSpriteFrame,
								ItemColor, m_dwCurTime);
						}
						else
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pBankList[i + m_dialogBoxes[14].sView]->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, m_pBankList[i + m_dialogBoxes[14].sView]->m_sSpriteFrame,
								ItemColor, m_dwCurTime);
					}
				}
				else if (iter != end)
				{
					if (m_itemColor != Color(255, 255, 255, 255))
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), m_itemColor);
					else
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), 0, 0, 0);
				}
			}

			iTotalLines = 0;
			for (i = 0; i < MAXBANKITEMS; i++)
				if (m_pBankList[i] != 0) iTotalLines++;

			Point pointerLoc = m_dialogBoxes[14].HandleScroll(13, iTotalLines);
			if (iTotalLines > m_dialogBoxes[14].sV1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			if (bFlag == false)
			{
				PutAlignedString(sX, sX + szX, sY + 35, DRAW_DIALOGBOX_BANK3);
				PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_BANK4);
				PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_BANK5);
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_BANK6, iTotalLines, MAXBANKITEMS);
				PutAlignedString(sX, sX + szX, sY + 85, G_cTxt, 255, 255, 255);
			}
			break;
	}
}

void helbreath::DrawDialogBox_FeedBackCard()
{
}

void helbreath::DrawDialogBox_Character()
{
	short sX, sY, sSprH, sFrame;
	int i, iR, iG, iB, iSkirtDraw = 0;
	char cTxt2[120], cEquipPoiStatus[MAXITEMEQUIPPOS];
	uint32_t ItemColor;
	char cCollison;

	char onButton = m_dialogBoxes[1].OnButton();
	sX = m_dialogBoxes[1].m_X;
	sY = m_dialogBoxes[1].m_Y;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 0, FALSE, m_bDialogTrans);

	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	strcpy(G_cTxt, player_name.c_str());


	if (m_iPKCount > 0)
	{
		strcat(G_cTxt, " : ");
		ZeroMemory(cTxt2, sizeof(cTxt2));
		fmt::format_to(cTxt2, DRAW_DIALOGBOX_CHARACTER1, m_iPKCount);
		strcat(G_cTxt, cTxt2);
	}

	/*fmt::format_to(cTxt2, DRAW_DIALOGBOX_CHARACTER2, m_iContribution);
	strcat(G_cTxt, cTxt2);
	fmt::format_to(cTxt2, DRAW_DIALOGBOX_CHARACTER10, m_iGizonItemUpgradeLeft);
	strcat(G_cTxt, cTxt2);*/
	PutAlignedString(sX + 24, sX + 252, sY + 50, G_cTxt, 45, 20, 20);

	ZeroMemory(G_cTxt, sizeof(G_cTxt));

	sstream txt;
	txt << sideName[m_side];

	if (m_side != NEUTRAL)
	{
		txt << MSG_COMBATANT;

		if (m_iGuildRank != GUILDRANK_NONE)
		{
			txt << '(' << m_cGuildName << ' ' << GetGuildRankName(m_iGuildRank) << ')';
		}
	}

	PutAlignedString(sX, sX + 275, sY + 64, txt.str().c_str(), 45, 25, 25);

	// Level
	fmt::format_to(G_cTxt, "%d", m_iLevel);
	PutAlignedString(sX + 180, sX + 250, sY + 106, G_cTxt, 45, 25, 25);
	// Exp
	fmt::format_to(G_cTxt, "%d", m_iExp);
	PutAlignedString(sX + 180, sX + 250, sY + 125, G_cTxt, 45, 25, 25);
	// Next.Exp
	fmt::format_to(G_cTxt, "%d", m_levelExpTable[m_iLevel + 1]);
	PutAlignedString(sX + 180, sX + 250, sY + 142, G_cTxt, 45, 25, 25);

	// Hp
	fmt::format_to(G_cTxt, "%d/%d", m_iHP, m_stat[STAT_VIT] * 8 + m_stat[STAT_STR] * 2 + m_stat[STAT_INT] * 2 + m_iLevel * 8); // HP System xRisenx
	PutAlignedString(sX + 180, sX + 250, sY + 173, G_cTxt, 45, 25, 25);

	// Mp
	fmt::format_to(G_cTxt, "%d/%d", m_iMP, m_stat[STAT_MAG] * 3 + m_iLevel * 2 + m_stat[STAT_INT] * 2); // MP System xRisenx
	PutAlignedString(sX + 180, sX + 250, sY + 191, G_cTxt, 45, 25, 25);

	// Sp
	fmt::format_to(G_cTxt, "%d/%d", m_iSP, m_iLevel * 17 + m_stat[STAT_STR]); // SP System xRisenx
	PutAlignedString(sX + 180, sX + 250, sY + 208, G_cTxt, 45, 25, 25);

	// Max.Load
	fmt::format_to(G_cTxt, "%d/%d", m_weight, (m_stat[STAT_STR] * 5 + m_iLevel * 5));
	PutAlignedString(sX + 180, sX + 250, sY + 240, G_cTxt, 45, 25, 25);

	// Enemy Kills
	fmt::format_to(G_cTxt, "%d/%d", m_iEnemyKillCount, m_iEnemyKillTotalCount);
	PutAlignedString(sX + 180, sX + 250, sY + 257, G_cTxt, 45, 25, 25);

	// Str
	fmt::format_to(G_cTxt, "%d", m_stat[STAT_STR]);
	if (m_angelStat[STAT_STR] == 0)
		PutAlignedString(sX + 48, sX + 82, sY + 285, G_cTxt, 45, 25, 25);
	else
		PutAlignedString(sX + 48, sX + 82, sY + 285, G_cTxt, 0, 0, 192);


	fmt::format_to(G_cTxt, "%d", m_stat[STAT_VIT]);
	PutAlignedString(sX + 218, sX + 251, sY + 285, G_cTxt, 45, 25, 25);

	// Dex
	fmt::format_to(G_cTxt, "%d", m_stat[STAT_DEX]);
	if (m_angelStat[STAT_DEX] == 0)
	{
		PutAlignedString(sX + 48, sX + 82, sY + 302, G_cTxt, 45, 25, 25);
	}
	else
	{
		PutAlignedString(sX + 48, sX + 82, sY + 302, G_cTxt, 0, 0, 192);
	}

	// Int
	fmt::format_to(G_cTxt, "%d", m_stat[STAT_INT]);
	if (m_angelStat[STAT_INT] == 0)
	{
		PutAlignedString(sX + 135, sX + 167, sY + 285, G_cTxt, 45, 25, 25);
	}
	else
	{
		PutAlignedString(sX + 135, sX + 167, sY + 285, G_cTxt, 0, 0, 192);
	}

	// Mag
	fmt::format_to(G_cTxt, "%d", m_stat[STAT_MAG]);
	if (m_angelStat[STAT_MAG] == 0)
	{
		PutAlignedString(sX + 135, sX + 167, sY + 302, G_cTxt, 45, 25, 25);
	}
	else
	{
		PutAlignedString(sX + 135, sX + 167, sY + 302, G_cTxt, 0, 0, 192);
	}

	// Chr
	fmt::format_to(G_cTxt, "%d", m_stat[STAT_CHR]);
	PutAlignedString(sX + 218, sX + 251, sY + 302, G_cTxt, 45, 25, 25);

	for (i = 0; i < MAXITEMEQUIPPOS; i++)
		cEquipPoiStatus[i] = -1;

	for (i = 0; i < MAXITEMS; i++)
	{
		if ((m_pItemList[i] != 0) && (m_bIsItemEquipped[i] == true))	cEquipPoiStatus[m_pItemList[i]->m_cEquipPos] = i;
	}
	if ((m_sPlayerType >= 1) && (m_sPlayerType <= 3))
	{
		cCollison = -1;
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 0]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType - 1, m_dwCurTime);
		if (cEquipPoiStatus[EQUIPPOS_HEAD] == -1)
		{
			_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 18]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 19]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);

		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BACK]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 41, sY + 137, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 41, sY + 137, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 41, sY + 137, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BACK;
		}

		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_PANTS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_PANTS;
		}

		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_ARMS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_ARMS;
		}

		if (cEquipPoiStatus[EQUIPPOS_BOOTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BOOTS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BODY]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BODY;
		}

		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_FULLBODY]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_FULLBODY;
		}

		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_LHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 90, sY + 170, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 90, sY + 170, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 90, sY + 170, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_LHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_RHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_RHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_TWOHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 57, sY + 186, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 57, sY + 186, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 57, sY + 186, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_TWOHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_NECK]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 35, sY + 120, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 35, sY + 120, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_NECK;
		}

		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_RFINGER]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 32, sY + 193, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 32, sY + 193, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_RFINGER;
		}

		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_LFINGER]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 100, sY + 185, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 100, sY + 185, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 100, sY + 185, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_LFINGER;
		}

		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_HEAD]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutSpriteRGB(sX + 72, sY + 135, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSpriteRGB(sX + 72, sY + 135, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->_bCheckCollison(sX + 72, sY + 135, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_HEAD;
		}
		if (cCollison != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSpriteFrame;
			if (cCollison == EQUIPPOS_HEAD)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 72, sY + 135, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_RFINGER)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_LFINGER)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 100, sY + 185, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_NECK)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_TWOHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_RHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 57, sY + 186, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_LHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 90, sY + 170, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BODY)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_FULLBODY)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BOOTS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_ARMS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_PANTS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BACK)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH]->PutTransSprite(sX + 41, sY + 137, sFrame, m_dwCurTime);
		}
	}
	else if ((m_sPlayerType >= 4) && (m_sPlayerType <= 6))
	{
		cCollison = -1;
		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 40]->PutSpriteFast(sX + 171, sY + 290, m_sPlayerType - 4, m_dwCurTime);

		if (cEquipPoiStatus[EQUIPPOS_HEAD] == -1)
		{
			_GetHairColorRGB(((m_sPlayerAppr1 & 0x00F0) >> 4), &iR, &iG, &iB);
			m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 18 + 40]->PutSpriteRGB(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x0F00) >> 8, iR, iG, iB, m_dwCurTime);
		}

		m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + 19 + 40]->PutSpriteFast(sX + 171, sY + 290, (m_sPlayerAppr1 & 0x000F), m_dwCurTime);

		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			if ((sSprH == 12) && (sFrame == 0)) iSkirtDraw = 1;
		}
		if (cEquipPoiStatus[EQUIPPOS_BACK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BACK]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BACK]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 45, sY + 143, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 45, sY + 143, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 45, sY + 143, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BACK;
		}

		if ((cEquipPoiStatus[EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 1))
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BOOTS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[EQUIPPOS_PANTS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_PANTS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_PANTS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_PANTS;
		}

		if (cEquipPoiStatus[EQUIPPOS_ARMS] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_ARMS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_ARMS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_ARMS;
		}

		if ((cEquipPoiStatus[EQUIPPOS_BOOTS] != -1) && (iSkirtDraw == 0))
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BOOTS]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BOOTS]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BOOTS;
		}

		if (cEquipPoiStatus[EQUIPPOS_BODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_BODY]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_BODY]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_BODY;
		}
		if (cEquipPoiStatus[EQUIPPOS_FULLBODY] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_FULLBODY]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_FULLBODY]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 171, sY + 290, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 171, sY + 290, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_FULLBODY;
		}

		if (cEquipPoiStatus[EQUIPPOS_LHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_LHAND]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_LHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 84, sY + 175, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 84, sY + 175, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 84, sY + 175, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_LHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_RHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_RHAND]]->m_ItemColor;
			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_RHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_RHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_TWOHAND] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_TWOHAND]]->m_ItemColor;
			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_TWOHAND]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 60, sY + 191, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 60, sY + 191, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 60, sY + 191, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_TWOHAND;
		}

		if (cEquipPoiStatus[EQUIPPOS_NECK] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_NECK]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_NECK]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 35, sY + 120, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 35, sY + 120, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 35, sY + 120, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_NECK;
		}

		if (cEquipPoiStatus[EQUIPPOS_RFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_RFINGER]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_RFINGER]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 32, sY + 193, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 32, sY + 193, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 32, sY + 193, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_RFINGER;
		}

		if (cEquipPoiStatus[EQUIPPOS_LFINGER] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_LFINGER]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_LFINGER]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 100, sY + 185, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 100, sY + 185, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 100, sY + 185, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_LFINGER;
		}

		if (cEquipPoiStatus[EQUIPPOS_HEAD] != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_sSpriteFrame;
			ItemColor = m_pItemList[cEquipPoiStatus[EQUIPPOS_HEAD]]->m_ItemColor;

			if (m_bIsItemDisabled[cEquipPoiStatus[EQUIPPOS_HEAD]] == false)
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutSpriteRGB(sX + 72, sY + 139, sFrame, ItemColor, m_dwCurTime);
			}
			else
			{
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSpriteRGB(sX + 72, sY + 139, sFrame, ItemColor, m_dwCurTime);
			}
			if (m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->_bCheckCollison(sX + 72, sY + 139, sFrame, m_stMCursor.sX, m_stMCursor.sY))
				cCollison = EQUIPPOS_HEAD;
		}
		if (cCollison != -1)
		{
			sSprH = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSprite;
			sFrame = m_pItemList[cEquipPoiStatus[cCollison]]->m_sSpriteFrame;
			if (cCollison == EQUIPPOS_HEAD)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 72, sY + 139, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_RFINGER)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 32, sY + 193, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_LFINGER)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 100, sY + 185, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_NECK)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 35, sY + 120, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_TWOHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_RHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 60, sY + 191, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_LHAND)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 84, sY + 175, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BODY)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_FULLBODY)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BOOTS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_ARMS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_PANTS)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 171, sY + 290, sFrame, m_dwCurTime);
			else if (cCollison == EQUIPPOS_BACK)
				m_pSprite[SPRID_ITEMEQUIP_PIVOTPOINT + sSprH + 40]->PutTransSprite(sX + 45, sY + 143, sFrame, m_dwCurTime);
		}
	}


	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY + 326, 5, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY + 326, 4, false, m_bDialogTrans);

	if (onButton == 2)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 98, sY + 326, 45, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 98, sY + 326, 44, false, m_bDialogTrans);

	if (onButton == 3)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 180, sY + 326, 11, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 180, sY + 326, 10, false, m_bDialogTrans);

	if (onButton == 4)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY + 348, 23, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY + 348, 22, false, m_bDialogTrans);
#ifdef TitleClient
	if (onButton == 5)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 180, sY + 348, 53, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 180, sY + 348, 52, false, m_bDialogTrans);
#endif
	/*	if (onButton == 4)
			 DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +348, 71, FALSE, m_bDialogTrans);
		else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 15, sY +348, 70, FALSE, m_bDialogTrans);*/	// Not even used? wtf? lol
}

// 3.51 Level Up Dialog - Diuuude
void helbreath::DrawDialogBox_LevelUpSetting()
{
	short sX, sY, szX;
	uint64_t dwTime = m_dwCurTime;
	char cTxt[120];
	int iStats;

#ifdef _DEBUG
	fmt::format_to(G_cTxt, "m_stat[STAT_STR]: %d   m_angelStat[STAT_STR]: %d", m_stat[STAT_STR], m_angelStat[STAT_STR]);
	PutString(10, 10, G_cTxt, Color(255, 255, 255, 255));
#endif

	char onButton = m_dialogBoxes[12].OnButton();
	sX = m_dialogBoxes[12].m_X;
	sY = m_dialogBoxes[12].m_Y;
	szX = m_dialogBoxes[12].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX + 16, sY + 100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING1);
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING2);

	// Points Left - Display in green if > 0
	PutString(sX + 20, sY + 85, DRAW_DIALOGBOX_LEVELUP_SETTING3, Color(255, 0, 0, 0));
	fmt::format_to(cTxt, "%d", m_iLU_Point);
	if (m_iLU_Point > 0)
	{
		PutString(sX + 73, sY + 102, cTxt, Color(255, 0, 255, 0));
	}
	else
	{
		PutString(sX + 73, sY + 102, cTxt, Color(255, 0, 0, 0));
	}
	// Strength
	PutString(sX + 24, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING4, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_STR] - m_angelStat[STAT_STR]);
	PutString(sX + 109, sY + 125, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_STR] + m_luStat[STAT_STR] - m_angelStat[STAT_STR];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_STR] - m_angelStat[STAT_STR])
	{
		PutString(sX + 162, sY + 125, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 125, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 3 && (m_stat[STAT_STR] < Stats_Limit))
		//if (onButton == 3 && (m_stat[STAT_STR] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 127, 5, dwTime);
	if (onButton == 4 && (m_luStat[STAT_STR] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 127, 6, dwTime);


	PutString(sX + 24, sY + 144, DRAW_DIALOGBOX_LEVELUP_SETTING5, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_VIT]);
	PutString(sX + 109, sY + 144, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_VIT] + m_luStat[STAT_VIT];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_VIT])
	{
		PutString(sX + 162, sY + 144, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 144, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 5 && (m_stat[STAT_VIT] < Stats_Limit))
		//if (onButton == 5 && (m_stat[STAT_VIT] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 146, 5, dwTime);
	if (onButton == 6 && (m_luStat[STAT_VIT] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 146, 6, dwTime);

	// Dexterity
	PutString(sX + 24, sY + 163, DRAW_DIALOGBOX_LEVELUP_SETTING6, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_DEX] - m_angelStat[STAT_DEX]);
	PutString(sX + 109, sY + 163, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_DEX] + m_luStat[STAT_DEX] - m_angelStat[STAT_DEX];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_DEX] - m_angelStat[STAT_DEX])
	{
		PutString(sX + 162, sY + 163, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 163, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 7 && (m_stat[STAT_DEX] < Stats_Limit))
		//if (onButton == 7 && (m_stat[STAT_DEX] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 165, 5, dwTime);
	if (onButton == 8 && (m_luStat[STAT_DEX] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 165, 6, dwTime);

	// Intelligence
	PutString(sX + 24, sY + 182, DRAW_DIALOGBOX_LEVELUP_SETTING7, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_INT] - m_angelStat[STAT_INT]);
	PutString(sX + 109, sY + 182, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_INT] + m_luStat[STAT_INT] - m_angelStat[STAT_INT];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_INT] - m_angelStat[STAT_INT])
	{
		PutString(sX + 162, sY + 182, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 182, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 9 && (m_stat[STAT_INT] < Stats_Limit))
		//if (onButton == 9 && (m_stat[STAT_INT] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 184, 5, dwTime);
	if (onButton == 10 && (m_luStat[STAT_INT] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 184, 6, dwTime);

	// Magic
	PutString(sX + 24, sY + 201, DRAW_DIALOGBOX_LEVELUP_SETTING8, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_MAG] - m_angelStat[STAT_MAG]);
	PutString(sX + 109, sY + 201, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_MAG] + m_luStat[STAT_MAG] - m_angelStat[STAT_MAG];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_MAG] - m_angelStat[STAT_MAG])
	{
		PutString(sX + 162, sY + 201, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 201, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 11 && (m_stat[STAT_MAG] < Stats_Limit))
		//if (onButton == 11 && (m_stat[STAT_MAG] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 203, 5, dwTime);
	if (onButton == 12 && (m_luStat[STAT_MAG] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 203, 6, dwTime);

	// Charisma
	PutString(sX + 24, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING9, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_CHR]);
	PutString(sX + 109, sY + 220, cTxt, Color(255, 0, 0, 0));
	iStats = m_stat[STAT_CHR] + m_luStat[STAT_CHR];
	fmt::format_to(cTxt, "%d", iStats);
	if (iStats != m_stat[STAT_CHR])
	{
		PutString(sX + 162, sY + 220, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 220, cTxt, Color(255, 0, 0, 0));
	}
	if (onButton == 13 && (m_stat[STAT_CHR] < Stats_Limit))
		//if (onButton == 13 && (m_stat[STAT_CHR] < 450))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 222, 5, dwTime);
	if (onButton == 14 && (m_luStat[STAT_CHR] > 0))
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 222, 6, dwTime);

	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
	if ((m_luStat[STAT_STR] == 0) && (m_luStat[STAT_VIT] == 0) && (m_luStat[STAT_DEX] == 0) && (m_luStat[STAT_INT] == 0) && (m_luStat[STAT_MAG] == 0) && (m_luStat[STAT_CHR] == 0))
	{
		if (onButton == 2)
		{
			if (m_iLU_Point <= 0) DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 21);
		}
		else
		{
			if (m_iLU_Point <= 0) DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 20);
		}
	}
}

void helbreath::DrawDialogBox_CityHallMenu()
{
	enum modes
	{
		LEGIONPTSSERVICES = 9,
		TELEPORTLIST = 10
	};
	short sX, sY, szX;
	int  iTotalLines/*, iPointerLoc*/;
	double d1, d2, d3;
	char cTxt[120];
	int i;
	Point pointerLoc;

	char onButton = m_dialogBoxes[13].OnButton();

	sX = m_dialogBoxes[13].m_X;
	sY = m_dialogBoxes[13].m_Y;
	szX = m_dialogBoxes[13].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 18);//CityHall Menu Text

	switch (m_dialogBoxes[13].GetMode())
	{
		case 0:
			// citizenship req
			if (m_side == NEUTRAL)
			{
				if (onButton == 1)
					PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, Color(255, 4, 0, 50));
			}
			else PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_CITYHALL_MENU1, Color(255, 65, 65, 65));

			if (m_iRewardGold > 0)
			{
				if (onButton == 2)
					PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, Color(255, 4, 0, 50));
			}
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU4, Color(255, 65, 65, 65));

			// 3.51 Cityhall Menu - Request Hero's Items - Diuuude
			if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 10))
			{
				if (onButton == 3)
					PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, Color(255, 4, 0, 50));
			}
			else PutAlignedString(sX, sX + szX, sY + 120, DRAW_DIALOGBOX_CITYHALL_MENU8, Color(255, 65, 65, 65));

			// Cancel quest
			if (m_stQuest.sQuestType != 0 && !m_stQuest.bIsQuestCompleted)
			{
				if (onButton == 4)
					PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU10, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU10, Color(255, 4, 0, 50));
			}
			else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_CITYHALL_MENU10, Color(255, 65, 65, 65));

			// Legion point services
			if (onButton == 5)
				PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU11, Color(255, 255, 255, 255));
			else
				PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU11, Color(255, 4, 0, 50));

			// Teleport list
			if ((m_bIsCrusadeMode == false))
			{
				if (onButton == 6)
					PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU12, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU12, Color(255, 4, 0, 50));
			}
			else    PutAlignedString(sX, sX + szX, sY + 195, DRAW_DIALOGBOX_CITYHALL_MENU12, Color(255, 65, 65, 65));

			// Quest list
			if (onButton == 7)
				PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU9, Color(255, 255, 255, 255));
			else PutAlignedString(sX, sX + szX, sY + 220, DRAW_DIALOGBOX_CITYHALL_MENU9, Color(255, 4, 0, 50));

			//Change crusade role
			if (m_bIsCrusadeMode && m_side != NEUTRAL)
			{
				if (onButton == 8)
					PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU13, Color(255, 255, 255, 255));
				else PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU13, Color(255, 4, 0, 50));
			}
			else    PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU13, Color(255, 65, 65, 65));

			PutAlignedString(sX, sX + szX, sY + 285, DRAW_DIALOGBOX_CITYHALL_MENU17);//"Select an Item you want."

			break;

		case 1: // become citizen warning
			PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU18, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU19, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU20, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU21, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU22, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU23, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_CITYHALL_MENU24, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 200, DRAW_DIALOGBOX_CITYHALL_MENU25, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU26, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 230, DRAW_DIALOGBOX_CITYHALL_MENU27, Color(255, 55, 25, 25));//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 2: // Offering Citizenship.
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU28, Color(255, 55, 25, 25));//"
			break;

		case 3: //Congratulations!! You acquired Citizenship"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU29, Color(255, 55, 25, 25));//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 4: //Failed on acquiring citizenship!"
			PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU30, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 100, DRAW_DIALOGBOX_CITYHALL_MENU31, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 115, DRAW_DIALOGBOX_CITYHALL_MENU32, Color(255, 55, 25, 25));//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 5: //The prize gold for your"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU33, Color(255, 55, 25, 25));//"
			fmt::format_to(cTxt, DRAW_DIALOGBOX_CITYHALL_MENU34, m_iRewardGold);//"
			PutAlignedString(sX, sX + szX, sY + 140, cTxt, Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU35, Color(255, 55, 25, 25));//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 7:// 3.51 Cityhall Menu - Request Hero's Items - Diuuude
			PutAlignedString(sX, sX + szX, sY + 60, DRAW_DIALOGBOX_CITYHALL_MENU46, Color(255, 255, 255, 255));// Here are the Hero's Item aivable :
			// Hero's Cape (EK 300)
			if (m_iEnemyKillCount >= 300)
			{
				if (onButton == 1)
					PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU47, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Helm (EK 150 - Contrib 20)
			if ((m_iEnemyKillCount >= 150) && (m_iContribution >= 20))
			{
				if (onButton == 2)
					PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU48, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Cap (EK 100 - Contrib 20)
			if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 20))
			{
				if (onButton == 3)
					PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_CITYHALL_MENU49, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Armor (EK 300 - Contrib 30)
			if ((m_iEnemyKillCount >= 300) && (m_iContribution >= 30))
			{
				if (onButton == 4)
					PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_CITYHALL_MENU50, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Robe (EK 200 - Contrib 20)
			if ((m_iEnemyKillCount >= 200) && (m_iContribution >= 20))
			{
				if (onButton == 5)
					PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 215, DRAW_DIALOGBOX_CITYHALL_MENU51, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Hauberk (EK 100 - Contrib 10)
			if ((m_iEnemyKillCount >= 100) && (m_iContribution >= 10))
			{
				if (onButton == 6)
					PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 245, DRAW_DIALOGBOX_CITYHALL_MENU52, Color(255, 65, 65, 65));// Disabled Mode
			// Hero's Leggings (EK 150 - Contrib 15)
			if ((m_iEnemyKillCount >= 150) && (m_iContribution >= 15))
			{
				if (onButton == 7)
					PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, Color(255, 255, 255, 255));// On mouse over Mode
				else PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, Color(255, 4, 0, 50));// Normal Mode
			}
			else PutAlignedString(sX, sX + szX, sY + 275, DRAW_DIALOGBOX_CITYHALL_MENU53, Color(255, 65, 65, 65));// Disabled Mode
			break;

		case 8: // cancel current quest?
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU54, Color(255, 55, 25, 25));//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_CITYHALL_MENU55, Color(255, 55, 25, 25));//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case LEGIONPTSSERVICES:
			fmt::format_to(cTxt, "Xtreme points: %u", m_cash);
			PutAlignedString(sX, sX + szX, sY + 35, cTxt, Color(255, 55, 25, 25));
			if (onButton == 1)
				PutAlignedString(sX + 160, sX + szX, sY + 35, DRAW_DIALOGBOX_CITYHALL_MENU14, Color(255, 255, 255, 255));
			else
				PutAlignedString(sX + 160, sX + szX, sY + 35, DRAW_DIALOGBOX_CITYHALL_MENU14, Color(255, 4, 0, 50));

			PutAlignedString(sX - 20, sX + szX, sY + 55, DRAW_DIALOGBOX_CITYHALL_MENU15, Color(255, 55, 25, 25));
			PutAlignedString(sX + 180, sX + szX, sY + 55, DRAW_DIALOGBOX_CITYHALL_MENU16, Color(255, 55, 25, 25));

			pointerLoc = m_dialogBoxes[13].HandleScroll(16, CMD_LGNSVC_MAX);

			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);

			for (i = 0; i < 16; i++)
			{
				if (i + m_dialogBoxes[13].sView < CMD_LGNSVC_MAX)
				{
					if (onButton == i + 2)
					{
						PutAlignedString(sX - 30, sX + szX, sY + 75 + 15 * i, lgnPtsSvcs[i + m_dialogBoxes[13].sView].desc, Color(255, 255, 255, 255));
						fmt::format_to(cTxt, "%u", lgnPtsSvcs[i + m_dialogBoxes[13].sView].price);
						PutAlignedString(sX + 190, sX + szX, sY + 75 + 15 * i, cTxt, Color(255, 255, 255, 255));
					}
					else
					{
						PutAlignedString(sX - 30, sX + szX, sY + 75 + 15 * i, lgnPtsSvcs[i + m_dialogBoxes[13].sView].desc, Color(255, 4, 0, 50));
						fmt::format_to(cTxt, "%u", lgnPtsSvcs[i + m_dialogBoxes[13].sView].price);
						PutAlignedString(sX + 190, sX + szX, sY + 75 + 15 * i, cTxt, Color(255, 4, 0, 50));
					}
				}
			}

			break;

		case TELEPORTLIST:// Teleport List
			if (m_iTeleportMapCount > 0)
			{	//PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_CITYHALL_MENU69, 55,25,25); // "Teleporting to dungeon level 2."
				//PutAlignedString(sX, sX + szX, sY + 80, DRAW_DIALOGBOX_CITYHALL_MENU70, 55,25,25); // "5000Gold is required"
				//PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_CITYHALL_MENU71, 55,25,25); //
				//PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_CITYHALL_MENU72, 55,25,25);//
				//PutString2(sX + 35, sY + 250, DRAW_DIALOGBOX_CITYHALL_MENU72_1, 55,25,25);//"Civilians cannot go some area."
				for (int i = 0; i < m_iTeleportMapCount; i++)
				{
					if (m_stTeleportList[i].donateEvent)
					{
						fmt::format_to(G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU78, 5);
					}
					else
					{
						ZeroMemory(cTxt, sizeof(cTxt));
						GetOfficialMapName(m_stTeleportList[i].mapname, cTxt);
						fmt::format_to(G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost);
					}

					if (onButton == i + 1)
						PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, Color(255, 255, 255, 255));
					else
						PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, Color(255, 250, 250, 0));
				}
			}
			else if (m_iTeleportMapCount == -1)
			{
				PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, Color(255, 55, 25, 25));
				PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, Color(255, 55, 25, 25));
			}
			else
			{
				PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU76, Color(255, 55, 25, 25));//"There is no area that you can teleport."
			}
			break;

		case 11: //drajwer - ask for tooking hero mantle
			PutAlignedString(sX, sX + szX - 1, sY + 125, m_cTakeHeroItemName, Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 125, m_cTakeHeroItemName, Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 260, DRAW_DIALOGBOX_CITYHALL_MENU46A, Color(255, 55, 25, 25)); // would you like..
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 12: // Bleeding Island Teleport
			PutAlignedString(sX, sX + szX - 1, sY + 125, "Bleeding Island", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 125, "Bleeding Island", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX - 1, sY + 140, "(100) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 140, "(100) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 260, "Would you like to teleport here?", Color(255, 55, 25, 25)); // would you like..
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 13: // Players Arena Teleport
			PutAlignedString(sX, sX + szX - 1, sY + 125, "Players Arena", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 125, "Players Arena", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX - 1, sY + 140, "(500) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 140, "(500) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 260, "Would you like to teleport here?", Color(255, 55, 25, 25)); // would you like..
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 14: // Dungeon Level 2 Teleport
			PutAlignedString(sX, sX + szX - 1, sY + 125, "Dark Crypt", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 125, "Dark Crypt", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX - 1, sY + 140, "(5000) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 140, "(5000) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 260, "Would you like to teleport here?", Color(255, 55, 25, 25)); // would you like..
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 15: // Dungeon Level 2 Teleport
			PutAlignedString(sX, sX + szX - 1, sY + 125, "Promiseland", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 125, "Promiseland", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX - 1, sY + 140, "(5000) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX + 1, sX + szX, sY + 140, "(5000) Gold Required", Color(255, 55, 25, 25));
			PutAlignedString(sX, sX + szX, sY + 260, "Would you like to teleport here?", Color(255, 55, 25, 25)); // would you like..
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

	}
}
/*********************************************************************************************************************
**  void CGame::DrawDialogBox_ConfirmExchange()
**  description			:: paints the trade windows	Added confirmation window in v3.51								**
**********************************************************************************************************************/
void helbreath::DrawDialogBox_ConfirmExchange()
{
	short sX, sY;
	char onButton = m_dialogBoxes[41].OnButton();
	sX = m_dialogBoxes[41].m_X;
	sY = m_dialogBoxes[41].m_Y;

	switch (m_dialogBoxes[41].GetMode())
	{
		case 1: // Question
			PutString3(sX + 35, sY + 30, "Do you really want to exchange?", Color(255, 4, 0, 50));

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55, 2);
			break;

		case 2: // Waiting for response
			PutString3(sX + 45, sY + 36, "Waiting for response...", Color(255, 4, 0, 50));
			break;
	}
}

void helbreath::DrawDialogBox_YesNo()
{
	CDialogBox & dlg = m_dialogBoxes[DIALOG_YESNO];
	char onButton = dlg.OnButton();
	short sX = dlg.m_X;
	short sY = dlg.m_Y;

	switch (dlg.GetMode())
	{
		case 1: // Mail deletion
			PutString3(sX + 35, sY + 30, DRAW_DIALOGBOX_YESNO1, Color(255, 4, 0, 50));
			break;

		case 2: // Post deletion
			PutString3(sX + 35, sY + 30, DRAW_DIALOGBOX_YESNO2, Color(255, 4, 0, 50));
			break;
	}

	DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 55, (onButton == 1) ? 19 : 18);
	DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 55, (onButton == 2) ? 3 : 2);
}

void helbreath::DlgBoxClick_YesNo()
{
	CDialogBox & dlg = m_dialogBoxes[DIALOG_YESNO];
	CDialogBox * mdlg;
	char onButton = dlg.OnButton();

	switch (dlg.GetMode())
	{
		case 1: // delete mail
			mdlg = &m_dialogBoxes[DIALOG_MAILBOX];
			if (onButton == 1) // yes
			{
				if (mdlg->sV1 != -1)
				{
					mdlg->SetMode(0);
					bSendCommand(MSGID_REQ_DELETEMAIL, 0, 0, m_mails[mdlg->sV1]->id);
					m_mails.erase(m_mails.begin() + mdlg->sV1);
				}
				DisableDialogBox(DIALOG_YESNO);
				PlaySound('E', 14, 5);
				return;
			}
			else if (onButton == 2) // No
			{
				DisableDialogBox(DIALOG_YESNO);
				PlaySound('E', 14, 5);
				return;
			}
			break;

		case 2: // delete guild post
			mdlg = &m_dialogBoxes[DIALOG_GUILD];
			if (onButton == 1) // yes
			{
				if (mdlg->sV1 != -1)
				{
					mdlg->SetMode(8);
					bSendCommand(MSGID_REQ_DELETEGUILDPOST, 0, 0, m_gldBoard[mdlg->sV1]->id);
					m_gldBoard.erase(m_gldBoard.begin() + mdlg->sV1);
				}
				DisableDialogBox(DIALOG_YESNO);
				PlaySound('E', 14, 5);
				return;
			}
			else if (onButton == 2) // No
			{
				DisableDialogBox(DIALOG_YESNO);
				PlaySound('E', 14, 5);
				return;
			}
			break;
	}
}

/*********************************************************************************************************************
**  void CGame::DrawDialogBox_Exchange()
**  description			:: paints the trade windows																	**
**********************************************************************************************************************/
void helbreath::DrawDialogBox_Exchange()
{
	short sX, sY, szX, sXadd;
	uint64_t dwTime = m_dwCurTime;
	char cItemColor, cTxt[120], cTxt2[128];
	char cNameStr[120], cSubStr1[120], cSubStr2[120];
	int iLoc, i;

	char onButton = m_dialogBoxes[27].OnButton();
	sX = m_dialogBoxes[27].m_X;
	sY = m_dialogBoxes[27].m_Y;
	szX = m_dialogBoxes[27].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_NEWEXCHANGE, sX, sY, 0);
	switch (m_dialogBoxes[27].GetMode())
	{
		case 1: // Not yet confirmed exchange
			PutAlignedString(sX + 80, sX + 180, sY + 38, player_name, 35, 55, 35); // my name
			if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
				PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, 35, 55, 35);

			if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 == -1))
			{
				PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE9, 55, 25, 25); // Please wait until other player decides
				PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE10, 55, 25, 25);// to exchange. If you want to cancel the
				PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE11, 55, 25, 25);// exchange press the CANCEL button now.
				PutString_SprFont(sX + 220, sY + 310, "Exchange", 15, 15, 15);
			}
			else if ((m_stDialogBoxExchangeInfo[0].sV1 == -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
			{
				PutAlignedString(sX, sX + szX, sY + 205 + 10, DRAW_DIALOGBOX_EXCHANGE12, 55, 25, 25);// Other player offered an item exchange
				PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE13, 55, 25, 25);// Select an item which you want to exc-
				PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE14, 55, 25, 25);// hange with above item, drag it to the
				PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE15, 55, 25, 25);// blank and press the EXCHANGE button.
				PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE16, 55, 25, 25);// And you can also reject an offer by
				PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE17, 55, 25, 25);// pressing the CANCEL button.
				PutString_SprFont(sX + 220, sY + 310, "Exchange", 15, 15, 15);
			}
			else if ((m_stDialogBoxExchangeInfo[0].sV1 != -1) && (m_stDialogBoxExchangeInfo[4].sV1 != -1))
			{
				PutAlignedString(sX, sX + szX, sY + 205 + 10, DRAW_DIALOGBOX_EXCHANGE18, 55, 25, 25);// The preparation for item exchange
				PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE19, 55, 25, 25);// has been finished. Press the EXCHANGE
				PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE20, 55, 25, 25);// button to exchange as above. Press the
				PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE21, 55, 25, 25);// CANCEL button to cancel. Occasionally
				PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE22, 55, 25, 25);// when you press the EXCHANGE button, you
				PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE23, 55, 25, 25);// will not be able to cancel the exchange.
				if (onButton == 1)
					PutString_SprFont(sX + 220, sY + 310, "Exchange", 6, 6, 20);
				else PutString_SprFont(sX + 220, sY + 310, "Exchange", 0, 0, 7);
			}
			if (onButton == 2 && (m_bIsDialogEnabled[41] == false))
				PutString_SprFont(sX + 450, sY + 310, "Cancel", 6, 6, 20);
			else PutString_SprFont(sX + 450, sY + 310, "Cancel", 0, 0, 7);

			for (i = 0; i < 8; i++) // draw items
			{
				sXadd = (58 * i) + 48; if (i > 3) sXadd += 20;
				if (m_stDialogBoxExchangeInfo[i].sV1 != -1)
				{
					cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
					if (cItemColor == 0)
					{
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
					}
					else
					{
						switch (m_stDialogBoxExchangeInfo[i].sV1)
						{//sV1 : Sprite
							case 1: //  Swds
							case 2: //  Bows
							case 3: //  Shields
							case 15: // Axes hammers
							case 17: // Wands
								m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
									, m_stDialogBoxExchangeInfo[i].sV2, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
								break;
							default: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
								, m_stDialogBoxExchangeInfo[i].sV2, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
								break;
						}
					}

					// If pointer over item then show this item data
					if (m_stMCursor.sX >= sX + sXadd - 6 && m_stMCursor.sX <= sX + sXadd + 42
						&& m_stMCursor.sY >= sY + 61 && m_stMCursor.sY <= sY + 200)
					{
						std::vector<string> * lines = GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1,
							m_stDialogBoxExchangeInfo[i].sockets, m_stDialogBoxExchangeInfo[i].sV3);

						iLoc = 0;

						if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
						{
							string str;
							cTxt[0] = 0;
							// Crafting Magins completion fix
							if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
							{
								if (m_stDialogBoxExchangeInfo[i].sV2 > 5 && m_stDialogBoxExchangeInfo[i].sV2 < 10)
								{
									fmt::format_to(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
								}
							}
							else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
							{
								fmt::format_to(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
							}
							else
							{
								fmt::format_to(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
							}
							if (cTxt[0])
							{
								str.append(cTxt);
								lines->push_back(str);
							}
						}

						{
							string str;
							fmt::format_to(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);

							str.append(cTxt);
							lines->push_back(str);
						}

						std::vector<string>::iterator iter = lines->begin(), end = lines->end();

						uint32_t maxWidth = 0;

						while (iter != end)
						{
							if (iter->size() > maxWidth)
								maxWidth = iter->size();

							++iter;
						}
						//DIRECTX m_DDraw.DrawShadowBox(sX + 5-3, sY + 215 - 1, sX + 5 + maxWidth * 5.5, sY + 215+1 + 13*lines->size());

						iter = lines->begin();

						if (Color(m_itemColor) != Color(255, 255, 255, 255))
						{
							PutString(sX + 5, sY + 215 + iLoc, iter->c_str(), m_itemColor, false, 1);
						}
						else
						{
							PutString(sX + 5, sY + 215 + iLoc, iter->c_str(), Color(255, 180, 180, 180), false, 1);
						}
						iLoc += 13;
						++iter;

						while (iter != end)
						{
							PutString(sX + 5, sY + 215 + iLoc, iter->c_str(), Color(255, 150, 150, 150), false, 1);
							iLoc += 13;
							++iter;
						}
					}
				}
			}
			break;

		case 2: // You have confirmed the exchange
			PutAlignedString(sX + 80, sX + 180, sY + 38, player_name, Color(255, 35, 55, 35)); // my name
			if (m_stDialogBoxExchangeInfo[4].sV1 != -1) // Other name if applicable
				PutAlignedString(sX + 250, sX + 540, sY + 38, m_stDialogBoxExchangeInfo[4].cStr2, Color(255, 35, 55, 35));

			fmt::format_to(cTxt, DRAW_DIALOGBOX_EXCHANGE33, m_stDialogBoxExchangeInfo[4].cStr2);
			PutAlignedString(sX, sX + szX, sY + 205 + 10, cTxt, Color(255, 55, 25, 25));                     // Please wait until %s agrees to
			PutAlignedString(sX, sX + szX, sY + 220 + 10, DRAW_DIALOGBOX_EXCHANGE34, Color(255, 55, 25, 25));// exchange. The exchange can't be achieved
			PutAlignedString(sX, sX + szX, sY + 235 + 10, DRAW_DIALOGBOX_EXCHANGE35, Color(255, 55, 25, 25));// unless both people agree.
			PutAlignedString(sX, sX + szX, sY + 250 + 10, DRAW_DIALOGBOX_EXCHANGE36, Color(255, 55, 25, 25));//  If other player does not decide to exchange
			PutAlignedString(sX, sX + szX, sY + 265 + 10, DRAW_DIALOGBOX_EXCHANGE37, Color(255, 55, 25, 25));// you can cancel the exchange by pressing the
			PutAlignedString(sX, sX + szX, sY + 280 + 10, DRAW_DIALOGBOX_EXCHANGE38, Color(255, 55, 25, 25));// CANCEL button. But if other player already
			PutAlignedString(sX, sX + szX, sY + 295 + 10, DRAW_DIALOGBOX_EXCHANGE39, Color(255, 55, 25, 25));// decided to exchange, you can't cancel anymore

			for (i = 0; i < 8; i++) // draw items
			{
				sXadd = (58 * i) + 48; if (i > 3) sXadd += 20;
				if (m_stDialogBoxExchangeInfo[i].sV1 != -1)
				{
					cItemColor = m_stDialogBoxExchangeInfo[i].sV4;
					if (cItemColor == 0)
					{
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteFast(sX + sXadd, sY + 130, m_stDialogBoxExchangeInfo[i].sV2, dwTime);
					}
					else
					{
						switch (m_stDialogBoxExchangeInfo[i].sV1)
						{
							case 1: // Swds
							case 2: // Bows
							case 3: // Shields
							case 15: // Axes hammers
							case 17: // Wands
								m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
									, m_stDialogBoxExchangeInfo[i].sV2, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
								break;
							default: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_stDialogBoxExchangeInfo[i].sV1]->PutSpriteRGB(sX + sXadd, sY + 130
								, m_stDialogBoxExchangeInfo[i].sV2, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
								break;
						}
					}
					// If pointer over item then show this item data
					if (m_stMCursor.sX >= sX + sXadd - 6 && m_stMCursor.sX <= sX + sXadd + 42
						&& m_stMCursor.sY >= sY + 61 && m_stMCursor.sY <= sY + 200)
					{
						std::vector<string> * lines = GetItemName(m_stDialogBoxExchangeInfo[i].cStr1, m_stDialogBoxExchangeInfo[i].dwV1,
							m_stDialogBoxExchangeInfo[i].sockets, m_stDialogBoxExchangeInfo[i].sV3);

						iLoc = 0;

						if (m_stDialogBoxExchangeInfo[i].sV5 != -1) // completion
						{
							string str;
							// Crafting Magins completion fix
							if (m_stDialogBoxExchangeInfo[i].sV1 == 22)
							{
								if (m_stDialogBoxExchangeInfo[i].sV2 > 5 && m_stDialogBoxExchangeInfo[i].sV2 < 10)
								{
									fmt::format_to(cTxt, GET_ITEM_NAME2, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Completion - 100
								}
							}
							else if (m_stDialogBoxExchangeInfo[i].sV1 == 6)
							{
								fmt::format_to(cTxt, GET_ITEM_NAME1, (m_stDialogBoxExchangeInfo[i].sV7 - 100)); //Purity
							}
							else
							{
								fmt::format_to(cTxt, GET_ITEM_NAME2, m_stDialogBoxExchangeInfo[i].sV7); //Completion
							}
							str.append(cTxt);
							lines->push_back(str);
						}

						{
							string str;
							fmt::format_to(cTxt, DRAW_DIALOGBOX_EXCHANGE3, m_stDialogBoxExchangeInfo[i].sV5, m_stDialogBoxExchangeInfo[i].sV6);

							str.append(cTxt);
							lines->push_back(str);
						}

						std::vector<string>::iterator iter = lines->begin(), end = lines->end();

						uint32_t maxWidth = 0;

						while (iter != end)
						{
							if (iter->size() > maxWidth)
								maxWidth = iter->size();

							++iter;
						}
						//DIRECTX m_DDraw.DrawShadowBox(sX + 5-3, sY + 215 - 1, sX + 5 + maxWidth * 5.5, sY + 215+1 + 13*lines->size());

						iter = lines->begin();

						if (Color(m_itemColor) != Color(255, 255, 255, 255))
						{
							PutString(sX + 5, sY + 215 + iLoc, *iter, Color(m_itemColor), false, 1);
						}
						else
						{
							PutString(sX + 5, sY + 215 + iLoc, *iter, Color(255, 180, 180, 180), false, 1);
						}
						iLoc += 13;
						++iter;

						while (iter != end)
						{
							PutString(sX + 5, sY + 215 + iLoc, *iter, Color(255, 150, 150, 150), false, 1);
							iLoc += 13;
							++iter;
						}
					}
				}
			}
			break;
	}
}

void helbreath::DrawDialogBox_Fishing()
{

	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	char  cTxt[120];

	char onButton = m_dialogBoxes[24].OnButton();
	sX = m_dialogBoxes[24].m_X;
	sY = m_dialogBoxes[24].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_dialogBoxes[24].cStr, 0, cStr1, cStr2, cStr3);

	switch (m_dialogBoxes[24].GetMode())
	{
		case 0:
			m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_dialogBoxes[24].sV3]->PutSpriteFast(sX + 18 + 35, sY + 18 + 17, m_dialogBoxes[24].sV4, dwTime);
			fmt::format_to(cTxt, "%s", cStr1);
			PutString(sX + 98, sY + 14, cTxt, Color(255, 255, 255, 255));
			fmt::format_to(cTxt, DRAW_DIALOGBOX_FISHING1, m_dialogBoxes[24].sV2);
			PutString(sX + 98, sY + 28, cTxt, Color(255, 0, 0, 0));
			PutString(sX + 97, sY + 43, DRAW_DIALOGBOX_FISHING2, Color(255, 0, 0, 0));
			fmt::format_to(cTxt, "%d %%", m_dialogBoxes[24].sV1);
			PutString_SprFont(sX + 157, sY + 40, cTxt, 10, 0, 0);
			if (onButton == 1)
				PutString_SprFont(sX + 160, sY + 70, "Try Now!", 6, 6, 20);
			else PutString_SprFont(sX + 160, sY + 70, "Try Now!", 0, 0, 7);
			break;
	}

}

void helbreath::DrawDialogBox_GuildMenu()
{
	short sX, sY, szX;
	int iAdjX, iAdjY;

	char onButton = m_dialogBoxes[7].OnButton();
	sX = m_dialogBoxes[7].m_X;
	sY = m_dialogBoxes[7].m_Y;
	szX = m_dialogBoxes[7].sSizeX;

	iAdjX = -13;
	iAdjY = 30;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_dialogBoxes[7].GetMode())
	{
		case 0:
			if ((m_iGuildRank == -1) && /*(m_stat[STAT_CHR] >= 20) &&*/ (m_iLevel >= 100))
			{ // Guild Req xRisenx
				if (onButton == 1)
					PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 4, 0, 50);//"
			}
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 65, DRAW_DIALOGBOX_GUILDMENU1, 45, 45, 45);//"

			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 2)
					PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 4, 0, 50);//"
			}
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU4, 65, 65, 65);//"

			if (onButton == 3)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU7, 4, 0, 50);//"

			if (onButton == 4)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 255, 255, 255);//"
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 125, DRAW_DIALOGBOX_GUILDMENU9, 4, 0, 50);//"

			if (m_iGuildRank == GUILDRANK_MASTER && m_iFightzoneNumber == 0)
			{
				if (onButton == 5)
					PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 4, 0, 50);//"

			}
			else if (m_iGuildRank == GUILDRANK_MASTER && m_iFightzoneNumber > 0)
			{
				if (onButton == 6)
					PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 4, 0, 50);//"

			}
			else if (m_iFightzoneNumber < 0)
			{
				PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU13, 65, 65, 65);//"
			}
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 145, DRAW_DIALOGBOX_GUILDMENU11, 65, 65, 65);//"

			PutAlignedString(sX, sX + szX, sY + iAdjY + 205, DRAW_DIALOGBOX_GUILDMENU17);//"
			break;

		case 1:
			PutAlignedString(sX + 24, sX + 239, sY + 125, DRAW_DIALOGBOX_GUILDMENU18, 55, 25, 25);//"
			PutString(sX + 75, sY + 144, "____________________", Color(255, 25, 35, 25));

			if (iGetTopDialogBoxIndex() != 7)
				PutString(sX + 75, sY + 140, m_cGuildName, Color(255, 255, 255, 255), false, 2);

			if (onButton == 1)
			{
				if ((strcmp(m_cGuildName, "NONE") == 0) || (strlen(m_cGuildName) == 0))
				{
					DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 24);//Create Gray Button
				}
				else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 25);//Create Highlight Button
			}
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 24);//Create Gray Button

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);//Red Cancel Button
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);//Gray Cancel Button
			break;

		case 2:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU19, 55, 25, 25);//"
			break;
		case 3:
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU20, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 140, m_cGuildName, 55, 25, 25);
			PutAlignedString(sX, sX + szX, sY + 144, "____________________", 25, 35, 25);
			PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU21, 55, 25, 25);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
		case 4:
			PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU22, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU23, 55, 25, 25);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
		case 5:
			PutAlignedString(sX, sX + szX, sY + 90, DRAW_DIALOGBOX_GUILDMENU24);
			PutAlignedString(sX, sX + szX, sY + 105, m_cGuildName, 35, 35, 35);
			PutAlignedString(sX, sX + szX, sY + 109, "____________________", 0, 0, 0);
			PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU25);//"
			PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU26);//"
			PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU27);//"
			PutAlignedString(sX, sX + szX, sY + 185, DRAW_DIALOGBOX_GUILDMENU28, 55, 25, 25);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;
		case 6:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU29, 55, 25, 25);//"
			break;
		case 7:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU30, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
		case 8:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU31, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
		case 9:
			PutAlignedString(sX, sX + szX, sY + iAdjY + 60, DRAW_DIALOGBOX_GUILDMENU32);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 75, DRAW_DIALOGBOX_GUILDMENU33);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU34);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU35);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU36);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 31);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 30);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;
		case 10:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU37, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
		case 11:
			PutAlignedString(sX, sX + szX, sY + iAdjY + 60, DRAW_DIALOGBOX_GUILDMENU38);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 75, DRAW_DIALOGBOX_GUILDMENU39);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 90, DRAW_DIALOGBOX_GUILDMENU40);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 105, DRAW_DIALOGBOX_GUILDMENU41);//
			PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU42);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 31);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 30);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;
		case 12:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU43, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 13:
			PutAlignedString(sX, sX + szX, sY + iAdjY + 40, DRAW_DIALOGBOX_GUILDMENU44);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 55, DRAW_DIALOGBOX_GUILDMENU45);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 70, DRAW_DIALOGBOX_GUILDMENU46);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 85, DRAW_DIALOGBOX_GUILDMENU47);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 100, DRAW_DIALOGBOX_GUILDMENU48);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 115, DRAW_DIALOGBOX_GUILDMENU49);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 130, DRAW_DIALOGBOX_GUILDMENU50);//"

			if (onButton == 1)
				PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU51, Color(255, 4, 0, 50));

			if (onButton == 2)
				PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 170, DRAW_DIALOGBOX_GUILDMENU53, Color(255, 4, 0, 50));

			if (onButton == 3)
				PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU55, Color(255, 4, 0, 50));

			if (onButton == 4)
				PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 190, DRAW_DIALOGBOX_GUILDMENU57, Color(255, 4, 0, 50));

			if (onButton == 5)
				PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU59, Color(255, 4, 0, 50));

			if (onButton == 6)
				PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 210, DRAW_DIALOGBOX_GUILDMENU61, Color(255, 4, 0, 50));

			if (onButton == 7)
				PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 65 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU63, Color(255, 4, 0, 50));

			if (onButton == 8)
				PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, Color(255, 255, 255, 255));
			else PutString(sX + iAdjX + 150 + 25 - 23, sY + iAdjY + 230, DRAW_DIALOGBOX_GUILDMENU65, Color(255, 4, 0, 50));

			if (onButton == 9)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 14:
			PutAlignedString(sX, sX + szX, sY + 130, DRAW_DIALOGBOX_GUILDMENU66, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_GUILDMENU67, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 160, DRAW_DIALOGBOX_GUILDMENU68, 55, 25, 25);//
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 15:
			PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU69, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU70, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 16:
			PutAlignedString(sX, sX + szX, sY + 135, DRAW_DIALOGBOX_GUILDMENU71, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_GUILDMENU72, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 17:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU73, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 18:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU74, 55, 25, 25);//"
			break;

		case 19:
			if (m_iFightzoneNumber > 0)
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET, 0, 0, 0, 0, 0);
			m_dialogBoxes[7].SetMode(0);
			break;

		case 20:
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_GUILDMENU75, 55, 25, 25);//"
			PutString(sX + 75, sY + 144, "____________________", Color(255, 25, 35, 25));
			PutString(sX + 75, sY + 140, m_cGuildName, Color(255, 255, 255, 255), false, 2);
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 25);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 24);
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 21:
			PutAlignedString(sX, sX + szX, sY + iAdjY + 95, DRAW_DIALOGBOX_GUILDMENU76, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 110, DRAW_DIALOGBOX_GUILDMENU77, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 135, DRAW_DIALOGBOX_GUILDMENU78, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 150, DRAW_DIALOGBOX_GUILDMENU79, 55, 25, 25);//"
			PutAlignedString(sX, sX + szX, sY + iAdjY + 165, DRAW_DIALOGBOX_GUILDMENU80, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 22:
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_GUILDMENU81, 55, 25, 25);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
	}
}

void helbreath::DrawDialogBox_Guild()
{
	CDialogBox & dlg = m_dialogBoxes[DIALOG_GUILD];

	char txt[200];
	int iTotalLines, iPointerLoc, maxLines, line = 0;
	double d1, d2, d3;
	uint32_t view;
	MemberList::const_iterator it;
	Point pointerLoc;

	char onButton = dlg.OnButton();
	short sX = dlg.m_X;
	short sY = dlg.m_Y;
	short szX = dlg.sSizeX;

	int iAdjX = -13, cropX = 22;
	int iAdjY = 30;

	if (dlg.GetMode() != 1 && // members list
		!(dlg.GetMode() >= 8 && dlg.GetMode() <= 10)) // message board
	{
		fmt::format_to(txt, DRAW_DIALOGBOX_GUILD4, m_guild.GetOnlineCnt() + 1);
		PutAlignedString(sX + cropX, sX + szX - cropX, sY + 35, txt);

		DisplayCommaNumber_G_cTxt(m_guild.m_gold);
		fmt::format_to(txt, DRAW_DIALOGBOX_GUILD10, G_cTxt);
		PutAlignedString(sX + cropX, sX + szX - cropX, sY + 50, txt);

		DisplayCommaNumber_G_cTxt(m_guild.m_maj);
		fmt::format_to(txt, DRAW_DIALOGBOX_GUILD11, G_cTxt);
		PutAlignedString(sX + cropX, sX + szX - cropX, sY + 35, txt);

		DisplayCommaNumber_G_cTxt(m_guild.m_cont);
		fmt::format_to(txt, DRAW_DIALOGBOX_GUILD29, G_cTxt);
		PutAlignedString(sX + cropX, sX + szX - cropX, sY + 50, txt);
	}

	switch (dlg.GetMode())
	{
		case 0:
			// online members
	//uncomment		ButtonString(dlg, 1, DRAW_DIALOGBOX_GUILD1);
			// give gold
	//uncomment		ButtonString(dlg, 2, DRAW_DIALOGBOX_GUILD2);
			// give maj
	//uncomment		ButtonString(dlg, 3, DRAW_DIALOGBOX_GUILD3);
			// give cont
	//uncomment		ButtonString(dlg, 4, DRAW_DIALOGBOX_GUILD43);
			// Upgrades
	//uncomment		ButtonString(dlg, 5, DRAW_DIALOGBOX_GUILD12);
			// Message board
	//uncomment		ButtonString(dlg, 6, DRAW_DIALOGBOX_GUILD45);

			break;

		case 1:
			PutAlignedString(sX + 5, sX + 5 + szX / 3, sY + 35, DRAW_DIALOGBOX_GUILD5, 55, 25, 25);
			PutAlignedString(sX + szX / 3 - 16, sX + szX / 3 * 2 - 11, sY + 35, DRAW_DIALOGBOX_GUILD6, 55, 25, 25);
			PutAlignedString(sX + szX / 3 * 2 - 38, sX + szX, sY + 35, DRAW_DIALOGBOX_GUILD7, 55, 25, 25);


			iTotalLines = m_guild.GetOnlineCnt();

			maxLines = 16;
			if (gldRankPerm[m_iGuildRank].canSummon)
				maxLines--;

			if (gldRankPerm[m_iGuildRank].canPromote)
				maxLines--;

			pointerLoc = dlg.HandleScroll(maxLines, iTotalLines);

			if (iTotalLines > maxLines)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			view = dlg.sView;

			it = m_guild.m_onlineList.begin();

			while (view > 0 && it != m_guild.m_onlineList.end())
			{
				++it;
				view--;
			}

			for (int i = 0; i < maxLines; i++, ++it)
			{
				if (it == m_guild.m_onlineList.end())
					break;
				if (i + dlg.sView < m_guild.m_onlineList.size())
				{
					if (gldRankPerm[m_iGuildRank].canSummon && onButton == i + 2)
					{
						PutAlignedString(sX + 5, sX + 5 + szX / 3, sY + 55 + 15 * i, (*it).first.c_str(), 255, 255, 255);
					}
					else
					{
						PutAlignedString(sX + 5, sX + 5 + szX / 3, sY + 55 + 15 * i, (*it).first.c_str());
					}

					if ((*it).second.rank < GUILDRANK_MAX)
					{
						if (gldRankPerm[m_iGuildRank].canPromote && onButton == i + 18 &&
							m_iGuildRank < (*it).second.rank)
						{
							PutAlignedString(sX + szX / 3 - 16, sX + szX / 3 * 2 - 11, sY + 55 + 15 * i,
								GetGuildRankName((*it).second.rank), 255, 255, 255);
						}
						else
						{
							PutAlignedString(sX + szX / 3 - 16, sX + szX / 3 * 2 - 11, sY + 55 + 15 * i,
								GetGuildRankName((*it).second.rank));
						}
					}
					GetOfficialMapName(GetMapName((*it).second.map), txt);
					PutAlignedString(sX + szX / 3 * 2 - 40 + 1, sX + szX / 3 * 3 + 1, sY + 55 + 15 * i, txt);
				}
			}

			if (gldRankPerm[m_iGuildRank].canSummon)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD8, GUILDSUMMONSGOLDCOST);
				PutAlignedString(sX, sX + szX, sY + 265, txt, 55, 25, 25);
			}

			if (gldRankPerm[m_iGuildRank].canPromote)
			{
				PutAlignedString(sX, sX + szX, sY + 280, DRAW_DIALOGBOX_GUILD9, 55, 25, 25);
			}

			if (onButton == 1)
				PutAlignedString(sX, sX + szX, sY + 295 + 15 * line, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 295 + 15 * line, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);
			break;

		case 2:
			// warehouse
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD13, m_guild.m_upgrades[GU_WAREHOUSE]);
			if (onButton == 1)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 4, 0, 50);
			line++;

			// teleport
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD14, m_guild.m_upgrades[GU_SUMMONS]);
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 4, 0, 50);
			line++;

			// captaincy
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD33, m_guild.m_upgrades[GU_CAPTAINCY], m_guild.m_captains,
				GetGuildRankName(GUILDRANK_CAPTAIN));
			if (onButton == 3)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 4, 0, 50);
			line++;

			// raidmasters
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD34, m_guild.m_upgrades[GU_RAIDMASTERS], m_guild.m_raidmasters,
				GetGuildRankName(GUILDRANK_RAIDMASTER));
			if (onButton == 4)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 4, 0, 50);
			line++;

			// huntmasters
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD35, m_guild.m_upgrades[GU_HUNTMASTERS], m_guild.m_huntmasters,
				GetGuildRankName(GUILDRANK_HUNTMASTER));
			if (onButton == 5)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, txt, 4, 0, 50);
			line++;

			line++;
			// back
			if (onButton == 7)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * line, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);

			break;

		case 3:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD16, m_guild.m_upgrades[GU_WAREHOUSE]);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 0, txt);

			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 1)
					PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 255, 255, 255);
				else PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 4, 0, 50);
			}

			// back
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);

			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 2, DRAW_DIALOGBOX_GUILD18, true);

			for (int i = 0; i < gldUps[GU_WAREHOUSE].maxLvl; i++)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (5 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_WAREHOUSE].costGold[i + 1] / 1000,
					gldUps[GU_WAREHOUSE].costMaj[i + 1] / 1000, gldUps[GU_WAREHOUSE].costCont[i + 1] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (5 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD22, maxGWHItems[i + 1]);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (6 + i * 2), txt);
			}
			break;

		case 4:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD23, m_guild.m_upgrades[GU_SUMMONS]);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 0, txt);

			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 1)
					PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 255, 255, 255);
				else PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 4, 0, 50);
			}

			// back
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);


			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD24, GUILDSUMMONSGOLDCOST);
			PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 2, txt, true);

			{
				int lvl = 1;
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, lvl);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 6, txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_SUMMONS].costGold[lvl] / 1000,
					gldUps[GU_SUMMONS].costMaj[lvl] / 1000, gldUps[GU_SUMMONS].costCont[lvl] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 6, txt);

				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 7, DRAW_DIALOGBOX_GUILD25, true);
			}
			{
				int lvl = 2;
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, lvl);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 8, txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_SUMMONS].costGold[lvl] / 1000,
					gldUps[GU_SUMMONS].costMaj[lvl] / 1000, gldUps[GU_SUMMONS].costCont[lvl] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 8, txt);

				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 9, DRAW_DIALOGBOX_GUILD26, true);
			}
			{
				int lvl = 3;
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, lvl);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 10, txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_SUMMONS].costGold[lvl] / 1000,
					gldUps[GU_SUMMONS].costMaj[lvl] / 1000, gldUps[GU_SUMMONS].costCont[lvl] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 10, txt);

				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 11, DRAW_DIALOGBOX_GUILD27, true);
			}
			{
				int lvl = 4;
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, lvl);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 13, txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_SUMMONS].costGold[lvl] / 1000,
					gldUps[GU_SUMMONS].costMaj[lvl] / 1000, gldUps[GU_SUMMONS].costCont[lvl] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 13, txt);

				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 14, DRAW_DIALOGBOX_GUILD28, true);
			}
			break;

		case 5:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD30, m_guild.m_upgrades[GU_CAPTAINCY]);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 0, txt);

			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD44, GetGuildRankName(GUILDRANK_CAPTAIN), m_guild.m_captains);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 1, txt);

			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 1)
					PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 255, 255, 255);
				else PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 4, 0, 50);
			}

			// back
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);

			PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 2, DRAW_DIALOGBOX_GUILD36, true);

			for (int i = 0; i < gldUps[GU_CAPTAINCY].maxLvl; i++)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (7 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_CAPTAINCY].costGold[i + 1] / 1000,
					gldUps[GU_CAPTAINCY].costMaj[i + 1] / 1000, gldUps[GU_CAPTAINCY].costCont[i + 1] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (7 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD37, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (8 + i * 2), txt);
			}
			break;

		case 6:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD31, m_guild.m_upgrades[GU_RAIDMASTERS]);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 0, txt);

			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD44, GetGuildRankName(GUILDRANK_RAIDMASTER), m_guild.m_raidmasters);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 1, txt);

			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 1)
					PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 255, 255, 255);
				else PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 4, 0, 50);
			}

			// back
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);

			PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 2, DRAW_DIALOGBOX_GUILD40, true);

			for (int i = 0; i < gldUps[GU_RAIDMASTERS].maxLvl; i++)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (8 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_RAIDMASTERS].costGold[i + 1] / 1000,
					gldUps[GU_RAIDMASTERS].costMaj[i + 1] / 1000, gldUps[GU_RAIDMASTERS].costCont[i + 1] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (8 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD38, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (9 + i * 2), txt);
			}
			break;

		case 7:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD32, m_guild.m_upgrades[GU_HUNTMASTERS]);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 0, txt);

			fmt::format_to(txt, DRAW_DIALOGBOX_GUILD44, GetGuildRankName(GUILDRANK_HUNTMASTER), m_guild.m_huntmasters);
			PutAlignedString(sX + cropX, sX + szX, sY + iAdjY + 45 + 15 * 1, txt);

			// upgrade
			if (m_iGuildRank == GUILDRANK_MASTER)
			{
				if (onButton == 1)
					PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 255, 255, 255);
				else PutAlignedString(sX + szX / 3 * 2, sX + szX, sY + iAdjY + 45 + 15 * 0, DRAW_DIALOGBOX_GUILD17, 4, 0, 50);
			}

			// back
			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + iAdjY + 45 + 15 * 1, DRAW_DIALOGBOX_GUILD15, 4, 0, 50);

			PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * 2, DRAW_DIALOGBOX_GUILD41, true);

			for (int i = 0; i < gldUps[GU_HUNTMASTERS].maxLvl; i++)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD20, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (8 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD21, gldUps[GU_HUNTMASTERS].costGold[i + 1] / 1000,
					gldUps[GU_HUNTMASTERS].costMaj[i + 1] / 1000, gldUps[GU_HUNTMASTERS].costCont[i + 1] / 1000);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (8 + i * 2), txt);

				fmt::format_to(txt, DRAW_DIALOGBOX_GUILD39, i + 1);
				PutAlignedString(sX + cropX, sX + szX - cropX, sY + iAdjY + 45 + 15 * (9 + i * 2), txt);
			}
			break;

		case 8:
			if (m_gldBoard.size() > 15)
			{
				Point pointerLoc = dlg.HandleScroll(15, m_gldBoard.size());

				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX19, GUILDBOARD_POST_COST);
			//uncomment		ButtonString(dlg, 1, G_cTxt);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX20, m_gldBoard.size());
			PutAlignedString(sX + 161, sX + szX, sY + 35, G_cTxt);

			PutAlignedString(sX - 20, sX + szX / 2, sY + 55, DRAW_DIALOGBOX_MAILBOX2);
			PutAlignedString(sX + 56, sX + szX, sY + 55, DRAW_DIALOGBOX_MAILBOX21);
			PutAlignedString(sX + 158, sX + szX, sY + 55, DRAW_DIALOGBOX_MAILBOX4);

			for (int i = 0; i < 15; i++)
			{
				int idx = i + dlg.sView;
				if (idx < m_gldBoard.size())
				{
					idx = m_gldBoard.size() - 1 - idx;
					PutAlignedString(sX + 25, sX + szX / 3 * 2, sY + 75 + 15 * i, m_gldBoard[idx]->title.c_str(), (onButton == i + 4));
					PutAlignedString(sX + 56, sX + szX, sY + 75 + 15 * i, m_gldBoard[idx]->sender.c_str(), (onButton == i + 4));
					fmt::format_to(G_cTxt, "%.2u/%.2u", m_gldBoard[idx]->date.day, m_gldBoard[idx]->date.month);
					PutAlignedString(sX + 158, sX + szX, sY + 75 + 15 * i, G_cTxt, (onButton == i + 4));
				}
			}

			//uncomment		ButtonString(dlg, 3, DRAW_DIALOGBOX_MAILBOX16);
			break;

		case 9:
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX12, m_gldBoard[dlg.sV1]->sender.c_str());
			//PutLabel(dlg.GetButton(1), G_cTxt, POS_LEFT);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX17, m_gldBoard[dlg.sV1]->title.c_str());
			//PutLabel(dlg.GetButton(2), G_cTxt, POS_LEFT);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX13, strlen(dlg.txt), MAX_MAIL_MSG_LENGTH - 1);
			//PutLabel(dlg.GetButton(3), G_cTxt, POS_LEFT);

			//if(m_gldBoard[dlg.sV1]->msg)
			//	PutAlignedString(dlg.GetButton(3).left, dlg.GetButton(3).right, dlg.GetButton(3).top + 15, m_gldBoard[dlg.sV1]->msg->c_str(), false, true);

	//uncomment		if(m_iGuildRank == GUILDRANK_MASTER || m_iGuildRank == GUILDRANK_CAPTAIN)
	//uncomment			ButtonString(dlg, 4, DRAW_DIALOGBOX_MAILBOX15);

	//uncomment		ButtonString(dlg, 5, DRAW_DIALOGBOX_MAILBOX16);
			break;

		case 10:
			//uncomment		ButtonString(dlg, 1, DRAW_DIALOGBOX_MAILBOX6, POS_LEFT);
			PutAlignedString(dlg.GetButton(1).left + 30, dlg.GetButton(1).right, dlg.GetButton(1).top - 1, dlg.cStr2, false);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX7, strlen(dlg.txt), MAX_MAIL_MSG_LENGTH - 1);
			//uncomment		ButtonString(dlg, 2, G_cTxt, POS_LEFT);
					//PutAlignedString(dlg.GetButton(2).left, dlg.GetButton(2).right, dlg.GetButton(2).top + 15, dlg.txt, false, true);

			//uncomment		if(!dlg.bFlag)
			//uncomment			ButtonString(dlg, 3, DRAW_DIALOGBOX_MAILBOX22);
			//uncomment		else
			//uncomment			ButtonString(dlg, 3, DRAW_DIALOGBOX_MAILBOX23);

			//uncomment		ButtonString(dlg, 4, DRAW_DIALOGBOX_MAILBOX11);
			break;
	}
}

void helbreath::DrawDialogBox_GuildQuery()
{
	char txt[120];

	char onButton = m_dialogBoxes[44].OnButton();
	short x = m_dialogBoxes[44].m_X;
	short y = m_dialogBoxes[44].m_Y;
	short width = m_dialogBoxes[44].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, x, y, 6);

	switch (m_dialogBoxes[44].GetMode())
	{
		case 0:
			fmt::format_to(txt, DRAW_DIALOGBOX_GUILDQUERY, m_dialogBoxes[44].cStr);
			PutAlignedString(x, x + width, y + 10, txt, 45, 25, 25);

			if (m_iGuildRank < GUILDRANK_CAPTAIN)
			{
				fmt::format_to(txt, DRAW_DIALOGBOX_GUILDQUERY2, GetGuildRankName(GUILDRANK_CAPTAIN),
					m_guild.m_upgrades[GU_CAPTAINCY] - m_guild.m_captains);
				if (m_guild.m_upgrades[GU_CAPTAINCY] - m_guild.m_captains == 0 ||
					m_dialogBoxes[44].sV1 == GUILDRANK_CAPTAIN)
				{
					PutAlignedString(x, x + 135, y + 25, txt, 50, 50, 50);
				}
				else
				{
					if (onButton == 1)
						PutAlignedString(x, x + 135, y + 25, txt, 255, 255, 255);
					else
						PutAlignedString(x, x + 135, y + 25, txt);
				}
			}

			fmt::format_to(txt, DRAW_DIALOGBOX_GUILDQUERY2, GetGuildRankName(GUILDRANK_RAIDMASTER),
				m_guild.m_upgrades[GU_RAIDMASTERS] - m_guild.m_raidmasters);
			if (m_guild.m_upgrades[GU_RAIDMASTERS] - m_guild.m_raidmasters == 0 ||
				m_dialogBoxes[44].sV1 == GUILDRANK_RAIDMASTER)
			{
				PutAlignedString(x + 135, x + width, y + 25, txt, 50, 50, 50);
			}
			else
			{
				if (onButton == 2)
					PutAlignedString(x + 135, x + width, y + 25, txt, 255, 255, 255);
				else
					PutAlignedString(x + 135, x + width, y + 25, txt);
			}

			fmt::format_to(txt, DRAW_DIALOGBOX_GUILDQUERY2, GetGuildRankName(GUILDRANK_HUNTMASTER),
				m_guild.m_upgrades[GU_HUNTMASTERS] - m_guild.m_huntmasters);
			if (m_guild.m_upgrades[GU_HUNTMASTERS] - m_guild.m_huntmasters == 0 ||
				m_dialogBoxes[44].sV1 == GUILDRANK_HUNTMASTER)
			{
				PutAlignedString(x, x + 135, y + 40, txt, 50, 50, 50);
			}
			else
			{
				if (onButton == 3)
					PutAlignedString(x, x + 135, y + 40, txt, 255, 255, 255);
				else
					PutAlignedString(x, x + 135, y + 40, txt);
			}

			if (m_dialogBoxes[44].sV1 == GUILDRANK_GUILDSMAN)
				PutAlignedString(x + 135, x + width, y + 40, GetGuildRankName(GUILDRANK_GUILDSMAN), 50, 50, 50);
			else if (onButton == 4)
				PutAlignedString(x + 135, x + width, y + 40, GetGuildRankName(GUILDRANK_GUILDSMAN), 255, 255, 255);
			else
				PutAlignedString(x + 135, x + width, y + 40, GetGuildRankName(GUILDRANK_GUILDSMAN));

			if (m_dialogBoxes[44].sV1 == GUILDRANK_RECRUIT)
				PutAlignedString(x, x + 135, y + 55, GetGuildRankName(GUILDRANK_RECRUIT), 50, 50, 50);
			else if (onButton == 5)
				PutAlignedString(x, x + 135, y + 55, GetGuildRankName(GUILDRANK_RECRUIT), 255, 255, 255);
			else
				PutAlignedString(x, x + 135, y + 55, GetGuildRankName(GUILDRANK_RECRUIT));

			break;
	}
}


void helbreath::DlgBoxClick_GuildQuery()
{
	char onButton = m_dialogBoxes[44].OnButton();
	switch (m_dialogBoxes[44].GetMode())
	{
		case 0:
			if (onButton == 1 &&
				m_guild.m_upgrades[GU_CAPTAINCY] - m_guild.m_captains > 0 &&
				m_dialogBoxes[44].sV1 != GUILDRANK_CAPTAIN &&
				m_iGuildRank < GUILDRANK_CAPTAIN)
			{
				bSendCommand(MSGID_GUILDSMANCHANGE, 0, 0, GUILDRANK_CAPTAIN, 0, 0, m_dialogBoxes[44].cStr);
				DisableDialogBox(44);
			}
			else if (onButton == 2 &&
				m_guild.m_upgrades[GU_RAIDMASTERS] - m_guild.m_raidmasters > 0 &&
				m_dialogBoxes[44].sV1 != GUILDRANK_RAIDMASTER)
			{
				bSendCommand(MSGID_GUILDSMANCHANGE, 0, 0, GUILDRANK_RAIDMASTER, 0, 0, m_dialogBoxes[44].cStr);
				DisableDialogBox(44);
			}
			else if (onButton == 3 &&
				m_guild.m_upgrades[GU_HUNTMASTERS] - m_guild.m_huntmasters > 0 &&
				m_dialogBoxes[44].sV1 != GUILDRANK_HUNTMASTER)
			{
				bSendCommand(MSGID_GUILDSMANCHANGE, 0, 0, GUILDRANK_HUNTMASTER, 0, 0, m_dialogBoxes[44].cStr);
				DisableDialogBox(44);
			}
			else if (onButton == 4 &&
				m_dialogBoxes[44].sV1 != GUILDRANK_GUILDSMAN)
			{
				bSendCommand(MSGID_GUILDSMANCHANGE, 0, 0, GUILDRANK_GUILDSMAN, 0, 0, m_dialogBoxes[44].cStr);
				DisableDialogBox(44);
			}
			else if (onButton == 5 &&
				m_dialogBoxes[44].sV1 != GUILDRANK_RECRUIT)
			{
				bSendCommand(MSGID_GUILDSMANCHANGE, 0, 0, GUILDRANK_RECRUIT, 0, 0, m_dialogBoxes[44].cStr);
				DisableDialogBox(44);
			}
			break;
	}
}
void helbreath::DrawDialogBox_GuildOperation()
{
	short sX, sY;

	char onButton = m_dialogBoxes[8].OnButton();
	sX = m_dialogBoxes[8].m_X;
	sY = m_dialogBoxes[8].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 19);

	switch (m_stGuildOpList[0].cOpMode)
	{
		case 1:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION1);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION2);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION3);
			PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION4);
			PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION5, 55, 25, 25);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 33);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 32);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 35);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 34);
			break;

		case 2:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION6);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION7);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION8);
			PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION9);
			PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_GUILD_OPERATION10, 55, 25, 25);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 33);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 32);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 35);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 34);
			break;

		case 3:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION11);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION12);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION13);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 4:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION14);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION15);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION16);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 5:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION17);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION18);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION19);
			PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_GUILD_OPERATION20);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 6:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION21);
			PutAlignedString(sX + 24, sX + 248, sY + 65, m_stGuildOpList[0].cName, 35, 35, 35);
			PutAlignedString(sX + 24, sX + 248, sY + 69, "____________________", 0, 0, 0);
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION22);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION23);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 7:
			PutAlignedString(sX + 24, sX + 248, sY + 50, DRAW_DIALOGBOX_GUILD_OPERATION24);
			//PutString(sX + 60, sY + 65, m_stGuildOpList[0].cName,Color(255,35,35,35));
			//PutString(sX + 60, sY + 69, "____________________",Color(255,0,0,0));
			PutAlignedString(sX + 24, sX + 248, sY + 90, DRAW_DIALOGBOX_GUILD_OPERATION25);
			PutAlignedString(sX + 24, sX + 248, sY + 105, DRAW_DIALOGBOX_GUILD_OPERATION26);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
	}
}

int  _tmp_iMCProb[] = { 0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40 };
int  _tmp_iMLevelPenalty[] = { 0,   5,   5,   8,   8,   10, 14, 28, 32, 36, 40 };

void helbreath::DrawDialogBox_Magic()
{
	short sX, sY, sMagicCircle, sLevelMagic;
	int  iCPivot, i, j, iYloc, iResult, iManaCost;
	char cTxt[120], cMana[10];
	uint64_t dwTime = m_dwCurTime;
	double dV1, dV2, dV3, dV4;

	char onButton = m_dialogBoxes[3].OnButton();
	sX = m_dialogBoxes[3].m_X;
	sY = m_dialogBoxes[3].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME1, sX, sY, 1, FALSE, m_bDialogTrans);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 7, FALSE, m_bDialogTrans);

	if (iGetTopDialogBoxIndex() == 3 && m_stMCursor.sZ != 0)
	{
		if (m_stMCursor.sZ > 0) m_dialogBoxes[3].sView--;
		if (m_stMCursor.sZ < 0) m_dialogBoxes[3].sView++;
		//DIRECTX m_dInput.m_sZ = 0;
	}
	if (m_dialogBoxes[3].sView < 0) m_dialogBoxes[3].sView = 9;
	if (m_dialogBoxes[3].sView > 9) m_dialogBoxes[3].sView = 0;

	//Circle
	ZeroMemory(cTxt, sizeof(cTxt));
	switch (m_dialogBoxes[3].sView)
	{
		case 0: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC1);  break;//"Circle One"
		case 1: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC2);  break;//"Circle Two"
		case 2: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC3);  break;//"Circle Three"
		case 3: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC4);  break;//"Circle Four"
		case 4: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC5);  break;//"Circle Five"
		case 5: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC6);  break;//"Circle Six"
		case 6: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC7);  break;//"Circle Seven"
		case 7: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC8);  break;//"Circle Eight"
		case 8: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC9);  break;//"Circle Nine"
		case 9: strcpy(cTxt, DRAW_DIALOGBOX_MAGIC10); break;//"Circle Ten"
	}
	PutAlignedString(sX + 3, sX + 256, sY + 50, cTxt);
	PutAlignedString(sX + 4, sX + 257, sY + 50, cTxt);
	iCPivot = m_dialogBoxes[3].sView * 10;
	iYloc = 0;

	for (i = 0, j = 0; i < 9; i++)
	{
		if ((m_cMagicMastery[iCPivot + i] != 0) && (m_pMagicCfgList[iCPivot + i] != 0))
		{
			j++;
			fmt::format_to(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);

			m_Misc.ReplaceString(cTxt, '-', ' ');
			iManaCost = iGetManaCost(iCPivot + i);
			if (iManaCost > m_iMP)
			{
				if (m_Misc.bCheckIMEString(cTxt) == false)
				{
					PutString3(sX + 30, sY + 73 + iYloc, cTxt, Color(255, 41, 16, 41));
				}
				else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 5, 5, 5);
				fmt::format_to(cMana, "%3d", iManaCost);
				PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 5, 5, 5);
			}
			else
				if (onButton == j)
				{
					if (m_Misc.bCheckIMEString(cTxt) == false)
					{
						PutString3(sX + 30, sY + 73 + iYloc, cTxt, Color(255, 255, 255, 255));
					}
					else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 250, 250, 250);
					fmt::format_to(cMana, "%3d", iManaCost);
					PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 250, 250, 250);
				}
				else
				{
					if (m_Misc.bCheckIMEString(cTxt) == false)
					{
						PutString3(sX + 30, sY + 73 + iYloc, cTxt, Color(255, 8, 0, 66));
					}
					else PutString_SprFont(sX + 30, sY + 70 + iYloc, cTxt, 1, 1, 8);
					fmt::format_to(cMana, "%3d", iManaCost);
					PutString_SprFont(sX + 206, sY + 70 + iYloc, cMana, 1, 1, 8);
				}

			iYloc += 18;
		}

	}

	if (iYloc == 0)
	{
		PutAlignedString(sX + 3, sX + 256, sY + 100, DRAW_DIALOGBOX_MAGIC11);//"
		PutAlignedString(sX + 3, sX + 256, sY + 115, DRAW_DIALOGBOX_MAGIC12);//"
		PutAlignedString(sX + 3, sX + 256, sY + 130, DRAW_DIALOGBOX_MAGIC13);//"
		PutAlignedString(sX + 3, sX + 256, sY + 145, DRAW_DIALOGBOX_MAGIC14);//"
		PutAlignedString(sX + 3, sX + 256, sY + 160, DRAW_DIALOGBOX_MAGIC15);//"
	}

	m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 19, dwTime);

	switch (m_dialogBoxes[3].sView)
	{
		case 0: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 30, sY + 250, 20, dwTime); break;
		case 1: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 43, sY + 250, 21, dwTime); break;
		case 2: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 61, sY + 250, 22, dwTime); break;
		case 3: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 86, sY + 250, 23, dwTime); break;
		case 4: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 106, sY + 250, 24, dwTime); break;
		case 5: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 121, sY + 250, 25, dwTime); break;
		case 6: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 142, sY + 250, 26, dwTime); break;
		case 7: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 169, sY + 250, 27, dwTime); break;
		case 8: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 202, sY + 250, 28, dwTime); break;
		case 9: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 222, sY + 250, 29, dwTime); break;
	}

	sMagicCircle = m_dialogBoxes[3].sView + 1;
	if (m_cSkillMastery[SKILL_MAGIC] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_cSkillMastery[SKILL_MAGIC];
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;
	if (m_stat[STAT_INT] > 50) iResult += (m_stat[STAT_INT] - 50) / 2;
	sLevelMagic = (m_iLevel / 10);
	if (sMagicCircle != sLevelMagic)
	{
		if (sMagicCircle > sLevelMagic)
		{
			dV1 = (double)(m_iLevel - sLevelMagic * 10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
			dV4 = (dV1 / dV3) * dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else
		{
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_weather)
	{
		case WEATHER_LIGHTRAIN:		iResult = iResult - (iResult / 24); break;
		case WEATHER_MEDIUMRAIN:	iResult = iResult - (iResult / 12); break;
		case WEATHER_HEAVYRAIN:		iResult = iResult - (iResult / 5);  break;
	}

	for (i = 0; i < MAXITEMS; i++)
	{
		if (!m_pItemList[i])
			continue;

		if (m_bIsItemEquipped[i])
		{
			if ((m_pItemList[i]->m_dwAttribute & 0x00F00000) >> 20 == 10)
			{
				dV1 = (double)iResult;
				dV2 = (double)(((m_pItemList[i]->m_dwAttribute & 0x000F0000) >> 16) * 3);
				dV3 = dV1 + dV2;
				iResult = (int)dV3;
				break;
			}
		}
	}

	if (iResult > 100) iResult = 100;
	if (m_iSP < 1) iResult = iResult * 9 / 10;
	if (iResult < 1) iResult = 1;

	ZeroMemory(cTxt, sizeof(cTxt));
	fmt::format_to(cTxt, DRAW_DIALOGBOX_MAGIC16, iResult);//"
	PutAlignedString(sX, sX + 256, sY + 267, cTxt);
	PutAlignedString(sX + 1, sX + 257, sY + 267, cTxt);


	if (onButton == 20)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + 285, 49, false, m_bDialogTrans);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + 285, 48, false, m_bDialogTrans);
}

void helbreath::DrawDialogBox_MagicShop()
{
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	int  i, j;
	int  iCPivot, iYloc;
	char cTxt[120], cMana[10];

	char onButton = m_dialogBoxes[16].OnButton();
	sX = m_dialogBoxes[16].m_X;
	sY = m_dialogBoxes[16].m_Y;

	switch (m_dialogBoxes[16].GetMode())
	{
		case 1:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX, sY, 1);
			//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 14);

			PutString_SprFont(sX + 45, sY + 40, DRAW_MANASAVEINFO, 5, 5, 5);

			PutString3(sX + 50, sY + 55, DRAW_MANASAVEINFO1, Color(255, 45, 25, 25));
			PutString(sX + 50, sY + 70, DRAW_MANASAVEINFO2, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 80, DRAW_MANASAVEINFO3, Color(255, 255, 255, 255));
			//PutString(sX + 50, sY + 90, DRAW_MANASAVEINFO4,Color(255,255, 255, 255));

			PutString3(sX + 50, sY + 105, DRAW_MANASAVEINFO5, Color(255, 45, 25, 25));
			PutString(sX + 50, sY + 120, DRAW_MANASAVEINFO6, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 130, DRAW_MANASAVEINFO7, Color(255, 255, 255, 255));
			//PutString(sX + 50, sY + 140, DRAW_MANASAVEINFO8,Color(255,255, 255, 255));

			PutString3(sX + 50, sY + 155, DRAW_MANASAVEINFO9, Color(255, 45, 25, 25));
			PutString(sX + 50, sY + 170, DRAW_MANASAVEINFO10, Color(255, 255, 255, 255));

			PutString3(sX + 50, sY + 185, DRAW_MANASAVEINFO11, Color(255, 45, 25, 25));
			PutString(sX + 50, sY + 200, DRAW_MANASAVEINFO12, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 210, DRAW_MANASAVEINFO13, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 220, DRAW_MANASAVEINFO14, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 230, DRAW_MANASAVEINFO15, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 240, DRAW_MANASAVEINFO16, Color(255, 255, 255, 255));
			PutString(sX + 50, sY + 250, DRAW_MANASAVEINFO17, Color(255, 255, 255, 255));

			PutString3(sX + 50, sY + 265, DRAW_MANASAVEINFO18, Color(255, 45, 25, 25));
			PutString(sX + 50, sY + 280, DRAW_MANASAVEINFO19, Color(255, 255, 255, 255));
			//PutString3(sX + 50, sY + 245, DRAW_MANASAVEINFO16,Color(255,45,25,25));
			//PutString(sX + 50, sY + 260, DRAW_MANASAVEINFO17,Color(255,255, 255, 255));
			//PutString(sX + 50, sY + 270, DRAW_MANASAVEINFO18,Color(255,255, 255, 255));
			//PutString(sX + 50, sY + 280, DRAW_MANASAVEINFO19,Color(255,255, 255, 255));

			break;

		default:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX, sY, 1);
			//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 14);

			if (iGetTopDialogBoxIndex() == 16 && m_stMCursor.sZ != 0)
			{
				if (m_stMCursor.sZ > 0) m_dialogBoxes[16].sView--;
				if (m_stMCursor.sZ < 0) m_dialogBoxes[16].sView++;
				//DIRECTX m_dInput.m_sZ = 0;
			}
			if (m_dialogBoxes[16].sView < 0) m_dialogBoxes[16].sView = 9;
			if (m_dialogBoxes[16].sView > 9) m_dialogBoxes[16].sView = 0;

			PutString3(sX + 20, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP11, Color(255, 45, 25, 25));

			PutString3(sX + 155, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP16, Color(255, 45, 25, 25));

			PutString3(sX + 225, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP12, Color(255, 45, 25, 25));

			PutString3(sX + 255, sY - 35 + 90, DRAW_DIALOGBOX_MAGICSHOP13, Color(255, 45, 25, 25));

			iCPivot = m_dialogBoxes[16].sView * 10;

			iYloc = 0;
			for (i = 0, j = 0; i < 9; i++)
			{
				if ((m_pMagicCfgList[iCPivot + i] != 0) && (m_pMagicCfgList[iCPivot + i]->m_bIsVisible))
				{
					j++;
					fmt::format_to(cTxt, "%s", m_pMagicCfgList[iCPivot + i]->m_cName);
					m_Misc.ReplaceString(cTxt, '-', ' ');
					if (m_cMagicMastery[iCPivot + i] != 0)
					{
						if (m_Misc.bCheckIMEString(cTxt) == false)
						{
							PutString3(sX + 20, sY + 73 + iYloc, cTxt, Color(255, 41, 16, 41));
						}
						else PutString_SprFont(sX + 20, sY + 70 + iYloc, cTxt, 5, 5, 5);
						fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue1);
						PutString_SprFont(sX + 190, sY + 70 + iYloc, cMana, 5, 5, 5);
						fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
						PutString_SprFont(sX + 220, sY + 70 + iYloc, cMana, 5, 5, 5);
						fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
						PutString_SprFont(sX + 250, sY + 70 + iYloc, cMana, 5, 5, 5);
					}
					else
						if (onButton == j)
						{
							if (m_Misc.bCheckIMEString(cTxt) == false)
							{
								PutString3(sX + 20, sY + 73 + iYloc, cTxt, Color(255, 255, 255, 255));
							}
							else PutString_SprFont(sX + 20, sY + 70 + iYloc, cTxt, 250, 250, 250);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue1);
							PutString_SprFont(sX + 190, sY + 70 + iYloc, cMana, 250, 250, 250);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
							PutString_SprFont(sX + 220, sY + 70 + iYloc, cMana, 250, 250, 250);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
							PutString_SprFont(sX + 250, sY + 70 + iYloc, cMana, 250, 250, 250);
						}
						else
						{
							if (m_Misc.bCheckIMEString(cTxt) == false)
							{
								PutString3(sX + 20, sY + 73 + iYloc, cTxt, Color(255, 8, 0, 66));
							}
							else PutString_SprFont(sX + 20, sY + 70 + iYloc, cTxt, 1, 1, 8);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue1);
							PutString_SprFont(sX + 190, sY + 70 + iYloc, cMana, 1, 1, 8);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue2);
							PutString_SprFont(sX + 220, sY + 70 + iYloc, cMana, 1, 1, 8);
							fmt::format_to(cMana, "%3d", m_pMagicCfgList[iCPivot + i]->m_sValue3);
							PutString_SprFont(sX + 250, sY + 70 + iYloc, cMana, 1, 1, 8);
						}
					iYloc += 18;
				}
			}
			m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX + 55, sY + 250, 19, dwTime);

			switch (m_dialogBoxes[16].sView)
			{
				case 0: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 44 + 31, sY + 250, 20, dwTime); break;
				case 1: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 57 + 31, sY + 250, 21, dwTime); break;
				case 2: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 75 + 31, sY + 250, 22, dwTime); break;
				case 3: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 100 + 31, sY + 250, 23, dwTime); break;
				case 4: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 120 + 31, sY + 250, 24, dwTime); break;
				case 5: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 135 + 31, sY + 250, 25, dwTime); break;
				case 6: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 156 + 31, sY + 250, 26, dwTime); break;
				case 7: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 183 + 31, sY + 250, 27, dwTime); break;
				case 8: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 216 + 31, sY + 250, 28, dwTime); break;
				case 9: m_pSprite[SPRID_INTERFACE_SPRFONTS]->PutSpriteFast(sX - 20 + 236 + 31, sY + 250, 29, dwTime); break;
			}
			PutString3(sX + 90, sY + 260, DRAW_DIALOGBOX_MAGICSHOP17, Color(255, 45, 25, 25));
			PutAlignedString(sX, sX + m_dialogBoxes[16].sSizeX, sY + 275, DRAW_DIALOGBOX_MAGICSHOP14, 45, 25, 25);
			PutAlignedString(sX, sX + m_dialogBoxes[16].sSizeX + 1, sY + 275, DRAW_DIALOGBOX_MAGICSHOP14, 45, 25, 25);
			break;
	}
}

void helbreath::DrawDialogBox_ShutDownMsg()
{
	short sX, sY, szX;

	char onButton = m_dialogBoxes[25].OnButton();
	sX = m_dialogBoxes[25].m_X;
	sY = m_dialogBoxes[25].m_Y;
	szX = m_dialogBoxes[25].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX, sY,2);

	switch (m_dialogBoxes[25].GetMode())
	{
		case 1:
			ZeroMemory(G_cTxt, sizeof(G_cTxt));
			if (m_dialogBoxes[25].sV1 != 0) fmt::format_to(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG1, m_dialogBoxes[25].sV1);
			else strcpy(G_cTxt, DRAW_DIALOGBOX_NOTICEMSG2);
			PutAlignedString(sX, sX + szX, sY + 31, G_cTxt, 100, 10, 10);
			PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG3);
			PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_NOTICEMSG4);

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0);
			break;

		case 2:
			PutAlignedString(sX, sX + szX, sY + 31, DRAW_DIALOGBOX_NOTICEMSG7, 100, 10, 10);
			PutAlignedString(sX, sX + szX, sY + 48, DRAW_DIALOGBOX_NOTICEMSG8);
			PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_NOTICEMSG9);
			PutAlignedString(sX, sX + szX, sY + 82, DRAW_DIALOGBOX_NOTICEMSG10);
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 210, sY + 127, 0);
			break;
	}
}

void helbreath::DrawDialogBox_NpcActionQuery()
{
	short sX, sY, szX;

	char cTxt[120], cTxt2[120], cStr1[64], cStr2[64], cStr3[64];

	char onButton = m_dialogBoxes[20].OnButton();

	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));

	sX = m_dialogBoxes[20].m_X;
	sY = m_dialogBoxes[20].m_Y;
	szX = m_dialogBoxes[20].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5); //5
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6); //6

	switch (m_dialogBoxes[20].GetMode())
	{
		case 0: // npc
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			switch (m_dialogBoxes[20].sV3)
			{
				case 15:
					PutString(sX + 33, sY + 23, NPC_NAME_SHOP_KEEPER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_SHOP_KEEPER, Color(255, 255, 255, 255));
					break;
				case 19:
					PutString(sX + 33, sY + 23, NPC_NAME_MAGICIAN, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_MAGICIAN, Color(255, 255, 255, 255));
					break;
				case 20:
					PutString(sX + 33, sY + 23, NPC_NAME_WAREHOUSE_KEEPER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_WAREHOUSE_KEEPER, Color(255, 255, 255, 255));
					break;
				case 24:
					PutString(sX + 33, sY + 23, NPC_NAME_BLACKSMITH_KEEPER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_BLACKSMITH_KEEPER, Color(255, 255, 255, 255));
					break;
				case 25:
					PutString(sX + 33, sY + 23, NPC_NAME_CITYHALL_OFFICER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_CITYHALL_OFFICER, Color(255, 255, 255, 255));
					break;
				case 26: // "Guildhall Officer"
					PutString(sX + 33, sY + 23, NPC_NAME_GUILDHALL_OFFICER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_GUILDHALL_OFFICER, Color(255, 255, 255, 255));
					break;
				case 90: //Gail
					PutString(sX + 33, sY + 23, NPC_NAME_CMDHALL_OFFICER, Color(255, 45, 25, 25));
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_CMDHALL_OFFICER, Color(255, 255, 255, 255));
					break;
			}

			if (m_dialogBoxes[20].sV3 == 25)
			{   // OFFER
				if (onButton == 1)
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, Color(255, 255, 255, 255)); // "Offer"
				}
				else
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY13, Color(255, 4, 0, 50));
				}
			}
			else if (m_dialogBoxes[20].sV3 == 20)
			{   // WITHDRAW
				if (onButton == 1)
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, Color(255, 255, 255, 255)); // "Withdraw"
				}
				else
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY17, Color(255, 4, 0, 50));
				}
			}
			else if (m_dialogBoxes[20].sV3 == 19) // CLEROTH: MAGICIAN
			{   // LEARN
				if (onButton == 1)
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, Color(255, 255, 255, 255)); // "Learn"
				}
				else
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY19, Color(255, 4, 0, 50));
				}
			}
			else
			{   // TRADE
				if (onButton == 1)
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 255, 255, 255)); // "Trade"
				}
				else
				{
					PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 4, 0, 50));
				}
			}

			if (m_bIsDialogEnabled[21] == false)
			{
				if (onButton == 2)
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 255, 255, 255)); // "Talk"
				}
				else
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 4, 0, 50));
				}
			}
			break;
			ZeroMemory(_tmp_cName, sizeof(_tmp_cName));
		case 1: // Other char
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
			GetItemName(m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_pItemList[m_dialogBoxes[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);
			fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_dialogBoxes[20].sV3, cStr1); //"%d %s to"
			//fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29_2, m_dialogBoxes[20].sV3, cStr1, m_dialogBoxes[20].cStr); //"%d %s to %s" // Added other player name on give! xRisenx
			fmt::format_to(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_dialogBoxes[20].cStr); // "%s"

			PutString(sX + 24, sY + 25, cTxt, Color(255, 45, 25, 25));
			PutString(sX + 24, sY + 40, cTxt2, Color(255, 45, 25, 25));

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, Color(255, 255, 255, 255));//"Give"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY30, Color(255, 4, 0, 50));
			}

			if (onButton == 2)
			{
				PutString3(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, Color(255, 255, 255, 255));//"Exchange"
			}
			else
			{
				PutString3(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY34, Color(255, 4, 0, 50));
			}
			break;

		case 2: // Shop / BS
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			GetItemName(m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_pItemList[m_dialogBoxes[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);

			fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_dialogBoxes[20].sV3, cStr1);//"%d %s to"
			fmt::format_to(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_dialogBoxes[20].cStr);//"%s"

			PutString(sX + 24, sY + 20, cTxt, Color(255, 45, 25, 25));
			PutString(sX + 24, sY + 35, cTxt2, Color(255, 45, 25, 25));

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, Color(255, 255, 255, 255));//"Sell"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, Color(255, 4, 0, 50));
			}

			if ((m_pItemList[m_dialogBoxes[20].sV1]->m_cItemType != ITEMTYPE_CONSUME) &&
				(m_pItemList[m_dialogBoxes[20].sV1]->m_cItemType != ITEMTYPE_ARROW))
			{
				if (onButton == 2)
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, Color(255, 255, 255, 255));//"Repair"
				}
				else
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, Color(255, 4, 0, 50));
				}
			}
			break;

		case 3: // WH
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
			GetItemName(m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_pItemList[m_dialogBoxes[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);

			fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_dialogBoxes[20].sV3, cStr1);//"%d %s to"
			fmt::format_to(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_dialogBoxes[20].cStr);//"%s"

			PutAlignedString(sX, sX + 240, sY + 20, cTxt, 45, 25, 25);
			PutAlignedString(sX, sX + 240, sY + 35, cTxt2, 45, 25, 25);

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, Color(255, 255, 255, 255));//"Deposit"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, Color(255, 4, 0, 50));
			}
			break;

		case 4: // talk to npc or unicorn
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			switch (m_dialogBoxes[20].sV3)
			{
				case 21:
					PutString(sX + 35, sY + 25, NPC_NAME_GUARD, Color(255, 45, 25, 25));//
					PutString(sX + 35 - 1, sY + 25 - 1, NPC_NAME_GUARD, Color(255, 255, 255, 255));
					break;
				case 32:
					PutString(sX + 35, sY + 25, NPC_NAME_UNICORN, Color(255, 45, 25, 25));//"
					PutString(sX + 35 - 1, sY + 25 - 1, NPC_NAME_UNICORN, Color(255, 255, 255, 255));//"
					break;
				case 67:
					PutString(sX + 35, sY + 25, NPC_NAME_MCGAFFIN, Color(255, 45, 25, 25));
					PutString(sX + 35 - 1, sY + 25 - 1, NPC_NAME_MCGAFFIN, Color(255, 255, 255, 255));
					break;
				case 68:
					PutString(sX + 35, sY + 25, NPC_NAME_PERRY, Color(255, 45, 25, 25));
					PutString(sX + 35 - 1, sY + 25 - 1, NPC_NAME_PERRY, Color(255, 255, 255, 255));
					break;
				case 69:
					PutString(sX + 35, sY + 25, NPC_NAME_DEVLIN, Color(255, 45, 25, 25));
					PutString(sX + 35 - 1, sY + 25 - 1, NPC_NAME_DEVLIN, Color(255, 255, 255, 255));
					break;

			}

			if (m_bIsDialogEnabled[21] == false)
			{
				if (onButton == 1)
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 255, 255, 255));
				}
				else
				{
					PutString3(sX + 125, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 4, 0, 50));
				}
			}
			break;

		case 5: // Shop / BS
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
			switch (m_dialogBoxes[20].sV3)
			{
				case 15:
					PutString(sX + 33, sY + 23, NPC_NAME_SHOP_KEEPER, Color(255, 45, 25, 25));//Shop Keeper"
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_SHOP_KEEPER, Color(255, 255, 255, 255));
					break;
				case 24:
					PutString(sX + 33, sY + 23, NPC_NAME_BLACKSMITH_KEEPER, Color(255, 45, 25, 25));//"BlackSmith Keeper"
					PutString(sX + 33 - 1, sY + 23 - 1, NPC_NAME_BLACKSMITH_KEEPER, Color(255, 255, 255, 255));//"
					break;
			}

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 255, 255, 255));//"Trade"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 4, 0, 50));
			}

			if (onButton == 2)
			{
				PutString3(sX + 28 + 75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, Color(255, 255, 255, 255));//"Sell"
			}
			else
			{
				PutString3(sX + 28 + 75, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY39, Color(255, 4, 0, 50));
			}
			if (m_bIsDialogEnabled[21] == false)
			{
				if (onButton == 3)
				{
					PutString3(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 255, 255, 255));//"Talk"
				}
				else
				{
					PutString3(sX + 155, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY25, Color(255, 4, 0, 50));
				}
			}
			break;

		case 6: //Gail
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 255, 255, 255)); // "Trade"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY21, Color(255, 4, 0, 50));
			}
			PutString(sX + 33, sY + 23, DRAW_DIALOGBOX_NPCACTION_QUERY49, Color(255, 45, 25, 25));
			PutString(sX + 33 - 1, sY + 23 - 1, DRAW_DIALOGBOX_NPCACTION_QUERY49, Color(255, 255, 255, 255));
			break;

		case 7: // Jehovah - New Blacksmith Function
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			if (onButton == 1)
			{
				PutString3(sX + 25, sY + 29, DRAW_BLACKSMITH1, Color(255, 255, 255, 255)); // "Buy Weapons"
			}
			else
			{
				PutString3(sX + 25, sY + 29, DRAW_BLACKSMITH1, Color(255, 4, 0, 50));
			}

			if (onButton == 2)
			{
				PutString3(sX + 125, sY + 29, DRAW_BLACKSMITH2, Color(255, 255, 255, 255)); // "Buy (M) Armor"
			}
			else
			{
				PutString3(sX + 125, sY + 29, DRAW_BLACKSMITH2, Color(255, 4, 0, 50));
			}

			if (onButton == 3)
			{
				PutString3(sX + 125, sY + 46, DRAW_BLACKSMITH3, Color(255, 255, 255, 255)); // "Buy (W) Armor"
			}
			else
			{
				PutString3(sX + 125, sY + 46, DRAW_BLACKSMITH3, Color(255, 4, 0, 50));
			}

			if (onButton == 4)
			{
				PutString3(sX + 25, sY + 46, DRAW_BLACKSMITH4, Color(255, 255, 255, 255)); // "Sell"
			}
			else
			{
				PutString3(sX + 25, sY + 46, DRAW_BLACKSMITH4, Color(255, 4, 0, 50));
			}

			if (onButton == 5)
			{
				PutString3(sX + 25, sY + 63, DRAW_BLACKSMITH5, Color(255, 255, 255, 255)); // "Repair All"
			}
			else
			{
				PutString3(sX + 25, sY + 63, DRAW_BLACKSMITH5, Color(255, 4, 0, 50));
			}

			PutString(sX + 65, sY + 5, DRAW_BLACKSMITH, Color(255, 0, 0, 0));
			PutString(sX + 65 - 1, sY + 5 - 1, DRAW_BLACKSMITH, Color(255, 255, 255, 255));
			PutString(sX + 61, sY + 5, "________________", Color(255, 0, 0, 0));
			break;

		case 8: // Jehovah - New Shopkeeper Function
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);
			if (onButton == 1)
			{
				PutString3(sX + 25, sY + 30, DRAW_SHOP1, Color(255, 255, 255, 255)); // "Buy Potions"
			}
			else
			{
				PutString3(sX + 25, sY + 30, DRAW_SHOP1, Color(255, 4, 0, 50));
			}

			if (onButton == 2)
			{
				PutString3(sX + 125, sY + 30, DRAW_SHOP2, Color(255, 255, 255, 255)); // "Buy Misc."
			}
			else
			{
				PutString3(sX + 125, sY + 30, DRAW_SHOP2, Color(255, 4, 0, 50));
			}

			if (onButton == 3)
			{
				PutString3(sX + 125, sY + 50, DRAW_SHOP3, Color(255, 255, 255, 255)); // "Buy Outfits"
			}
			else
			{
				PutString3(sX + 125, sY + 50, DRAW_SHOP3, Color(255, 4, 0, 50));
			}

			if (onButton == 4)
			{
				PutString3(sX + 25, sY + 50, DRAW_SHOP4, Color(255, 255, 255, 255)); // "Sell Items"
			}
			else
			{
				PutString3(sX + 25, sY + 50, DRAW_SHOP4, Color(255, 4, 0, 50));
			}

			PutString(sX + 70, sY + 5, DRAW_SHOP, Color(255, 0, 0, 0));
			PutString(sX + 70 - 1, sY + 5 - 1, DRAW_SHOP, Color(255, 255, 255, 255));
			PutString(sX + 66, sY + 5, "____________", Color(255, 0, 0, 0));
			break;

		case 9: // Jehovah - New Cityhall Officer Function
			if (onButton == 1)
			{
				PutString3(sX + 25, sY + 30, DRAW_CITYHALL1, Color(255, 255, 255, 255)); // "Offer"
			}
			else
			{
				PutString3(sX + 25, sY + 30, DRAW_CITYHALL1, Color(255, 4, 0, 50));
			}

			if (onButton == 2)
			{
				PutString3(sX + 125, sY + 30, DRAW_CITYHALL4, Color(255, 255, 255, 255)); // "Mailbox"
			}
			else
			{
				PutString3(sX + 125, sY + 30, DRAW_CITYHALL4, Color(255, 4, 0, 50));
			}

			//if (onButton == 3){
			//	PutString3(sX + 125, sY + 50, DRAW_CITYHALL2,Color(255,255,255,255)); // "Buy Weapons"
			//}else{
			//	PutString3(sX + 125, sY + 50, DRAW_CITYHALL2,Color(255,4,0,50));
			//}

			if (onButton == 4)
			{
				PutString3(sX + 25, sY + 50, DRAW_CITYHALL3, Color(255, 255, 255, 255)); // "Talk"
			}
			else
			{
				PutString3(sX + 25, sY + 50, DRAW_CITYHALL3, Color(255, 4, 0, 50));
			}

			PutString(sX + 70, sY + 5, DRAW_CITYHALL, Color(255, 0, 0, 0));
			PutString(sX + 70 - 1, sY + 5 - 1, DRAW_CITYHALL, Color(255, 255, 255, 255));
			PutString(sX + 66, sY + 5, "____________", Color(255, 0, 0, 0));
			break;

		case 10: //GuildBank
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6);
			GetItemName(m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_pItemList[m_dialogBoxes[20].sV1]->m_dwAttribute, cStr1, cStr2, cStr3);

			fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY29, m_dialogBoxes[20].sV3, cStr1);//"%d %s to"
			fmt::format_to(cTxt2, DRAW_DIALOGBOX_NPCACTION_QUERY29_1, m_dialogBoxes[20].cStr);//"%s"

			PutAlignedString(sX, sX + 240, sY + 20, cTxt, 45, 25, 25);
			PutAlignedString(sX, sX + 240, sY + 35, cTxt2, 45, 25, 25);

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, Color(255, 255, 255, 255));//"Deposit"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY48, Color(255, 4, 0, 50));
			}
			break;

		case 11: //Repair all items
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 6);

			fmt::format_to(cTxt, DRAW_DIALOGBOX_NPCACTION_QUERY51, m_dialogBoxes[20].sV2); //"your items for %d gold?"

			PutAlignedString(sX, sX + 243, sY + 20, DRAW_DIALOGBOX_NPCACTION_QUERY50, 45, 25, 25); //"Would you like me to repair"
			PutAlignedString(sX, sX + 243, sY + 35, cTxt, 45, 25, 25);

			if (onButton == 1)
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, Color(255, 255, 255, 255));//"Repair"
			}
			else
			{
				PutString3(sX + 28, sY + 55, DRAW_DIALOGBOX_NPCACTION_QUERY43, Color(255, 4, 0, 50));
			}
			break;
	}
}

void helbreath::DrawDialogBox_Party()
{
	short sX, sY, szX;
	int  i, iTotalLines, iPointerLoc;
	double d1, d2, d3;
	Point pointerLoc;

	char onButton = m_dialogBoxes[32].OnButton();
	sX = m_dialogBoxes[32].m_X;
	sY = m_dialogBoxes[32].m_Y;
	szX = m_dialogBoxes[32].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 3);

	switch (m_dialogBoxes[32].GetMode())
	{
		case 0:
			if (m_iPartyStatus == 0)
			{
				if (onButton == 1)
					PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 4, 0, 50);//"
			}
			else PutAlignedString(sX, sX + szX, sY + 85, DRAW_DIALOGBOX_PARTY1, 65, 65, 65);//"

			if (m_iPartyStatus != 0)
			{
				if (onButton == 2)
					PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 4, 0, 50);//"
			}
			else PutAlignedString(sX, sX + szX, sY + 105, DRAW_DIALOGBOX_PARTY4, 65, 65, 65);//"

			if (m_iPartyStatus != 0)
			{
				if (onButton == 3)
					PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 255, 255, 255);//"
				else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 4, 0, 50);//"
			}
			else PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY7, 65, 65, 65);//"

			if (m_partyAutoAccept)
			{
				if (onButton == 4)
					PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_PARTY57, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_PARTY57, 4, 0, 50);//"
			}
			else
			{
				if (onButton == 4)
					PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_PARTY56, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 145, DRAW_DIALOGBOX_PARTY56, 4, 0, 50);
			}

			switch (m_iPartyStatus)
			{
				case 0:
					PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY10);//"
					PutAlignedString(sX, sX + szX, sY + 190, DRAW_DIALOGBOX_PARTY11);//"
					PutAlignedString(sX, sX + szX, sY + 205, DRAW_DIALOGBOX_PARTY12);//"
					break;

				case 1:
				case 2:
					PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY13);//"
					PutAlignedString(sX, sX + szX, sY + 190, DRAW_DIALOGBOX_PARTY14);//"
					PutAlignedString(sX, sX + szX, sY + 205, DRAW_DIALOGBOX_PARTY15);//"
					break;
			}

			if (onButton == 5)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
			break;

		case 1: //
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_PARTY16, m_dialogBoxes[32].cStr);
			PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY17);//"join the party. You can"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY18);//"share the experience by"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY19);//"the ratio of level if"
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY20);//"you join the party."
			PutAlignedString(sX, sX + szX, sY + 175, DRAW_DIALOGBOX_PARTY21);//"Would you like to join party?"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;

		case 2:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY22);//"Click the character which"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY23);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY24);//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY25);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 3:
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_PARTY26, m_dialogBoxes[32].cStr);//"
			PutAlignedString(sX, sX + szX, sY + 95, G_cTxt);
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY27);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY28);//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY29);//"
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY30);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 4:
			PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_PARTY31);//"
			PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_PARTY32);//"

			iTotalLines = m_stPartyMember.size();
			pointerLoc = m_dialogBoxes[32].HandleScroll(12, iTotalLines);

			if (iTotalLines > 12)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			for (i = 0; i < 12; i++)
			{
				if ((i + m_dialogBoxes[32].sView) < m_stPartyMember.size())
				{
					PutAlignedString(sX + 10, sX + 260, sY + 95 + 15 * (i), (char *)m_stPartyMember[i + m_dialogBoxes[32].sView]->cName.c_str());
				}
			}

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 5:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY33);//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY34);//"
			break;

		case 6:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY35);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 7:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY36);//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY37);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY38);//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY39);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 8:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY40);//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY41);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY42);//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY43);//"
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY44);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY45);//"


			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 9:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY46);//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY47);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY48);//"
			PutAlignedString(sX, sX + szX, sY + 140, DRAW_DIALOGBOX_PARTY49);//"
			PutAlignedString(sX, sX + szX, sY + 155, DRAW_DIALOGBOX_PARTY50);//"
			PutAlignedString(sX, sX + szX, sY + 170, DRAW_DIALOGBOX_PARTY51);//"

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 10:
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY52);//"
			PutAlignedString(sX, sX + szX, sY + 110, DRAW_DIALOGBOX_PARTY53);//"
			PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_PARTY54);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 11: //
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_DIALOGBOX_PARTY55);//"
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 19);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 18);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 3);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 2);
			break;
	}
}

void helbreath::DrawDialogBox_QueryDropItemAmount()
{
	short sX, sY;
	char cTxt[120], cStr1[64], cStr2[64], cStr3[64];

	sX = m_dialogBoxes[17].m_X;
	sY = m_dialogBoxes[17].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 5);

	switch (m_dialogBoxes[17].GetMode())
	{
		case 1:
			GetItemName(m_pItemList[m_dialogBoxes[17].sView]->m_cName, m_pItemList[m_dialogBoxes[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3);
			if (strlen(m_dialogBoxes[17].cStr) == 0)
				fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);
			else fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_dialogBoxes[17].cStr);//"%s:

			if (m_dialogBoxes[17].sV3 < 1000)
				PutString(sX + 30, sY + 20, cTxt, Color(255, 55, 25, 25));

			PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, Color(255, 55, 25, 25));//"
			if (iGetTopDialogBoxIndex() != 17)
				PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", m_pItemList[m_dialogBoxes[17].sView]->m_dwCount);
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;

		case 20:
			GetItemName(m_pItemList[m_dialogBoxes[17].sView]->m_cName, m_pItemList[m_dialogBoxes[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3);
			if (strlen(m_dialogBoxes[17].cStr) == 0)
				fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);//"%s:
			else fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_dialogBoxes[17].cStr);//"%s:

			if (m_dialogBoxes[17].sV3 < 1000)
				PutString(sX + 30, sY + 20, cTxt, Color(255, 55, 25, 25));

			PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, Color(255, 55, 25, 25));//"
			PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", m_pItemList[m_dialogBoxes[17].sView]->m_dwCount);
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;

		case NPC_PRINCESS:
			GetItemName(m_pItemList[m_dialogBoxes[17].sView]->m_cName, m_pItemList[m_dialogBoxes[17].sView]->m_dwAttribute, cStr1, cStr2, cStr3);
			if (strlen(m_dialogBoxes[17].cStr) == 0)
				fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT1, cStr1);//"%s:
			else fmt::format_to(cTxt, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT2, cStr1, m_dialogBoxes[17].cStr);//"%s:

			if (m_dialogBoxes[17].sV3 < 1000)
				PutString(sX + 30, sY + 20, cTxt, Color(255, 55, 25, 25));

			PutString(sX + 30, sY + 35, DRAW_DIALOGBOX_QUERY_DROP_ITEM_AMOUNT3, Color(255, 55, 25, 25));//"
			PutString(sX + 40, sY + 57, m_cAmountString, Color(255, 255, 255, 255), false, 2);
			fmt::format_to(cTxt, "__________ (0 ~ %d)", m_pItemList[m_dialogBoxes[17].sView]->m_dwCount);
			PutString(sX + 38, sY + 62, cTxt, Color(255, 25, 35, 25));
			break;
	}
}


void helbreath::DrawDialogBox_Quest()
{
	short sX, sY, szX;
	char cTxt[120], cTemp[21];

	char onButton = m_dialogBoxes[28].OnButton();

	sX = m_dialogBoxes[28].m_X;
	sY = m_dialogBoxes[28].m_Y;
	szX = m_dialogBoxes[28].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT , sX, sY, 4);

	switch (m_dialogBoxes[28].GetMode())
	{
		case 1:
			switch (m_stQuest.sQuestType)
			{
				case 0:
					PutAlignedString(sX, sX + szX, sY + 50 + 115 - 30, DRAW_DIALOGBOX_QUEST1, 55, 25, 25); // " You are not on a quest."
					break;

				case 1:	//  Hunt
					if (m_stQuest.bIsQuestCompleted == false)
						PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST2, 55, 25, 25); // "You are on a monster conquering quest."
					else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST3, 55, 25, 25); // "You accomplished the monster conquering quest."

					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, "Rest Monster : %d", m_stQuest.sCurrentCount); // Snoopy: "Rest Monster : %s"
					PutAlignedString(sX, sX + szX, sY + 50 + 20, cTxt, 55, 25, 25);  // m_stQuest.sCurrentCount

					ZeroMemory(cTemp, sizeof(cTemp));
					switch (m_stQuest.sWho)
					{
						case 1:
						case 2:
						case 3: break;
						case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
						case 5:
						case 6:
						case 7: break;
					}
					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST5, cTemp); // "Client: %s"
					PutAlignedString(sX, sX + szX, sY + 50 + 45, cTxt, 55, 25, 25);

					ZeroMemory(cTemp, sizeof(cTemp));
					GetNpcName(m_stQuest.sTargetType, cTemp);
					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, NPC_TALK_HANDLER16, m_stQuest.sTargetCount, cTemp);
					PutAlignedString(sX, sX + szX, sY + 50 + 60, cTxt, 55, 25, 25);

					ZeroMemory(cTxt, sizeof(cTxt));
					if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0)
					{
						strcpy(cTxt, DRAW_DIALOGBOX_QUEST31); // "Location : Anywhere"
						PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);
					}
					else
					{
						ZeroMemory(cTemp, sizeof(cTemp));
						GetOfficialMapName(m_stQuest.cTargetName, cTemp);
						fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp); // "Map : %s"
						PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);

						if (m_stQuest.sX != 0)
						{
							ZeroMemory(cTxt, sizeof(cTxt));
							fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange); // "Position: %d, %d Range: %d block"
							PutAlignedString(sX, sX + szX, sY + 50 + 90, cTxt, 55, 25, 25);
						}
					}

					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution); // "Contribution: %d"
					PutAlignedString(sX, sX + szX, sY + 50 + 105, cTxt, 55, 25, 25);
					break;

				case 7: //
					if (m_stQuest.bIsQuestCompleted == false)
						PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST26, 55, 25, 25);
					else PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_QUEST27, 55, 25, 25);

					ZeroMemory(cTemp, sizeof(cTemp));
					switch (m_stQuest.sWho)
					{
						case 1:
						case 2:
						case 3: break;
						case 4: strcpy(cTemp, NPC_NAME_CITYHALL_OFFICER); break;
						case 5:
						case 6:
						case 7: break;
					}
					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST29, cTemp);
					PutAlignedString(sX, sX + szX, sY + 50 + 45, cTxt, 55, 25, 25);

					PutAlignedString(sX, sX + szX, sY + 50 + 60, DRAW_DIALOGBOX_QUEST30, 55, 25, 25);

					ZeroMemory(cTxt, sizeof(cTxt));
					if (memcmp(m_stQuest.cTargetName, "NONE", 4) == 0)
					{
						strcpy(cTxt, DRAW_DIALOGBOX_QUEST31);
						PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);
					}
					else
					{
						ZeroMemory(cTemp, sizeof(cTemp));
						GetOfficialMapName(m_stQuest.cTargetName, cTemp);
						fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST32, cTemp);
						PutAlignedString(sX, sX + szX, sY + 50 + 75, cTxt, 55, 25, 25);

						if (m_stQuest.sX != 0)
						{
							ZeroMemory(cTxt, sizeof(cTxt));
							fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST33, m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);
							PutAlignedString(sX, sX + szX, sY + 50 + 90, cTxt, 55, 25, 25);
						}
					}

					ZeroMemory(cTxt, sizeof(cTxt));
					fmt::format_to(cTxt, DRAW_DIALOGBOX_QUEST34, m_stQuest.sContribution);//" %dPoint"
					PutAlignedString(sX, sX + szX, sY + 50 + 105, cTxt, 55, 25, 25);
					break;
			}
			break;

		case 2:
			PutAlignedString(sX, sX + szX, sY + 50 + 115 - 30, DRAW_DIALOGBOX_QUEST35, 55, 25, 25);
			break;
	}

	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
}

void helbreath::DrawDialogBox_SellList()
{
	short sX, sY, szX;
	int  i, iItem;
	char cTemp[255], cStr1[64], cStr2[64], cStr3[64];

	char onButton = m_dialogBoxes[31].OnButton();
	sX = m_dialogBoxes[31].m_X;
	sY = m_dialogBoxes[31].m_Y;
	szX = m_dialogBoxes[31].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

	iItem = 0;
	for (i = 0; i < MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex != -1)
		{
			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pItemList[m_stSellItemList[i].iIndex]->m_cName, m_pItemList[m_stSellItemList[i].iIndex]->m_dwAttribute, cStr1, cStr2, cStr3);
			if (m_stSellItemList[i].iAmount > 1)
			{
				fmt::format_to(cTemp, DRAW_DIALOGBOX_SELL_LIST1, m_stSellItemList[i].iAmount, cStr1);
				if (onButton == i + 1)
					PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cTemp, 255, 255, 255);
				else
				{
					if (m_bIsSpecial)
						PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cTemp, 0, 255, 0);
					else
						PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cTemp, 45, 25, 25);
				}
			}
			else
			{
				if (onButton == i + 1)
				{
					if ((strlen(cStr2) == 0) && (strlen(cStr3) == 0)) PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 255, 255, 255);
					else
					{
						ZeroMemory(G_cTxt, sizeof(G_cTxt));
						if ((strlen(cStr1) + strlen(cStr2) + strlen(cStr3)) < 36)
						{
							if ((strlen(cStr2) > 0) && (strlen(cStr3) > 0)) fmt::format_to(G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3);
							else fmt::format_to(G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3);
							PutAlignedString(sX, sX + szX, sY + 55 + i * 15, G_cTxt, 255, 255, 255);

						}
						else
						{
							if ((strlen(cStr2) > 0) && (strlen(cStr3) > 0)) fmt::format_to(G_cTxt, "(%s, %s)", cStr2, cStr3);
							else fmt::format_to(G_cTxt, "(%s%s)", cStr2, cStr3);
							PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 255, 255, 255);
							PutAlignedString(sX, sX + szX, sY + 55 + i * 15 + 15, G_cTxt, 200, 200, 200);
							i++;
						}
					}
				}
				else
				{
					if ((strlen(cStr2) == 0) && (strlen(cStr3) == 0))
					{
						if (m_bIsSpecial)
							PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 0, 255, 0);
						else
							PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 45, 25, 25);
					}
					else
					{
						ZeroMemory(G_cTxt, sizeof(G_cTxt));
						if ((strlen(cStr1) + strlen(cStr2) + strlen(cStr3)) < 36)
						{
							if ((strlen(cStr2) > 0) && (strlen(cStr3) > 0)) fmt::format_to(G_cTxt, "%s(%s, %s)", cStr1, cStr2, cStr3);
							else fmt::format_to(G_cTxt, "%s(%s%s)", cStr1, cStr2, cStr3);

							if (m_bIsSpecial)
								PutAlignedString(sX, sX + szX, sY + 55 + i * 15, G_cTxt, 0, 255, 0);
							else
								PutAlignedString(sX, sX + szX, sY + 55 + i * 15, G_cTxt, 45, 25, 25);

						}
						else
						{
							if (m_bIsSpecial)
								PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 0, 255, 0);
							else
								PutAlignedString(sX, sX + szX, sY + 55 + i * 15, cStr1, 45, 25, 25);
						}
					}
				}
			}
		}
		else iItem++;

	if (iItem == MAXSELLLIST)
	{
		PutAlignedString(sX, sX + szX, sY + 55 + 30 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST2);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 45 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST3);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 60 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST4);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 75 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST5);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 95 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST6);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 110 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST7);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 125 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST8);//"
		PutAlignedString(sX, sX + szX, sY + 55 + 155 + 282 - 117 - 170, DRAW_DIALOGBOX_SELL_LIST9);//"

	}

	if (onButton == MAXSELLLIST + 1 && (iItem < MAXSELLLIST))
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 39);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 38);

	if (onButton == MAXSELLLIST + 2)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
}

void helbreath::DrawDialogBox_SellorRepairItem()
{
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	char cItemID, cItemColor, cTxt[120], cTemp[120], cStr2[120], cStr3[120];

	char onButton = m_dialogBoxes[23].OnButton();
	sX = m_dialogBoxes[23].m_X;
	sY = m_dialogBoxes[23].m_Y;

	switch (m_dialogBoxes[23].GetMode())
	{
		case 1:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

			cItemID = m_dialogBoxes[23].sV1;

			cItemColor = m_pItemList[cItemID]->m_ItemColor;
			if (cItemColor == 0)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
					m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
			else
			{
				switch (m_pItemList[cItemID]->m_sSprite)
				{
					case 1: // Swds
					case 2: // Bows
					case 3: // Shields
					case 15: // Axes hammers
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
							, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
						break;
					default: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
						, m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
						break;
				}
			}
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));

			GetItemName(m_pItemList[cItemID]->m_cName, m_pItemList[cItemID]->m_dwAttribute, cTemp, cStr2, cStr3);
			if (m_dialogBoxes[23].sV4 == 1) strcpy(cTxt, cTemp);
			else fmt::format_to(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM1, m_dialogBoxes[23].sV4, cTemp);

			if (m_bIsSpecial)
			{
				PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0, 255, 0);
				PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 0, 255, 0);
			}
			else
			{
				PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45, 25, 25);
				PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 45, 25, 25);
			}

			fmt::format_to(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_dialogBoxes[23].sV2);
			PutString(sX + 95 + 15, sY + 53 + 60, cTxt, Color(255, 45, 25, 25));
			fmt::format_to(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM3, m_dialogBoxes[23].sV3);
			PutString(sX + 95 + 15, sY + 53 + 75, cTxt, Color(255, 45, 25, 25));
			PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM4, Color(255, 45, 25, 25));

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 39);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 38);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 2:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 10);
			cItemID = m_dialogBoxes[23].sV1;
			cItemColor = m_pItemList[cItemID]->m_ItemColor;
			if (cItemColor == 0)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteFast(sX + 62 + 15, sY + 84 + 30,
					m_pItemList[cItemID]->m_sSpriteFrame, dwTime);
			else
			{
				switch (m_pItemList[cItemID]->m_sSprite)
				{
					case 1: // Swds
					case 2: // Bows
					case 3: // Shields
					case 15: // Axes hammers
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
							, m_pItemList[cItemID]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
						break;

					default: m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[cItemID]->m_sSprite]->PutSpriteRGB(sX + 62 + 15, sY + 84 + 30
						, m_pItemList[cItemID]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
						break;
				}
			}
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cStr2, sizeof(cStr2));
			ZeroMemory(cStr3, sizeof(cStr3));
			GetItemName(m_pItemList[cItemID], cTemp, cStr2, cStr3);
			fmt::format_to(cTxt, "%s", cTemp);
			//		PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45,25,25);
			//		PutAlignedString(sX + 25 +1, sX + 240 +1, sY + 60, cTxt, 45,25,25);
			if (m_bIsSpecial)
			{
				PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 0, 255, 0);
				PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 0, 255, 0);
			}
			else
			{
				PutAlignedString(sX + 25, sX + 240, sY + 60, cTxt, 45, 25, 25);
				PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 60, cTxt, 45, 25, 25);
			}
			fmt::format_to(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM2, m_dialogBoxes[23].sV2);
			PutString(sX + 95 + 15, sY + 53 + 60, cTxt, Color(255, 45, 25, 25));
			fmt::format_to(cTxt, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM6, m_dialogBoxes[23].sV3);
			PutString(sX + 95 + 15, sY + 53 + 75, cTxt, Color(255, 45, 25, 25));
			PutString(sX + 55, sY + 190, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM7, Color(255, 45, 25, 25));

			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 43);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 42);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 3:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

			PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM8, Color(255, 45, 25, 25));//"
			PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, Color(255, 45, 25, 25));//"
			PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, Color(255, 45, 25, 25));//"
			break;

		case 4:
			//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 10);

			PutString(sX + 55, sY + 100, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM11, Color(255, 45, 25, 25));//"
			PutString(sX + 55, sY + 120, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM9, Color(255, 45, 25, 25));//"
			PutString(sX + 55, sY + 135, DRAW_DIALOGBOX_SELLOR_REPAIR_ITEM10, Color(255, 45, 25, 25));//"
			break;
	}
}


void helbreath::DrawDialogBox_Skill()
{
	short sX, sY;
	int  iTotalLines, iPointerLoc;
	char cTemp[255], cTemp2[255];
	double d1, d2, d3;
	Point pointerLoc;

	char onButton = m_dialogBoxes[15].OnButton();
	sX = m_dialogBoxes[15].m_X;
	sY = m_dialogBoxes[15].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0); // Normal Dialog
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 1); // Skill Dialog Title Bar

	switch (m_dialogBoxes[15].GetMode())
	{
		case 0:
			for (int line = 0, skillIndex = 0; line < 17; skillIndex++)
				if (line < MAXSKILLTYPE && m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView])
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					fmt::format_to(cTemp, "%s", m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_cName);
					m_Misc.ReplaceString(cTemp, '-', ' ');
					ZeroMemory(cTemp2, sizeof(cTemp2));
					fmt::format_to(cTemp2, "%3d%%", m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_iLevel);

					Color color = Color(255, 5, 5, 5);
					if (m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_bIsUseable
						&& m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_iLevel != 0)
					{
						if (onButton == line + 1)
						{
							color = Color(255, 255, 255, 255);
						}
						else
						{
							color = Color(255, 34, 30, 120);
						}
					}

					PutString(sX + 30, sY + 45 + line * 15, cTemp, color);
					PutString(sX + 183, sY + 45 + line * 15, cTemp2, color);

					if (m_iDownSkillIndex == (skillIndex + m_dialogBoxes[15].sView))
						m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(sX + 215, sY + 47 + line * 15, 21, 50, 50, 50, m_dwTime);
					else m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + 215, sY + 47 + line * 15, 20, m_dwTime);
					line++;
				}

			iTotalLines = 0;
			for (int i = 0; i < MAXSKILLTYPE; i++)
				if (m_pSkillCfgList[i] != 0) iTotalLines++;

			pointerLoc = m_dialogBoxes[15].HandleScroll(17, iTotalLines);

			if (iTotalLines > 17)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			break;
	}
}

void helbreath::DrawDialogBox_SkillDlg()
{
	int i, iLoc, iAdjX, iAdjY, iAmount;
	char cTemp[120], cTemp2[120];
	short sX, sY, szX;
	char cStr1[64], cStr2[64], cStr3[64];
	uint64_t dwTime = m_dwCurTime;

	iAdjX = 5;
	iAdjY = 8;
	char onButton = m_dialogBoxes[26].OnButton();
	switch (m_dialogBoxes[26].GetMode())
	{
		case 1: // Alchemy waiting incredients
			if (m_dialogBoxes[26].cStr[0] != 0)
			{
				sX = m_dialogBoxes[26].m_X + iAdjX + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
				sY = m_dialogBoxes[26].m_Y + iAdjY + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
			}
			else
			{
				sX = m_dialogBoxes[26].m_X;
				sY = m_dialogBoxes[26].m_Y;
			}

			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

			if (m_dialogBoxes[26].sV1 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV2 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV3 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV4 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV5 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV6 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);

			if (onButton == 1)
				PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16, 16, 30);
			else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);

			break;

		case 2: // Alchemy, creating a potion
			if (m_dialogBoxes[26].cStr[0] != 0)
			{
				sX = m_dialogBoxes[26].m_X + iAdjX + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
				sY = m_dialogBoxes[26].m_Y + iAdjY + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
			}
			else
			{
				sX = m_dialogBoxes[26].m_X;
				sY = m_dialogBoxes[26].m_Y;
			}
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX, sY, 1, dwTime);

			if (m_dialogBoxes[26].sV1 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV2 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV3 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV4 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV5 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV6 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutTransSprite50(sX + iAdjX + 55 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);

			PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20, 6, 6);


			if ((dwTime - m_dialogBoxes[26].dwT1) > 1000)
			{
				m_dialogBoxes[26].dwT1 = dwTime;
				m_dialogBoxes[26].cStr[0]++;
			}

			if (m_dialogBoxes[26].cStr[0] >= 4)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_CREATEPOTION, 0, 0, 0, 0, 0);
				DisableDialogBox(26);
				PlaySound('E', 42, 0);
			}
			break;

		case 3: // Manuf: Choose what you want to create
			sX = m_dialogBoxes[26].m_X;
			sY = m_dialogBoxes[26].m_Y;
			szX = m_dialogBoxes[26].sSizeX;
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
			PutString(sX + iAdjX + 49, sY + iAdjY + 33, "Name", Color(255, 0, 0, 0));
			PutString(sX + iAdjX + 171, sY + iAdjY + 33, "Max.Title", Color(255, 0, 0, 0));

			iLoc = 0;
			for (i = 0; i < 13; i++)
				if (m_pDispBuildItemList[i + m_dialogBoxes[26].sView] != 0)
				{

					ZeroMemory(cTemp, sizeof(cTemp));
					GetItemName(m_pDispBuildItemList[i + m_dialogBoxes[26].sView]->m_cName, 0, cStr1, cStr2, cStr3);
					fmt::format_to(cTemp, "%s", cStr1);
					ZeroMemory(cTemp2, sizeof(cTemp2));
					fmt::format_to(cTemp2, "%d%", m_pDispBuildItemList[i + m_dialogBoxes[26].sView]->m_iMaxSkill);

					if (onButton == i + 1)
					{
						PutString(m_dialogBoxes[26].ButtonX(i + 1), m_dialogBoxes[26].ButtonY(i + 1), cTemp, Color(255, 255, 255, 255));
						PutString(m_dialogBoxes[26].ButtonX(i + 1) + 155, m_dialogBoxes[26].ButtonY(i + 1), cTemp2, Color(255, 255, 255, 255));
					}
					else
					{
						if (m_pDispBuildItemList[i + m_dialogBoxes[26].sView]->m_bBuildEnabled == true)
						{
							PutString(m_dialogBoxes[26].ButtonX(i + 1), m_dialogBoxes[26].ButtonY(i + 1), cTemp, Color(255, 34, 30, 120));
							PutString(m_dialogBoxes[26].ButtonX(i + 1) + 155, m_dialogBoxes[26].ButtonY(i + 1), cTemp2, Color(255, 34, 30, 120));
						}
						else
						{
							PutString(m_dialogBoxes[26].ButtonX(i + 1), m_dialogBoxes[26].ButtonY(i + 1), cTemp, Color(255, 45, 25, 25));
							PutString(m_dialogBoxes[26].ButtonX(i + 1) + 155, m_dialogBoxes[26].ButtonY(i + 1), cTemp2, Color(255, 45, 25, 25));
						}
					}

					iLoc++;
				}
			if ((m_dialogBoxes[26].sView >= 1) && (m_pDispBuildItemList[m_dialogBoxes[26].sView - 1] != 0))
				m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 210, 23, dwTime);
			else m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 210, 23, 5, 5, 5, dwTime);

			if (m_pDispBuildItemList[m_dialogBoxes[26].sView + 13] != 0)
				m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + iAdjX + 225, sY + iAdjY + 230, 24, dwTime);
			else m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutTransSpriteRGB(sX + iAdjX + 225, sY + iAdjY + 230, 24, 5, 5, 5, dwTime);

			if ((m_stMCursor.LB != 0) && m_dialogBoxes[26].IsTop())
			{
				if (onButton == 14)
				{
					m_dialogBoxes[26].sView--;
				}

				if (onButton == 15)
				{
					if (m_pDispBuildItemList[m_dialogBoxes[26].sView + 13] != 0)
						m_dialogBoxes[26].sView++;
				}
			}
			if ((m_stMCursor.sZ != 0) && m_dialogBoxes[26].IsTop())
			{
				m_dialogBoxes[26].sView = m_dialogBoxes[26].sView - m_stMCursor.sZ / 60;
				//DIRECTX m_dInput.m_sZ = 0;
			}
			if (m_pDispBuildItemList[m_dialogBoxes[26].sView + 12] == 0)
			{
				while (1)
				{
					m_dialogBoxes[26].sView--;
					if (m_dialogBoxes[26].sView < 1) break;
					if (m_pDispBuildItemList[m_dialogBoxes[26].sView + 12] != 0) break;
				}
			}
			if (m_dialogBoxes[26].sView < 0) m_dialogBoxes[26].sView = 0;

			PutAlignedString(sX, sX + m_dialogBoxes[26].sSizeX, sY + 260, DRAW_DIALOGBOX_SKILLDLG2, 55, 25, 25);//" List of items which you can make with"
			PutAlignedString(sX, sX + m_dialogBoxes[26].sSizeX, sY + 275, DRAW_DIALOGBOX_SKILLDLG3, 55, 25, 25);//"your current skill. The items you can"
			PutAlignedString(sX, sX + m_dialogBoxes[26].sSizeX, sY + 290, DRAW_DIALOGBOX_SKILLDLG4, 55, 25, 25);//"make now with your current stuff will"
			PutAlignedString(sX, sX + m_dialogBoxes[26].sSizeX, sY + 305, DRAW_DIALOGBOX_SKILLDLG5, 55, 25, 25);//"be displayed in blue. "
			PutAlignedString(sX, sX + m_dialogBoxes[26].sSizeX, sY + 330, DRAW_DIALOGBOX_SKILLDLG6, 55, 25, 25);//"Select an item you want to manufacture."

			strcpy(cTemp, DRAW_DIALOGBOX_SKILLDLG35);
			strcat(cTemp, m_manuAutoFill ? DRAW_ENABLED : DRAW_DISABLED);
			//PutAlignedString(&m_dialogBoxes[26].GetButton(16), cTemp, onButton == 16 ?Color(255,255,255,255) :Color(255,34,30,120));//uncomment

			break;

		case 4: // Manuf: Waiting for incredients
			sX = m_dialogBoxes[26].m_X;
			sY = m_dialogBoxes[26].m_Y;
			szX = m_dialogBoxes[26].sSizeX;
			iAdjX = -1;
			iAdjY = -7;
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
			m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
				m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprFrame, dwTime);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);
			fmt::format_to(cTemp, "%s", cStr1);
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, Color(255, 255, 255, 255));

			fmt::format_to(cTemp, DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
				, m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSkillLimit
				, m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iMaxSkill);
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 2 * 15, cTemp, Color(255, 45, 25, 25));
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 3 * 15 + 5, DRAW_DIALOGBOX_SKILLDLG8, Color(255, 45, 25, 25));//"Ingredients Needed:"

			iLoc = 4;
			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[1] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[1];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[1] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[2] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[2];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[2] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[3] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[3];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[3] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[4] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[4];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[4] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[5] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[5];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[5] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[6] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[6];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[6] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 150, 150, 150));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bBuildEnabled == true)
			{
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
				m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 100 + 180, 2, dwTime);

				if (m_dialogBoxes[26].sV1 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180,
						m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);

				if (m_dialogBoxes[26].sV2 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180,
						m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);

				if (m_dialogBoxes[26].sV3 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180,
						m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);

				if (m_dialogBoxes[26].sV4 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180,
						m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);

				if (m_dialogBoxes[26].sV5 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180,
						m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);

				if (m_dialogBoxes[26].sV6 != -1)
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180,
						m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);

				PutAlignedString(sX, sX + szX, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG15, 55, 25, 25);//" Click MANUFACTURE button after"
				PutAlignedString(sX, sX + szX, sY + iAdjY + 245 + 75, DRAW_DIALOGBOX_SKILLDLG16, 55, 25, 25);//"dragging ingredients in the blanks"
				PutAlignedString(sX, sX + szX, sY + iAdjY + 260 + 75, DRAW_DIALOGBOX_SKILLDLG17, 55, 25, 25);//"to manufacture above item."

				if (onButton == 1)
					PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
				else PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);


				if (onButton == 2)
				{
					if (m_dialogBoxes[26].cStr[4] == 1)
						PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 6, 6, 20);
					else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 10, 10, 10);
				}
				else
				{
					if (m_dialogBoxes[26].cStr[4] == 1)
						PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 0, 0, 7);
					else PutString_SprFont(sX + iAdjX + 153, sY + iAdjY + 330 + 23, "Manufacture", 10, 10, 10);
				}
			}
			else
			{
				PutAlignedString(sX, sX + szX, sY + iAdjY + 200 + 75, DRAW_DIALOGBOX_SKILLDLG18, 55, 25, 25);//"There are not enough ingredients to"
				PutAlignedString(sX, sX + szX, sY + iAdjY + 215 + 75, DRAW_DIALOGBOX_SKILLDLG19, 55, 25, 25);//"manufacture. Needed materials are"
				PutAlignedString(sX, sX + szX, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG20, 55, 25, 25);//"displayed in grey."
				if (onButton == 1)
					PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
				else PutString_SprFont(sX + iAdjX + 25, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);
			}
			break;

		case 5: // Manuf: in progress
			sX = m_dialogBoxes[26].m_X;
			sY = m_dialogBoxes[26].m_Y;
			iAdjX = -1;
			iAdjY = -7;

			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
			m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
				m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprFrame, dwTime);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);
			fmt::format_to(cTemp, "%s", cStr1);
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, Color(255, 255, 255, 255));

			fmt::format_to(cTemp, DRAW_DIALOGBOX_SKILLDLG7 // "Skill level: %d/%d"
				, m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSkillLimit, m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iMaxSkill);
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 2 * 15, cTemp, Color(255, 45, 25, 25));
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55 + 3 * 15 + 5, DRAW_DIALOGBOX_SKILLDLG8, Color(255, 45, 25, 25));//"Ingredients Needed:"

			iLoc = 4;
			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[1] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName1, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[1];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[1] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[2] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName2, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[2];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[2] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[3] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName3, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[3];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[3] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[4] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName4, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[4];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[4] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[5] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName5, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[5];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[5] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[6] != 0)
			{
				GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cElementName6, 0, cStr1, cStr2, cStr3);
				iAmount = m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iElementCount[6];
				fmt::format_to(cTemp, "%d %s", iAmount, cStr1);
				if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bElementFlag[6] == true)
					PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 45, 25, 25));
				else PutString(sX + iAdjX + 44 + 20 + 60, sY + iAdjY + 55 + iLoc * 15 + 5, cTemp, Color(255, 120, 120, 120));
				iLoc++;
			}

			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 55 + 180, 2, dwTime);
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 1 + 13, sY + iAdjY + 100 + 180, 2, dwTime);
			m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + iAdjX + 55 + 30 + 45 * 2 + 13, sY + iAdjY + 100 + 180, 2, dwTime);

			if (m_dialogBoxes[26].sV1 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV2 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV3 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 55 + 180,
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV4 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV5 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 1 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV6 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + 45 * 2 + 30 + 13, sY + iAdjY + 100 + 180,
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);

			PutString(sX + iAdjX + 33, sY + iAdjY + 230 + 75, DRAW_DIALOGBOX_SKILLDLG29, Color(255, 55, 25, 25));//" Manufacturing the items...."
			PutString(sX + iAdjX + 33, sY + iAdjY + 245 + 75, DRAW_DIALOGBOX_SKILLDLG30, Color(255, 55, 25, 25));//"Please wait until manufacture finishes."

			if ((dwTime - m_dialogBoxes[26].dwT1) > 400) //if ((dwTime - m_stDialogBoxInfo[26].dwT1) > 1000) 
			{
				m_dialogBoxes[26].dwT1 = dwTime;
				m_dialogBoxes[26].cStr[1]++;
				if (m_dialogBoxes[26].cStr[1] >= 7) m_dialogBoxes[26].cStr[1] = 7;
			}

			if (m_dialogBoxes[26].cStr[1] == 4)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_BUILDITEM, 0, 0, 0, 0, m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cName);
				m_dialogBoxes[26].cStr[1]++;
			}
			break;

		case 6: // Manuf: Done
			sX = m_dialogBoxes[26].m_X;
			sY = m_dialogBoxes[26].m_Y;
			iAdjX = -1;
			iAdjY = -7;

			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 0);
			DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 8);
			m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprH]->PutSpriteFast(sX + iAdjX + 62 + 5, sY + iAdjY + 84 + 17,
				m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_iSprFrame, dwTime);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_cName, 0, cStr1, cStr2, cStr3);

			fmt::format_to(cTemp, "%s", cStr1);
			PutString(sX + iAdjX + 44 + 10 + 60, sY + iAdjY + 55, cTemp, Color(255, 255, 255, 255));

			if (m_dialogBoxes[26].cStr[2] == 1)
			{
				PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 200 - 45, DRAW_DIALOGBOX_SKILLDLG31, Color(255, 55, 25, 25));//" Success in manufacture!"

				if (m_dialogBoxes[26].sV1 == ITEMTYPE_MATERIAL)
				{
					fmt::format_to(G_cTxt, DRAW_DIALOGBOX_SKILLDLG32, m_dialogBoxes[26].cStr[3]);//"The purity of product is %d%%."
					PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 215 - 45, G_cTxt, Color(255, 55, 25, 25));
				}
				else
				{
					fmt::format_to(G_cTxt, DRAW_DIALOGBOX_SKILLDLG33, (int)m_dialogBoxes[26].cStr[3] + 100);//"The completion of product is %d%%."
					PutString(sX + iAdjX + 33, sY + iAdjY + 215 - 45, G_cTxt, Color(255, 55, 25, 25));
				}
			}
			else
			{
				PutString(sX + iAdjX + 33 + 11, sY + iAdjY + 200, DRAW_DIALOGBOX_SKILLDLG34, Color(255, 55, 25, 25));//"Failed on manufacture."
			}

			if (onButton == 1)
				PutString_SprFont(sX + iAdjX + 35, sY + iAdjY + 330 + 23, "Back", 6, 6, 20);
			else PutString_SprFont(sX + iAdjX + 35, sY + iAdjY + 330 + 23, "Back", 0, 0, 7);
			break;


		case 7: // Crafting, wait for incredients
			if (m_dialogBoxes[26].cStr[0] != 0)
			{
				sX = m_dialogBoxes[26].m_X + iAdjX + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
				sY = m_dialogBoxes[26].m_Y + iAdjY + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
			}
			else
			{
				sX = m_dialogBoxes[26].m_X;
				sY = m_dialogBoxes[26].m_Y;
			}
			m_pSprite[SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

			if (m_dialogBoxes[26].sV1 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV2 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 40 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV3 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV4 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV5 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 115 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);

			if (m_dialogBoxes[26].sV6 != -1)
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
				m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);
			if (onButton == 1)
				PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 16, 16, 30);
			else PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Try Now!", 6, 6, 20);
			break;

		case 8: // Crafting in progress
			if (m_dialogBoxes[26].cStr[0] != 0)
			{
				sX = m_dialogBoxes[26].m_X + iAdjX + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
				sY = m_dialogBoxes[26].m_Y + iAdjY + (m_dialogBoxes[26].cStr[0] - (rand() % (m_dialogBoxes[26].cStr[0] * 2)));
			}
			else
			{
				sX = m_dialogBoxes[26].m_X;
				sY = m_dialogBoxes[26].m_Y;
			}
			m_pSprite[SPRID_INTERFACE_CRAFTING]->PutSpriteFast(sX, sY, 0, dwTime);

			if (m_dialogBoxes[26].sV1 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV1]->m_sSprite]->PutSpriteFast(sX + iAdjX + 55 + (1 - (rand() % 3)) + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV1]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV1]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV1]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			if (m_dialogBoxes[26].sV2 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV2]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 40 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV2]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV2]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV2]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			if (m_dialogBoxes[26].sV3 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV3]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 55 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV3]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV3]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV3]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			if (m_dialogBoxes[26].sV4 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV4]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV4]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV4]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV4]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			if (m_dialogBoxes[26].sV5 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV5]->m_sSprite]->PutSpriteFast(sX + iAdjX + 65 + 45 * 1 + (1 - (rand() % 3)), sY + iAdjY + 115 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV5]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV5]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV5]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			if (m_dialogBoxes[26].sV6 != -1)
			{
				m_pSprite[SPRID_ITEMPACK_PIVOTPOINT +
					m_pItemList[m_dialogBoxes[26].sV6]->m_sSprite]->PutSpriteFast(sX + iAdjX + 75 + 45 * 2 + (1 - (rand() % 3)), sY + iAdjY + 100 + (1 - (rand() % 3)),
						m_pItemList[m_dialogBoxes[26].sV6]->m_sSpriteFrame, dwTime);
				if ((m_pItemList[m_dialogBoxes[26].sV6]->m_cItemType == ITEMTYPE_EQUIP)
					&& (m_pItemList[m_dialogBoxes[26].sV6]->m_cEquipPos == EQUIPPOS_NECK))
					m_iContributionPrice = 10;
			}
			PutString_SprFont(sX + iAdjX + 60, sY + iAdjY + 175, "Creating...", 20, 6, 6);

			if ((dwTime - m_dialogBoxes[26].dwT1) > 1000)
			{
				m_dialogBoxes[26].dwT1 = dwTime;
				m_dialogBoxes[26].cStr[1]++;
			}
			if (m_dialogBoxes[26].cStr[1] >= 5)//m_pDispCraftItemList
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_CRAFTITEM, 0, 0, 0, 0, 0);
				DisableDialogBox(26);
				PlaySound('E', 42, 0);
			}
			break;
	}
}

void helbreath::DrawDialogBox_SysMenu()
{
	short sX, sY;
	char onButton = m_dialogBoxes[19].OnButton();

	sX = m_dialogBoxes[19].m_X;
	sY = m_dialogBoxes[19].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME1, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 6);
	PutString(sX + 23, sY + 63, DRAW_DIALOGBOX_SYSMENU_DETAILLEVEL, Color(255, 255, 255, 255));
	if (m_cDetailLevel == 0)
		PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, Color(255, 255, 255, 255));
	else PutString(sX + 121, sY + 63, DRAW_DIALOGBOX_SYSMENU_LOW, Color(255, 45, 25, 25));
	if (m_cDetailLevel == 1)
		PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, Color(255, 255, 255, 255));
	else PutString(sX + 153, sY + 63, DRAW_DIALOGBOX_SYSMENU_NORMAL, Color(255, 45, 25, 25));
	if (m_cDetailLevel == 2)
		PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, Color(255, 255, 255, 255));
	else PutString(sX + 205, sY + 63, DRAW_DIALOGBOX_SYSMENU_HIGH, Color(255, 45, 25, 25));

	PutString(sX + 23, sY + 84, DRAW_DIALOGBOX_SYSMENU_SOUND, Color(255, 255, 255, 255));
	if (m_bSoundFlag)
	{
		if (m_bSoundStat) PutString(sX + 85, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
		else PutString(sX + 83, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));
	}
	else PutString(sX + 68, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, Color(255, 100, 100, 100));

	PutString(sX + 123, sY + 84, DRAW_DIALOGBOX_SYSMENU_MUSIC, Color(255, 255, 255, 255));
	if (m_bSoundFlag)
	{
		if (m_bMusicStat) PutString(sX + 180, sY + 85, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
		else PutString(sX + 178, sY + 85, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));
	}
	else PutString(sX + 163, sY + 85, DRAW_DIALOGBOX_SYSMENU_DISABLED, Color(255, 100, 100, 100));

	PutString(sX + 23, sY + 106, DRAW_DIALOGBOX_SYSMENU_WHISPER, Color(255, 255, 255, 255));
	if (m_bWhisper) PutString(sX + 85, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
	else PutString(sX + 82, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));

	PutString(sX + 123, sY + 106, DRAW_DIALOGBOX_SYSMENU_SHOUT, Color(255, 255, 255, 255));
	if (m_bShout) PutString(sX + 180, sY + 106, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
	else PutString(sX + 177, sY + 106, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));

	PutString(sX + 23, sY + 124, DRAW_DIALOGBOX_SYSMENU_SOUNDVOLUME, Color(255, 255, 255, 255));
	DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cSoundVolume, sY + 129, 8);

	PutString(sX + 23, sY + 141, DRAW_DIALOGBOX_SYSMENU_MUSICVOLUME, Color(255, 255, 255, 255));
	DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX + 130 + m_cMusicVolume, sY + 145, 8);

	PutString(sX + 23, sY + 158, DRAW_DIALOGBOX_SYSMENU_TRANSPARENCY, Color(255, 255, 255, 255));
	if (m_bDialogTrans) PutString(sX + 208, sY + 158, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
	else PutString(sX + 207, sY + 158, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));

	PutString(sX + 23, sY + 180, DRAW_DIALOGBOX_SYSMENU_GUIDEMAP, Color(255, 255, 255, 255));
	if (m_bIsDialogEnabled[9]) PutString(sX + 99, sY + 180, DRAW_DIALOGBOX_SYSMENU_ON, Color(255, 255, 255, 255));
	else PutString(sX + 98, sY + 180, DRAW_DIALOGBOX_SYSMENU_OFF, Color(255, 200, 200, 200));

	if (onButton == 14) // Extended Menu Fixed xRisenx
		(DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 163, sY + 177, 51));
	else (DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 163, sY + 177, 50));

	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	fmt::format_to(G_cTxt, "M:%d - D:%d - H:%d - Min:%d - S:%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
	PutString(sX + 23, sY + 204, G_cTxt, Color(255, 255, 255, 255));

	//v2.172
#ifdef _DEBUG
	PutString3(sX + 23, sY + 41, UPDATE_SCREEN_ON_SELECT_CHARACTER36, Color(255, 45, 25, 25)); // "Test server"
#else

	if (strcmp(m_cWorldServerName, NAME_WORLDNAME1) == 0)
		PutString3(sX + 23, sY + 41, MSG_WORLDNAME1, Color(255, 45, 25, 25));

	else if (strcmp(m_cWorldServerName, NAME_WORLDNAME2) == 0)
		PutString3(sX + 23, sY + 41, MSG_WORLDNAME2, Color(255, 45, 25, 25));
#endif

	if ((m_stMCursor.LB != 0) && m_dialogBoxes[19].IsTop())
		//  (msX >= sX + 120) && (msX <= sX + 242) && (msY >= sY +122) && (msY <= sY +138)
	{
		if (onButton == 12)
		{
			m_cSoundVolume = m_stMCursor.sX - (sX + 127);
			if (m_cSoundVolume > 100) m_cSoundVolume = 100;
			if (m_cSoundVolume < 0) m_cSoundVolume = 0;
		}
		else if (onButton == 13)
		{
			m_cMusicVolume = m_stMCursor.sX - (sX + 127);
			if (m_cMusicVolume > 100) m_cMusicVolume = 100;
			if (m_cMusicVolume < 0) m_cMusicVolume = 0;
			if (m_bSoundFlag)
			{
				int iVol;
				iVol = (m_cMusicVolume - 100) * 20;
				if (iVol > 0) iVol = 0;
				if (iVol < -10000) iVol = -10000;
				// 				if (m_pBGM != NULL)
				// 				{
				// 					m_pBGM->bStop(TRUE);
				// 					m_pBGM->Play(FALSE, 0, iVol);
				// 				}//DIRECTX
			}
		}
	}
	else m_dialogBoxes[19].bIsScrollSelected = false;

	// Log-Out
	if (m_cLogOutCount == -1)
	{
		if (onButton == 10)
			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + 225, 9);
		else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + 225, 8);
	}
	else
	{  //Continue
		if (onButton == 10)
			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + 225, 7);
		else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + 225, 6);
	}
	// Restart
	if ((m_iHP <= 0) && (m_cRestartCount == -1))
	{
		if (onButton == 11)
			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + 225, 37);
		else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + 225, 36);
	}
}

//\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

void helbreath::bItemDrop_Character()
{
	ItemEquipHandler((char)m_stMCursor.sSelectedObjectID);
}

void helbreath::bItemDrop_Inventory()
{
	short sX, sY, dX, dY;
	char  cTxt[120];
	if (m_cCommand < 0) return;
	if (m_pItemList[m_stMCursor.sSelectedObjectID] == 0) return;
	if ((m_bSkillUsingStatus == true) && (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true))
	{
		AddEventList(BITEMDROP_INVENTORY1, 10);
		return;
	}
	if (m_bIsItemDisabled[m_stMCursor.sSelectedObjectID] == true) return;
	sY = m_dialogBoxes[2].m_Y;
	sX = m_dialogBoxes[2].m_X;
	dX = m_stMCursor.sX - sX - 32 - m_stMCursor.sDistX;
	dY = m_stMCursor.sY - sY - 44 - m_stMCursor.sDistY;
	if (dY < -10) dY = -10;
	if (dX < 0)   dX = 0;
	if (dX > 170) dX = 170;
	if (dY > 95) dY = 95;

	if (m_droppedOnIconbar) //Puts item back where it was rather than random
	{
		m_droppedOnIconbar = false;
	}
	else
	{
		m_pItemList[m_stMCursor.sSelectedObjectID]->m_sX = dX;
		m_pItemList[m_stMCursor.sSelectedObjectID]->m_sY = dY;
	}

	short sTmpSpr, sTmpSprFrm;
	sTmpSpr = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSprite;
	sTmpSprFrm = m_pItemList[m_stMCursor.sSelectedObjectID]->m_sSpriteFrame;

	char cItemID;
	if (m_bShiftPressed)
	{
		for (int i = 0; i < MAXITEMS; i++)
		{
			if (m_cItemOrder[MAXITEMS - 1 - i] != -1)
			{
				cItemID = m_cItemOrder[MAXITEMS - 1 - i];
				if (m_pItemList[cItemID] != 0 && memcmp(m_pItemList[cItemID]->m_cName, m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, 20) == 0)
				{
					m_pItemList[cItemID]->m_sX = dX;
					m_pItemList[cItemID]->m_sY = dY;
					bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, cItemID, dX, dY, 0, 0);
				}
			}
		}
	}
	else bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, (char)(m_stMCursor.sSelectedObjectID), dX, dY, 0, 0);

	if (m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] == true)
	{
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[m_stMCursor.sSelectedObjectID], cStr1, cStr2, cStr3);
		fmt::format_to(cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
		AddEventList(cTxt, 10);

		if (memcmp(m_pItemList[m_stMCursor.sSelectedObjectID]->m_cName, "AngelicPendant", 14) == 0) PlaySound('E', 53, 0);
		else PlaySound('E', 29, 0);

		// Remove Angelic Stats
		if ((m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos >= 11)
			&& (m_pItemList[m_stMCursor.sSelectedObjectID]->m_cItemType == 1))
		{
			char cItemID = m_stMCursor.sSelectedObjectID;
			if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(STR)", 19) == 0)
			{
				m_angelStat[STAT_STR] = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(DEX)", 19) == 0)
			{
				m_angelStat[STAT_DEX] = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(INT)", 19) == 0)
			{
				m_angelStat[STAT_INT] = 0;
			}
			else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(MAG)", 19) == 0)
			{
				m_angelStat[STAT_MAG] = 0;
			}
		}
		bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_RELEASEITEM, 0, m_stMCursor.sSelectedObjectID, 0, 0, 0);
		m_bIsItemEquipped[m_stMCursor.sSelectedObjectID] = false;
		m_sItemEquipmentStatus[m_pItemList[m_stMCursor.sSelectedObjectID]->m_cEquipPos] = -1;
	}
}

void helbreath::bItemDrop_SellList()
{
	int i;
	char cItemID;

	cItemID = (char)m_stMCursor.sSelectedObjectID;

	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	for (i = 0; i < MAXSELLLIST; i++)
		if (m_stSellItemList[i].iIndex == cItemID)
		{
			AddEventList(BITEMDROP_SELLLIST1, 10);
			return;
		}
	if (strcmp(m_pItemList[cItemID]->m_cName, "Gold") == 0)
	{
		AddEventList(BITEMDROP_SELLLIST2, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		char cStr1[64], cStr2[64], cStr3[64];
		GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
		fmt::format_to(G_cTxt, NOTIFYMSG_CANNOT_SELL_ITEM2, cStr1);
		AddEventList(G_cTxt, 10);
		return;
	}

	if (((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) || (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_ARROW)) &&
		(m_pItemList[cItemID]->m_dwCount > 1))
	{
		m_dialogBoxes[17].m_X = m_stMCursor.sX - 140;
		m_dialogBoxes[17].m_Y = m_stMCursor.sY - 70;
		if (m_dialogBoxes[17].m_Y < 0) m_dialogBoxes[17].m_Y = 0;
		m_dialogBoxes[17].sV1 = m_sPlayerX + 1;
		m_dialogBoxes[17].sV2 = m_sPlayerY + 1;
		m_dialogBoxes[17].sV3 = 1001;
		m_dialogBoxes[17].sV4 = cItemID;
		ZeroMemory(m_dialogBoxes[17].cStr, sizeof(m_dialogBoxes[17].cStr));
		EnableDialogBox(17, cItemID, m_pItemList[cItemID]->m_dwCount, 0);
		m_bIsItemDisabled[cItemID] = true;
	}
	else
	{
		for (i = 0; i < MAXSELLLIST; i++)
			if (m_stSellItemList[i].iIndex == -1)
			{
				m_stSellItemList[i].iIndex = cItemID;
				m_stSellItemList[i].iAmount = 1;
				m_bIsItemDisabled[cItemID] = true;
				return;
			}
		AddEventList(BITEMDROP_SELLLIST3, 10);
	}
}

void helbreath::bItemDrop_ItemUpgrade()
{
	char cItemID;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_cCommand < 0) return;
	if (m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_NONE) return;

	switch (m_dialogBoxes[34].GetMode())
	{
		case 1:
			m_bIsItemDisabled[m_dialogBoxes[34].sV1] = false;
			m_dialogBoxes[34].sV1 = cItemID;
			m_bIsItemDisabled[cItemID] = true;
			PlaySound('E', 29, 0);
			break;

		case 6:
			m_bIsItemDisabled[m_dialogBoxes[34].sV1] = false;
			m_dialogBoxes[34].sV1 = cItemID;
			m_bIsItemDisabled[cItemID] = true;
			PlaySound('E', 29, 0);
			break;

		case 13: // Upgrade Hero System xRisenx
			m_bIsItemDisabled[m_dialogBoxes[34].sV1] = false;
			m_dialogBoxes[34].sV1 = cItemID;
			m_bIsItemDisabled[cItemID] = true;
			PlaySound('E', 29, 0);
			break;
	}
}

void helbreath::bItemDrop_Bank()
{
	m_dialogBoxes[39].sV1 = m_stMCursor.sSelectedObjectID;
	if (m_cCommand < 0) return;
	if (m_pItemList[m_dialogBoxes[39].sV1] == 0) return;
	if (m_bIsItemDisabled[m_dialogBoxes[39].sV1] == true) return;
	if (m_bIsDialogEnabled[17] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if ((m_bIsDialogEnabled[20] == true) && ((m_dialogBoxes[20].GetMode() == 1) || (m_dialogBoxes[20].GetMode() == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_bIsDialogEnabled[23] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (m_bIsDialogEnabled[4] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}
	if (((m_pItemList[m_dialogBoxes[39].sV1]->m_cItemType == ITEMTYPE_CONSUME) || (m_pItemList[m_dialogBoxes[39].sV1]->m_cItemType == ITEMTYPE_ARROW)) && (m_pItemList[m_dialogBoxes[39].sV1]->m_dwCount > 1))
	{
		m_dialogBoxes[17].m_X = m_stMCursor.sX - 140;
		m_dialogBoxes[17].m_Y = m_stMCursor.sY - 70;
		if (m_dialogBoxes[17].m_Y < 0) m_dialogBoxes[17].m_Y = 0;

		m_dialogBoxes[17].sV1 = m_sPlayerX + 1;
		m_dialogBoxes[17].sV2 = m_sPlayerY + 1;
		m_dialogBoxes[17].sV3 = 1002;// NPC
		m_dialogBoxes[17].sV4 = m_dialogBoxes[39].sV1;

		ZeroMemory(m_dialogBoxes[17].cStr, sizeof(m_dialogBoxes[17].cStr));
		EnableDialogBox(17, m_dialogBoxes[39].sV1, m_pItemList[m_dialogBoxes[39].sV1]->m_dwCount, 0);
	}
	else
	{
		if (_iGetBankItemCount() >= MAXBANKITEMS) AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
		else bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxes[39].sV1, 1, m_dialogBoxes[39].sV5, m_dialogBoxes[39].sV6, m_pItemList[m_dialogBoxes[39].sV1]->m_cName, m_dialogBoxes[39].sV4); //v1.4
	}
}

void helbreath::bItemDrop_SkillDialog()
{
	int iConsumeNum;
	char cItemID;

	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;

	if (m_bIsDialogEnabled[17] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_bIsDialogEnabled[20] == true)
		&& ((m_dialogBoxes[20].GetMode() == 1) || (m_dialogBoxes[20].GetMode() == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_bIsDialogEnabled[23] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxes[26].GetMode())
	{
		case 1:
			if (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME)
			{
				iConsumeNum = 0;
				if (m_dialogBoxes[26].sV1 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV2 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV3 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV4 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV5 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV6 == cItemID) iConsumeNum++;
				if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
			}
			if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_EAT) ||
				(m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) ||
				(m_pItemList[cItemID]->m_cItemType == ITEMTYPE_NONE))
			{
			}
			else return;

			if (m_dialogBoxes[26].sV1 == -1)
			{
				m_dialogBoxes[26].sV1 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV2 == -1)
			{
				m_dialogBoxes[26].sV2 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV3 == -1)
			{
				m_dialogBoxes[26].sV3 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV4 == -1)
			{
				m_dialogBoxes[26].sV4 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV5 == -1)
			{
				m_dialogBoxes[26].sV5 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV6 == -1)
			{
				m_dialogBoxes[26].sV6 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			AddEventList(BITEMDROP_SKILLDIALOG4, 10);
			break;

		case 4:
			if (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME)
			{
				iConsumeNum = 0;
				if (m_dialogBoxes[26].sV1 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV2 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV3 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV4 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV5 == cItemID) iConsumeNum++;
				if (m_dialogBoxes[26].sV6 == cItemID) iConsumeNum++;
				if (iConsumeNum >= (int)(m_pItemList[cItemID]->m_dwCount)) return;
			}

			if (m_dialogBoxes[26].sV1 == -1)
			{
				m_dialogBoxes[26].sV1 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV2 == -1)
			{
				m_dialogBoxes[26].sV2 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV3 == -1)
			{
				m_dialogBoxes[26].sV3 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV4 == -1)
			{
				m_dialogBoxes[26].sV4 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV5 == -1)
			{
				m_dialogBoxes[26].sV5 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV6 == -1)
			{
				m_dialogBoxes[26].sV6 = cItemID;
				m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
			break;

			// Crafting
		case 7:
			if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_NONE)			// Merien Stone
				|| (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_EQUIP)		// Necks XXXMagins
				|| (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME)		// stones
				|| (m_pItemList[cItemID]->m_cItemType == ITEMTYPE_MATERIAL)	// XXXwares
				|| m_pItemList[cItemID]->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST)	// gems
			{
			}
			else return;

			if (m_dialogBoxes[26].sV1 == -1)
			{
				m_dialogBoxes[26].sV1 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV2 == -1)
			{
				m_dialogBoxes[26].sV2 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV3 == -1)
			{
				m_dialogBoxes[26].sV3 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV4 == -1)
			{
				m_dialogBoxes[26].sV4 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV5 == -1)
			{
				m_dialogBoxes[26].sV5 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			else if (m_dialogBoxes[26].sV6 == -1)
			{
				m_dialogBoxes[26].sV6 = cItemID;
				if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_CONSUME) && (m_pItemList[cItemID]->m_dwCount > 1))
				{
				}
				else m_bIsItemDisabled[cItemID] = true;
				return;
			}
			AddEventList(BITEMDROP_SKILLDIALOG4, 10); // "There is no more space for ingredients."
			break;

		default:
			break;
	}
}

// Slates Item Drag&Drop - Diuuude
void helbreath::bItemDrop_Slates()
{
	char cItemID;
	if (m_cCommand < 0) return;
	cItemID = (char)m_stMCursor.sSelectedObjectID;
	if (m_pItemList[cItemID] == 0) return;
	if (m_bIsItemDisabled[cItemID] == true) return;
	if (m_bIsDialogEnabled[17] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_bIsDialogEnabled[20] == true) &&
		((m_dialogBoxes[20].GetMode() == 1) || (m_dialogBoxes[20].GetMode() == 2)))
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if (m_bIsDialogEnabled[23] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	switch (m_dialogBoxes[40].GetMode())
	{
		case 1:
			if ((m_pItemList[cItemID]->m_cItemType == ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) && (m_pItemList[cItemID]->m_sSpriteFrame >= 151) && (m_pItemList[cItemID]->m_sSpriteFrame <= 154))
			{
				char cItemIDText[20];
				switch (m_pItemList[cItemID]->m_sSpriteFrame)
				{
					case 151:
						if (m_dialogBoxes[40].sV1 == -1)
						{
							m_bIsItemDisabled[cItemID] = true;
							m_dialogBoxes[40].sV1 = cItemID;
							fmt::format_to(cItemIDText, "Item ID : %d", cItemID);
							AddEventList(cItemIDText, 10);
						}
						break;
					case 152:
						if (m_dialogBoxes[40].sV2 == -1)
						{
							m_bIsItemDisabled[cItemID] = true;
							m_dialogBoxes[40].sV2 = cItemID;
							fmt::format_to(cItemIDText, "Item ID : %d", cItemID);
							AddEventList(cItemIDText, 10);
						}
						break;
					case 153:
						if (m_dialogBoxes[40].sV3 == -1)
						{
							m_bIsItemDisabled[cItemID] = true;
							m_dialogBoxes[40].sV3 = cItemID;
							fmt::format_to(cItemIDText, "Item ID : %d", cItemID);
							AddEventList(cItemIDText, 10);
						}
						break;
					case 154:
						if (m_dialogBoxes[40].sV4 == -1)
						{
							m_bIsItemDisabled[cItemID] = true;
							m_dialogBoxes[40].sV4 = cItemID;
							fmt::format_to(cItemIDText, "Item ID : %d", cItemID);
							AddEventList(cItemIDText, 10);
						}
						break;
				}
			}
			break;

		default:
			break;
	}
}

void helbreath::DlgBoxClick_Bank()
{
	int i;
	char onButton = m_dialogBoxes[14].OnButton();
	switch (m_dialogBoxes[14].GetMode())
	{
		case -1:
			break;

		case 0:
			for (i = 0; i < m_dialogBoxes[14].sV1; i++)
				if (onButton == i + 1)
				{
					if ((m_pBankList[m_dialogBoxes[14].sView + i] != 0) && ((m_dialogBoxes[14].sView + i) < MAXBANKITEMS))
					{
						if (_iGetTotalItemNum() >= 75)
						{ // Bag Fix xRisenx
							AddEventList(DLGBOX_CLICK_BANK1, 10);
							return;
						}
						bSendCommand(MSGID_REQUEST_RETRIEVEITEM, 0, 0, (m_dialogBoxes[14].sView + i), 0, 0, 0);
						m_dialogBoxes[14].SetMode(-1);
						PlaySound('E', 14, 5);
					}
					return;
				}

			break;
	}
}

void helbreath::DlgBoxClick_Fish()
{
	switch (m_dialogBoxes[24].GetMode())
	{
		case 0:
			if (m_dialogBoxes[24].OnButton() == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_GETFISHTHISTIME, 0, 0, 0, 0, 0);
				AddEventList(DLGBOX_CLICK_FISH1, 10);
				DisableDialogBox(24);

				PlaySound('E', 14, 5);
			}
			break;
	}
}

void helbreath::DlgBoxClick_Magic()
{
	int i, j, iCPivot;
	iCPivot = m_dialogBoxes[3].sView * 10;

	char onButton = m_dialogBoxes[3].OnButton();
	for (i = 0, j = 0; i < 9; i++)
	{
		if ((m_cMagicMastery[iCPivot + i] != 0) && (m_pMagicCfgList[iCPivot + i] != 0))
		{
			j++;
			if (onButton == j)
			{
				UseMagic(iCPivot + i);
				PlaySound('E', 14, 5);
				return;
			}
		}
	}

	if (onButton == 10)
		m_dialogBoxes[3].sView = 0;
	if (onButton == 11)
		m_dialogBoxes[3].sView = 1;
	if (onButton == 12)
		m_dialogBoxes[3].sView = 2;
	else if (onButton == 13)
		m_dialogBoxes[3].sView = 3;
	else if (onButton == 14)
		m_dialogBoxes[3].sView = 4;
	else if (onButton == 15)
		m_dialogBoxes[3].sView = 5;
	else if (onButton == 16)
		m_dialogBoxes[3].sView = 6;
	else if (onButton == 17)
		m_dialogBoxes[3].sView = 7;
	else if (onButton == 18)
		m_dialogBoxes[3].sView = 8;
	else if (onButton == 19)
		m_dialogBoxes[3].sView = 9;
	else if (onButton == 20)
	{
		//if (m_cSkillMastery[SKILL_ALCHEMY] == 0) AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY16, 10);
		//else
		//{	
		for (i = 0; i < MAXITEMS; i++)
			if ((m_pItemList[i] != 0) && (m_pItemList[i]->m_cItemType == ITEMTYPE_USE_SKILL_ENABLEDIALOGBOX) &&
				(m_pItemList[i]->m_sSpriteFrame == 55))
			{
				EnableDialogBox(26, 1, 0, 0, 0);
				AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY10, 10);
				PlaySound('E', 14, 5);
				return;
			}
		AddEventList(BDLBBOX_DOUBLE_CLICK_INVENTORY15, 10);
		//}
		PlaySound('E', 14, 5);
	}
}

void helbreath::DlgBoxClick_NpcActionQuery()
{

	int   absX, absY;
	if (m_bIsDialogEnabled[27] == true)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	char onButton = m_dialogBoxes[20].OnButton();
	switch (m_dialogBoxes[20].GetMode())
	{
		case 0: // Talk to npc
			if (onButton == 1)
			{
				EnableDialogBox(m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV2, 0, 0);
				DisableDialogBox(20);
			}
			if ((m_bIsDialogEnabled[21] == false) && onButton == 2)
			{
				switch (m_dialogBoxes[20].sV1)
				{
					case 7:	// Guild
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 1, 0, 0, 0);
						AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);
						break;
					case 11: // BS or Shop
						switch (m_dialogBoxes[20].sV2)
						{
							case 1:
								bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 2, 0, 0, 0);
								AddEventList(TALKING_TO_SHOP_KEEPER, 10);
								break;
							case 2:
								bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 3, 0, 0, 0);
								AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);
								break;
						}
						break;
					case 13: // CityHall officer
						if (m_stQuest.bIsQuestCompleted)
						{
							bSendCommand(MSGID_REQUEST_ACCEPT_QUEST, 0, 0, 0, 0, 0, 0);
						}
						else
						{
							bSendCommand(MSGID_REQUEST_QUEST_LIST, 0, 0, 0, 0, 0, "William");
							EnableDialogBox(61, 0, 0, 0);
						}
						AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);
						break;
					case 14: // WH keeper
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 5, 0, 0, 0);
						AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);
						break;
					case 16: // Magicmerchant
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 6, 0, 0, 0);
						AddEventList(TALKING_TO_MAGICIAN, 10);
						break;
					case 56: //GuildBank
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 10, 0, 0, 0);
						AddEventList(TALKING_TO_GUILDBANK_KEEPER, 10);
						break;
				}
				DisableDialogBox(20);
			}
			break;

		case 1: // On other player
			if (onButton == 1)
			{
				absX = abs(m_dialogBoxes[20].sV5 - m_sPlayerX);
				absY = abs(m_dialogBoxes[20].sV6 - m_sPlayerY);
				if ((absX <= 4) && (absY <= 4))
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV3, m_dialogBoxes[20].sV5, m_dialogBoxes[20].sV6, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4); //v1.4
				else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10); //"Too far to give the item."
				DisableDialogBox(20);
			}
			else if (onButton == 2)
			{
				absX = abs(m_dialogBoxes[20].sV5 - m_sPlayerX);
				absY = abs(m_dialogBoxes[20].sV6 - m_sPlayerY);
				if ((absX <= 4) && (absY <= 4))
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_EXCHANGEITEMTOCHAR, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV3, m_dialogBoxes[20].sV5, m_dialogBoxes[20].sV6, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4); //v1.4
				else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY8, 10); //"Too far to exchange item."
				DisableDialogBox(20);
			}
			break;

		case 2: // Item on Shop/BS
			if (onButton == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_SELLITEM, 0, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV2, m_dialogBoxes[20].sV3, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4);
				DisableDialogBox(20);
			}
			else if (onButton == 2)
			{
				if (m_dialogBoxes[20].sV3 == 1)
				{
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_REPAIRITEM, 0, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV2, 0, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4);
					DisableDialogBox(20);
				}
			}
			break;

		case 3: // Put item in the WH
			if (onButton == 1)
			{
				absX = abs(m_dialogBoxes[20].sV5 - m_sPlayerX);
				absY = abs(m_dialogBoxes[20].sV6 - m_sPlayerY);
				if ((absX <= 8) && (absY <= 8))
				{
					if (_iGetBankItemCount() >= MAXBANKITEMS)
					{
						AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"here is no empty space left in warehouse."
					}
					else bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV3, m_dialogBoxes[20].sV5, m_dialogBoxes[20].sV6, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4); //v1.4
				}
				else AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10);//"Too far to give the item."

				DisableDialogBox(20);
			}
			break;

		case 4: // talk to npc or Unicorn
			if ((m_bIsDialogEnabled[21] == false) && onButton == 1)
			{
				switch (m_dialogBoxes[20].sV3)
				{
					case 21: // Guard
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 21, 0, 0, 0);
						AddEventList(TALKING_TO_GUARD, 10);//"Talking to Guard..."
						break;

					case 32: // Unicorn
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 32, 0, 0, 0);
						AddEventList(TALKING_TO_UNICORN, 10);//"Talking to Unicorn..."
						break;
					case 67:
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 67, 0, 0, 0);
						AddEventList(TALKING_TO_MCGAFFIN, 10);//"Talking to a town man..."
						break;
					case 68:
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 68, 0, 0, 0);
						AddEventList(TALKING_TO_PERRY, 10);//"Talking to a town maiden..."
						break;
					case 69:
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 69, 0, 0, 0);
						AddEventList(TALKING_TO_DEVLIN, 10);//"Talking to a town magician..."
						break;
				}
			}
			DisableDialogBox(20);
			break;


		case 5: // Talk  slit shop
			if (onButton == 1)
			{
				if ((m_dialogBoxes[20].sV2 == 1) && (m_dialogBoxes[20].sV1 == 11))
				{
					EnableDialogBox(52, 0, 0, 0);
					DisableDialogBox(20);
				}
				if ((m_dialogBoxes[20].sV2 == 2) && (m_dialogBoxes[20].sV1 == 11))
				{
					EnableDialogBox(53, 0, 0, 0);
					DisableDialogBox(20);
				}
				if ((m_dialogBoxes[20].sV2 != 2) && (m_dialogBoxes[20].sV2 != 1) && (m_dialogBoxes[20].sV1 != 11))
				{
					EnableDialogBox(m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV2, 0, 0);
					DisableDialogBox(20);
				}
			}
			if (onButton == 2)
			{
				EnableDialogBox(31, 0, 0, 0);
				DisableDialogBox(20);
			}
			if ((m_bIsDialogEnabled[21] == false) && onButton == 3)
			{
				switch (m_dialogBoxes[20].sV1)
				{
					case 7:	// Guild
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 1, 0, 0, 0);
						AddEventList(TALKING_TO_GUILDHALL_OFFICER, 10);//"Talking to Guildhall Officer..."
						break;

					case 11: //
						switch (m_dialogBoxes[20].sV2)
						{
							case 1:
								bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 2, 0, 0, 0);
								AddEventList(TALKING_TO_SHOP_KEEPER, 10);//"Talking to Shop Keeper..."
								break;
							case 2:
								bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 3, 0, 0, 0);
								AddEventList(TALKING_TO_BLACKSMITH_KEEPER, 10);//"
								break;
						}
						break;

					case 13:
						if (m_stQuest.bIsQuestCompleted)
						{
							bSendCommand(MSGID_REQUEST_ACCEPT_QUEST, 0, 0, 0, 0, 0, 0);
						}
						else
						{
							bSendCommand(MSGID_REQUEST_QUEST_LIST, 0, 0, 0, 0, 0, "William");
							EnableDialogBox(61, 0, 0, 0);
							AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);//"
						}
						break;

					case 14: //
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 5, 0, 0, 0);
						AddEventList(TALKING_TO_WAREHOUSE_KEEPER, 10);//
						break;

					case 16: //
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TALKTONPC, 0, 6, 0, 0, 0);
						AddEventList(TALKING_TO_MAGICIAN, 10);//"
						break;
				}
				DisableDialogBox(20);
			}
			break;

		case 6: // Snoopy: Added Gail
			if (onButton == 1)
			{
				EnableDialogBox(51, 0, 0, 0);
				DisableDialogBox(20);
			}
			break;

		case 7: // Jehovah - New Blacksmith Function
			if (onButton == 1) // Buy Weapons
			{
				EnableDialogBox(11, 4, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 2) // Buy (M) Armor
			{
				EnableDialogBox(11, 5, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 3) // Buy (W) Armor
			{
				EnableDialogBox(11, 6, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 4) // Sell items
			{
				EnableDialogBox(31, 0, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 5) // Repair All
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_REPAIRALL, 0, 0, 0, 0, 0);
				DisableDialogBox(20);
			}
			break;

		case 8: // Jehovah - New Shopkeeper Function
			if (onButton == 1) // Buy Potions
			{
				EnableDialogBox(11, 1, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 2) // Buy Misc.
			{
				EnableDialogBox(11, 2, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 3) // Buy Outfits
			{
				EnableDialogBox(11, 3, 0, 0);
				DisableDialogBox(20);
			}
			if (onButton == 4) // Sell items
			{
				EnableDialogBox(31, 0, 0, 0);
				DisableDialogBox(20);
			}
			break;

		case 9: // Jehovah - New Cityhall Officer Function
			if (onButton == 1) // Offer
			{
				EnableDialogBox(13, 0, 0, 0);
				DisableDialogBox(20);
			}
			else if (onButton == 2) // Mailbox
			{
				EnableDialogBox(DIALOG_MAILBOX, 0, 0, 0);
				DisableDialogBox(20);
			}
			//else if (onButton == 3) // Buy Weapons
			//{	
			//	EnableDialogBox(53, 0, NULL, NULL);
			//	DisableDialogBox(20);
			//}
			else if (onButton == 4) // Talk
			{
				if (m_stQuest.bIsQuestCompleted)
				{
					bSendCommand(MSGID_REQUEST_ACCEPT_QUEST, 0, 0, 0, 0, 0, 0);
				}
				else
				{
					bSendCommand(MSGID_REQUEST_QUEST_LIST, 0, 0, 0, 0, 0, "William");
					EnableDialogBox(61, 0, 0, 0);
					AddEventList(TALKING_TO_CITYHALL_OFFICER, 10);//"
				}
			}
			break;

		case 10: // Put item in the GWH
			if (onButton == 1)
			{
				absX = abs(m_dialogBoxes[20].sV5 - m_sPlayerX);
				absY = abs(m_dialogBoxes[20].sV6 - m_sPlayerY);
				if ((absX <= 8) && (absY <= 8))
				{
					if (m_guildBankMap.size() >= maxGWHItems[m_guild.m_upgrades[GU_WAREHOUSE]])
						AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);//"here is no empty space left in warehouse."
					else
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxes[20].sV1, m_dialogBoxes[20].sV3, m_dialogBoxes[20].sV5, m_dialogBoxes[20].sV6, m_pItemList[m_dialogBoxes[20].sV1]->m_cName, m_dialogBoxes[20].sV4); //v1.4
				}
				else
					AddEventList(DLGBOX_CLICK_NPCACTION_QUERY7, 10);//"Too far to give the item."

				DisableDialogBox(20);
			}
			break;

		case 11: // Repair all items from blacksmith
			if (onButton == 1)
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_REPAIRALLCONFIRM, 0, m_dialogBoxes[20].sV2, 0, 0, 0);
				DisableDialogBox(20);
			}
			break;
	}
}


void helbreath::DlgBoxClick_Shop()
{
	int i, maxWeight;
	short sX, sY;
	char cTemp[21];
	bool isArrow = false;

	char onButton = m_dialogBoxes[11].OnButton();
	sX = m_dialogBoxes[11].m_X;
	sY = m_dialogBoxes[11].m_Y;
	maxWeight = m_stat[STAT_STR] * 5 + m_iLevel * 20; // changed from 5 to 20

	switch (m_dialogBoxes[11].GetMode())
	{
		case 0:
			if (onButton)
			{
				i = onButton - 1;
				if (m_pItemForSaleList[m_dialogBoxes[11].sView + i] != 0)
				{
					if (!strcmp(m_pItemForSaleList[m_dialogBoxes[11].sView + i]->m_cName, "10Arrows"))
					{
						if (m_weight >= maxWeight - 1)
						{
							AddEventList(DLGBOX_CLICK_SHOP1, 10);
							return;
						}
					}
					else if (!strcmp(m_pItemForSaleList[m_dialogBoxes[11].sView + i]->m_cName, "100Arrows"))
					{
						if (m_weight >= maxWeight - 10)
						{
							AddEventList(DLGBOX_CLICK_SHOP1, 10);
							return;
						}
					}

					if (_iGetTotalItemNum() >= 75)
					{ // Bag Fix xRisenx
						AddEventList(DLGBOX_CLICK_SHOP1, 10);//" anything because your bag is full."
						return;
					}

					m_dialogBoxes[11].SetMode(m_dialogBoxes[11].sView + i + 1);
					PlaySound('E', 14, 5);
				}
				return;
			}
			break;

		default:

			switch (onButton)
			{
				case 1: m_dialogBoxes[11].sV3 += 10;	break;
				case 2: m_dialogBoxes[11].sV3 -= 10;	break;
				case 3: m_dialogBoxes[11].sV3++;		break;
				case 4: m_dialogBoxes[11].sV3--;		break;
			}

			if (!strcmp(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "100Arrows"))
			{
				isArrow = true;
				if (m_weight + (m_dialogBoxes[11].sV3 * 10) > maxWeight)
				{
					m_dialogBoxes[11].sV3 = (maxWeight - m_weight) / 10;
				}
				if (m_dialogBoxes[11].sV3 > 99) m_dialogBoxes[11].sV3 = 99;
			}
			else if (!strcmp(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "10Arrows"))
			{
				isArrow = true;
				if (m_weight + m_dialogBoxes[11].sV3 > maxWeight)
				{
					m_dialogBoxes[11].sV3 = (maxWeight - m_weight - 1);
				}
				if (m_dialogBoxes[11].sV3 > 99) m_dialogBoxes[11].sV3 = 99;
			}
			else if (m_dialogBoxes[11].sV3 >= (75 - _iGetTotalItemNum()))
			{ // Bag Fix xRisenx
				m_dialogBoxes[11].sV3 = (75 - _iGetTotalItemNum()); // Bag Fix xRisenx
			}
			if (m_dialogBoxes[11].sV3 <= 1)
			{
				m_dialogBoxes[11].sV3 = 1;
			}


			if (onButton == 5)
			{	// Purchase Click
				if (isArrow && _iGetTotalItemNum() >= 75) // Bag Fix xRisenx
				{
					AddEventList(DLGBOX_CLICK_SHOP1, 10);
				}
				else if (!isArrow && ((75 - _iGetTotalItemNum()) < m_dialogBoxes[11].sV3))
				{ // Bag Fix xRisenx
					AddEventList(DLGBOX_CLICK_SHOP1, 10);//"You cannot buy anything because your bag is full."
				}
				else
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					strcpy(cTemp, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName);
					bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_PURCHASEITEM, 0, m_dialogBoxes[11].sV3, 0, 0, cTemp);
				}
				m_dialogBoxes[11].SetMode(0);
				m_dialogBoxes[11].sV3 = 1;
				PlaySound('E', 14, 5);
			}
			else if (onButton == 6)
			{	// Cancel Click
				m_dialogBoxes[11].SetMode(0);
				m_dialogBoxes[11].sV3 = 1;
				PlaySound('E', 14, 5);
			}
			break;
	}
}

void helbreath::DlgBoxClick_Skill()
{
	char onButton = m_dialogBoxes[15].OnButton();
	short skillIndex = (onButton > 17) ? (onButton - 17) : onButton;

	if (m_dialogBoxes[15].GetMode() == 0)
	{
		for (int i = 0, skill = 0; i < MAXSKILLTYPE; i++)
		{
			if (m_pSkillCfgList[i + m_dialogBoxes[15].sView] != 0)
			{ //FIXME
				if (++skill != skillIndex) continue;
				skillIndex = i;
				if (onButton >= 1 && onButton <= 17)
				{
					if (m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_bIsUseable
						&& m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_iLevel != 0)
					{
						if (m_bSkillUsingStatus)
						{
							AddEventList(DLGBOX_CLICK_SKILL1, 10); // "You are already using other skill."
							return;
						}
						if ((m_bCommandAvailable == false) || (m_iHP <= 0))
						{
							AddEventList(DLGBOX_CLICK_SKILL2, 10); // "You can't use a skill while you are moving."
							return;
						}
						if (m_bIsGetPointingMode)
							return;

						switch (m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_cUseMethod)
						{
							case 0:
							case 2:
								bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_USESKILL, 0, (skillIndex + m_dialogBoxes[15].sView), 0, 0, 0);
								m_bSkillUsingStatus = true;
								DisableDialogBox(15);
								PlaySound('E', 14, 5);
								break;
						}
					}
				}
				else if (onButton >= 18 && onButton <= 36)
				{
					if (m_dialogBoxes[15].bFlag == false)
					{
						bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_SETDOWNSKILLINDEX, 0, skillIndex + m_dialogBoxes[15].sView, 0, 0, 0);
						PlaySound('E', 14, 5);
						m_dialogBoxes[15].bFlag = true;

					}
				}
				break;
			}
		}
	}
}

void helbreath::DlgBoxClick_SkillDlg()
{
	int i, iAdjX, iAdjY, buildItem;
	short sX, sY;

	sX = m_dialogBoxes[26].m_X;
	sY = m_dialogBoxes[26].m_Y;

	iAdjX = 5;
	iAdjY = 8;

	char onButton = m_dialogBoxes[26].OnButton();
	switch (m_dialogBoxes[26].GetMode())
	{
		case 1:
			if (onButton)
			{
				m_dialogBoxes[26].SetMode(2);
				m_dialogBoxes[26].cStr[0] = 1;
				m_dialogBoxes[26].dwT1 = m_dwCurTime;
				PlaySound('E', 14, 5);
				AddEventList(DLGBOX_CLICK_SKILLDLG1, 10); // "Mixing a potion..."
				PlaySound('E', 41, 0);
			}
			break;
			// Crafting
		case 7:
			if (onButton)
			{
				DebugLog("Tag1 DlgBoxClick_SkillDlg");
				if (m_dialogBoxes[26].sV1 == -1)
				{
					AddEventList(DLGBOX_CLICK_SKILLDLG2, 10); // "There is not enough crafting materials. Please put in more materials."
					PlaySound('E', 14, 5);
				}
				else
				{
					m_dialogBoxes[26].SetMode(8);
					m_dialogBoxes[26].dwT1 = m_dwCurTime;
					m_dialogBoxes[26].cStr[1] = 1;
					PlaySound('E', 14, 5);
					AddEventList(DLGBOX_CLICK_SKILLDLG3, 10); // "Crafting the item in progress"
					PlaySound('E', 51, 0);
				}
			}
			break;

		case 3:
			i = onButton - 1;
			if (onButton && onButton < 14)
			{
				if (m_pDispBuildItemList[i + m_dialogBoxes[26].sView] != 0)
				{
					m_dialogBoxes[26].SetMode(4);
					m_dialogBoxes[26].cStr[0] = buildItem = i + m_dialogBoxes[26].sView;
					PlaySound('E', 14, 5);
					if (m_manuAutoFill)
					{
						for (i = 0; i < MAXITEMS; i++)
						{
							if (m_pItemList[i] == 0) continue;
							int usedCount = 0;
							if (m_dialogBoxes[26].sV1 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[1] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName1, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV1 = i;
								usedCount++;
								if (m_pItemList[i]->m_dwCount == usedCount) continue;
							}
							if (m_dialogBoxes[26].sV2 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[2] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName2, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV2 = i;
								usedCount++;
								if (m_pItemList[i]->m_dwCount == usedCount) continue;
							}
							if (m_dialogBoxes[26].sV3 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[3] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName3, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV3 = i;
								usedCount++;
								if (m_pItemList[i]->m_dwCount == usedCount) continue;
							}
							if (m_dialogBoxes[26].sV4 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[4] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName4, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV4 = i;
								usedCount++;
								if (m_pItemList[i]->m_dwCount == usedCount) continue;
							}
							if (m_dialogBoxes[26].sV5 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[5] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName5, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV5 = i;
								usedCount++;
								if (m_pItemList[i]->m_dwCount == usedCount) continue;
							}
							if (m_dialogBoxes[26].sV6 == -1 && m_pDispBuildItemList[buildItem]->m_iElementCount[6] &&
								!strcmp(m_pDispBuildItemList[buildItem]->m_cElementName6, m_pItemList[i]->m_cName))
							{
								m_dialogBoxes[26].sV6 = i;
							}
						}
					}
					m_dialogBoxes[26].cStr[4] = (char)_bCheckCurrentBuildItemStatus();
				}
			}
			if (onButton == 16)
			{
				m_manuAutoFill = !m_manuAutoFill;
				PlaySound('E', 14, 5);
			}
			break;

		case 4:
			iAdjX = -1;
			iAdjY = -7;
			if (m_pDispBuildItemList[m_dialogBoxes[26].cStr[0]]->m_bBuildEnabled == true)
			{
				if (onButton == 1)
				{
					// Back
					m_dialogBoxes[26].SetMode(3);
					PlaySound('E', 14, 5);

					if ((m_dialogBoxes[26].sV1 != -1) && (m_pItemList[m_dialogBoxes[26].sV1] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV1] = false;
					if ((m_dialogBoxes[26].sV2 != -1) && (m_pItemList[m_dialogBoxes[26].sV2] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV2] = false;
					if ((m_dialogBoxes[26].sV3 != -1) && (m_pItemList[m_dialogBoxes[26].sV3] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV3] = false;
					if ((m_dialogBoxes[26].sV4 != -1) && (m_pItemList[m_dialogBoxes[26].sV4] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV4] = false;
					if ((m_dialogBoxes[26].sV5 != -1) && (m_pItemList[m_dialogBoxes[26].sV5] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV5] = false;
					if ((m_dialogBoxes[26].sV6 != -1) && (m_pItemList[m_dialogBoxes[26].sV6] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV6] = false;

					m_dialogBoxes[26].sV1 = -1;
					m_dialogBoxes[26].sV2 = -1;
					m_dialogBoxes[26].sV3 = -1;
					m_dialogBoxes[26].sV4 = -1;
					m_dialogBoxes[26].sV5 = -1;
					m_dialogBoxes[26].sV6 = -1;
					m_dialogBoxes[26].cStr[0] = 0;
					m_dialogBoxes[26].cStr[1] = 0;
					m_dialogBoxes[26].cStr[4] = 0;
				}

				//if (onButton == 2)
				//{	// Manufacture
				if (m_dialogBoxes[26].cStr[4] == 1)
				{
					m_dialogBoxes[26].SetMode(5);
					m_dialogBoxes[26].cStr[1] = 0;
					m_dialogBoxes[26].dwT1 = m_dwCurTime;
					PlaySound('E', 14, 5);
					PlaySound('E', 44, 0);
				}
				//}
			}
			else
			{
				if (onButton == 1) 	// Back
				{
					m_dialogBoxes[26].SetMode(3);
					PlaySound('E', 14, 5);

					if ((m_dialogBoxes[26].sV1 != -1) && (m_pItemList[m_dialogBoxes[26].sV1] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV1] = false;
					if ((m_dialogBoxes[26].sV2 != -1) && (m_pItemList[m_dialogBoxes[26].sV2] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV2] = false;
					if ((m_dialogBoxes[26].sV3 != -1) && (m_pItemList[m_dialogBoxes[26].sV3] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV3] = false;
					if ((m_dialogBoxes[26].sV4 != -1) && (m_pItemList[m_dialogBoxes[26].sV4] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV4] = false;
					if ((m_dialogBoxes[26].sV5 != -1) && (m_pItemList[m_dialogBoxes[26].sV5] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV5] = false;
					if ((m_dialogBoxes[26].sV6 != -1) && (m_pItemList[m_dialogBoxes[26].sV6] != 0))
						m_bIsItemDisabled[m_dialogBoxes[26].sV6] = false;

					m_dialogBoxes[26].sV1 = -1;
					m_dialogBoxes[26].sV2 = -1;
					m_dialogBoxes[26].sV3 = -1;
					m_dialogBoxes[26].sV4 = -1;
					m_dialogBoxes[26].sV5 = -1;
					m_dialogBoxes[26].sV6 = -1;
					m_dialogBoxes[26].cStr[0] = 0;
					m_dialogBoxes[26].cStr[1] = 0;
					m_dialogBoxes[26].cStr[4] = 0;
				}
			}
			break;

		case 6:
			iAdjX = -1;
			iAdjY = -7;
			//if (onButton == 1) {
				// Back
			m_dialogBoxes[26].SetMode(3);
			PlaySound('E', 14, 5);

			if ((m_dialogBoxes[26].sV1 != -1) && (m_pItemList[m_dialogBoxes[26].sV1] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV1] = false;
			if ((m_dialogBoxes[26].sV2 != -1) && (m_pItemList[m_dialogBoxes[26].sV2] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV2] = false;
			if ((m_dialogBoxes[26].sV3 != -1) && (m_pItemList[m_dialogBoxes[26].sV3] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV3] = false;
			if ((m_dialogBoxes[26].sV4 != -1) && (m_pItemList[m_dialogBoxes[26].sV4] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV4] = false;
			if ((m_dialogBoxes[26].sV5 != -1) && (m_pItemList[m_dialogBoxes[26].sV5] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV5] = false;
			if ((m_dialogBoxes[26].sV6 != -1) && (m_pItemList[m_dialogBoxes[26].sV6] != 0))
				m_bIsItemDisabled[m_dialogBoxes[26].sV6] = false;

			m_dialogBoxes[26].sV1 = -1;
			m_dialogBoxes[26].sV2 = -1;
			m_dialogBoxes[26].sV3 = -1;
			m_dialogBoxes[26].sV4 = -1;
			m_dialogBoxes[26].sV5 = -1;
			m_dialogBoxes[26].sV6 = -1;
			m_dialogBoxes[26].cStr[0] = 0;
			m_dialogBoxes[26].cStr[1] = 0;
			m_dialogBoxes[26].cStr[4] = 0;
			//}
			break;
	}
}

void helbreath::ReceiveModifyTile(char * pData)
{
	//StreamRead sr(pData,);


}

void helbreath::ResponseTeleportList(char * pData)
{
	char * cp;
	int * ip;

	cp = pData + 6;
	ip = (int *)cp;
	m_iTeleportMapCount = *ip;
	cp += 4;

	for (int i = 0; i < m_iTeleportMapCount; i++)
	{
		ip = (int *)cp;
		m_stTeleportList[i].iIndex = *ip;
		cp += 4;
		ZeroMemory(m_stTeleportList[i].mapname, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, cp, 10);
		cp += 10;
		ip = (int *)cp;
		m_stTeleportList[i].iX = *ip;
		cp += 4;
		ip = (int *)cp;
		m_stTeleportList[i].iY = *ip;
		cp += 4;
		ip = (int *)cp;
		m_stTeleportList[i].iCost = *ip;
		cp += 4;
		m_stTeleportList[i].donateEvent = *cp;
		cp++;
	}
}

void helbreath::ResponseChargedTeleport(char * pData)
{
	short * sp;
	char * cp;
	short sRejectReason = 0;
	cp = (char *)pData + INDEX2_MSGTYPE + 2;
	sp = (short *)cp;
	sRejectReason = *sp;

	switch (sRejectReason)
	{
		case 1:
			AddEventList(RESPONSE_CHARGED_TELEPORT1, 10);
			break;
		case 2:
			AddEventList(RESPONSE_CHARGED_TELEPORT2, 10);
			break;
		case 3:
			AddEventList(RESPONSE_CHARGED_TELEPORT3, 10);
			break;
		case 4:
			AddEventList(RESPONSE_CHARGED_TELEPORT4, 10);
			break;
		case 5:
			AddEventList(RESPONSE_CHARGED_TELEPORT5, 10);
			break;
		case 6:
			AddEventList(RESPONSE_CHARGED_TELEPORT6, 10);
			break;
		case 7:
			AddEventList(RESPONSE_CHARGED_TELEPORT7, 10);
			break;
	}
}

void helbreath::GuildContributeRsp(char * data)
{
	// 	char cTxt[256];
	// 
	// 	uint8_t type;
	// 	Pop(data, type);
	// 	uint32_t amount;
	// 	Pop(data, amount);
	// 
	// 	switch(type)
	// 	{
	// 	case 0: // gold
	// 		fmt::format_to(cTxt, DRAW_DIALOGBOX_GUILDCONTRIBUTE5, amount);
	// 		SetGold( GetGold() - amount );
	// 		break;
	// 	case 1: // maj
	// 		fmt::format_to(cTxt, DRAW_DIALOGBOX_GUILDCONTRIBUTE6, amount);
	// 		m_iGizonItemUpgradeLeft -= amount;
	// 		break;
	// 	case 2: // cont
	// 		fmt::format_to(cTxt, DRAW_DIALOGBOX_GUILDCONTRIBUTE9, amount);
	// 		m_iContribution -= amount;
	// 		break;
	// 	}
	// 
	// 	AddEventList(cTxt, 10);
}

void helbreath::DrawDialogBox_CrusadeJob()
{
	short sX, sY;

	CDialogBox & dlg = m_dialogBoxes[33];
	char onButton = dlg.OnButton();
	sX = dlg.m_X;
	sY = dlg.m_Y;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);

	switch (dlg.GetMode())
	{
		case 1:
			PutAlignedString(sX + 24, sX + 246, sY + 45 + 20, DRAWDIALOGBOX_CRUSADEJOB1);
			PutAlignedString(sX + 24, sX + 246, sY + 60 + 20, DRAWDIALOGBOX_CRUSADEJOB2);
			PutAlignedString(sX + 24, sX + 246, sY + 75 + 20, DRAWDIALOGBOX_CRUSADEJOB3);
			PutAlignedString(sX + 24, sX + 246, sY + 90 + 20, DRAWDIALOGBOX_CRUSADEJOB4);

			if (m_side == ARESDEN || m_side == ELVINE)
			{
				if (m_iGuildRank != GUILDRANK_NONE && gldRankPerm[m_iGuildRank].crusadeCommander)
				{
					//uncomment				ButtonString(dlg, 1, DRAWDIALOGBOX_CRUSADEJOB5);
				}

				//uncomment			ButtonString(dlg, 2, DRAWDIALOGBOX_CRUSADEJOB7);

				if (m_iGuildRank != GUILDRANK_NONE)
				{
					//uncomment				ButtonString(dlg, 3, DRAWDIALOGBOX_CRUSADEJOB9);
				}
			}

			PutAlignedString(sX + 24, sX + 246, sY + 290 - 40, DRAWDIALOGBOX_CRUSADEJOB10);
			PutAlignedString(sX + 24, sX + 246, sY + 305 - 40, DRAWDIALOGBOX_CRUSADEJOB17);

			if (onButton == 4)
				PutString_SprFont(sX + 200, sY + 296, "Help", 6, 6, 20);
			else PutString_SprFont(sX + 200, sY + 296, "Help", 0, 0, 7);
			break;

		case 2:
			PutAlignedString(sX + 24, sX + 246, sY + 90 + 20, DRAWDIALOGBOX_CRUSADEJOB18);
			switch (m_iCrusadeDuty)
			{
				case 1: PutAlignedString(sX + 24, sX + 246, sY + 125, DRAWDIALOGBOX_CRUSADEJOB19); break;//"(Soldier)
				case 2: PutAlignedString(sX + 24, sX + 246, sY + 125, DRAWDIALOGBOX_CRUSADEJOB20); break;//"(Constructor)
				case 3: PutAlignedString(sX + 24, sX + 246, sY + 125, DRAWDIALOGBOX_CRUSADEJOB21); break;//"(Commander)
			}

			PutAlignedString(sX + 24, sX + 246, sY + 145, DRAWDIALOGBOX_CRUSADEJOB22);
			if (onButton == 1)
				PutAlignedString(sX + 24, sX + 246, sY + 160, DRAWDIALOGBOX_CRUSADEJOB23, 255, 255, 255);
			else PutAlignedString(sX + 24, sX + 246, sY + 160, DRAWDIALOGBOX_CRUSADEJOB23, 4, 0, 50);

			PutAlignedString(sX + 24, sX + 246, sY + 175, DRAWDIALOGBOX_CRUSADEJOB25);
			PutAlignedString(sX + 24, sX + 246, sY + 190, DRAWDIALOGBOX_CRUSADEJOB26);

			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;
	}
}

void helbreath::_Draw_OnLogin(char * pAccount, char * pPassword, int msX, int msY, int iFrame)
{
	bool bFlag = true;
	uint64_t dwTime = unixtime();

	//DIRECTX m_DDraw.ClearBackB4();

	DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 0, 0, 0, true);
	DrawVersion();

	//if ((iFrame >= 15) && (iFrame <= 20)) m_pSprite[SPRID_INTERFACE_ND_LOGIN]->PutTransSprite25(39,121, 2, TRUE);
	//else if (iFrame > 20) DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 39,121, 2, TRUE);

	if (m_cCurFocus != 1)
	{
		if (m_Misc.bCheckValidName(pAccount) != false)
			PutString2(330, 269, pAccount, 200, 200, 200);
		else PutString2(330, 269, pAccount, 200, 100, 100);
	}
	if ((m_Misc.bCheckValidName(pAccount) == false) || (strlen(pAccount) == 0)) bFlag = false;

	if (m_cCurFocus != 2)
	{
		if ((m_Misc.bCheckValidString(pPassword) != false))
			PutString(330, 309, pPassword, Color(255, 200, 200, 200), true, 1);
		else PutString(330, 309, pPassword, Color(255, 200, 100, 100), true, 1);
	}
	if ((m_Misc.bCheckValidString(pPassword) == false) || (strlen(pPassword) == 0)) bFlag = false;

	switch (m_cCurFocus)
	{
		case 1:
			ShowReceivedString();
			break;
		case 2:
			ShowReceivedString(true);
			break;

		case 3:
			if (bFlag == true)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 353, 359, 3, true);	// Login Button Rollover
				break;
			}
			break;

		case 4:
			DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 715, 560, 7, true);	// Exit Rollover
			break;

		case 5:
			DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 6, 558, 6, true);	// Create Account Rollover
			break;

		case 6:
			DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 154, 558, 5, true);	// Forums Rollover
			break;

		case 7:
			DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 255, 558, 4, true);	// Website Rollover
			break;
	}

	if (b_cRemember == true)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 322, 337, 2, true);	// Check mark
	}

	if (bFlag == false)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_LOGIN, 353, 359, 8, true); // Display Disabled button
	}

	if ((m_bIsHideLocalCursor != true)/* && (msX != 0) && (msY != 0)*/)
	{
		m_pSprite[SPRID_MOUSECURSOR]->PutSpriteFast(msX, msY, 0, dwTime);
	}
}

void helbreath::ShowEventList(uint64_t dwTime)
{
	int i;

	//DIRECTX m_DDraw._GetBackBufferDC();
	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory[i].dwTime) < 5000)
		{
			switch (m_stEventHistory[i].cColor)
			{
				case 0:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 225, 225, 225), false, 1);
					break;
				case 1:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 130, 255, 130), false, 1);
					break;
				case 2:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 255, 130, 130), false, 1);
					break;
				case 3:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 130, 130, 255), false, 1);
					break;
				case 4:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 230, 230, 130), false, 1);
					break;
				case 10:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 180, 255, 180), false, 1);
					break;
				case 20:
					PutString(10, 10 + i * 15, m_stEventHistory[i].cTxt, Color(255, 150, 150, 170), false, 1);
					break;
					//case 36: // GM Helper chat (Helper chatting in global)
					//	PutString(10, 10 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
					//case 37: // Vip Player chat (Helper chatting in global)
					//	PutString(10, 10 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
					//case 38: // Alpha Tester chat (Helper chatting in global)
					//	PutString(10, 10 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
			}
		}

	for (i = 0; i < 6; i++)
		if ((dwTime - m_stEventHistory2[i].dwTime) < 5000)
		{
			switch (m_stEventHistory2[i].cColor)
			{
				case 0:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 225, 225, 225), false, 1);
					break;
				case 1:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 130, 255, 130), false, 1);
					break;
				case 2:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 255, 130, 130), false, 1);
					break;
				case 3:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 130, 130, 255), false, 1);
					break;
				case 4:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 230, 230, 130), false, 1);
					break;
				case 10:
					PutString(10, 435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 180, 255, 180), false, 1);
					break;
				case 20:
					PutString(10, /*322*/435 + i * 15, m_stEventHistory2[i].cTxt, Color(255, 150, 150, 170), false, 1);
					break;
					//case 36: //besk: GM Helper chat (helper chatting in global)
					//	PutString(10, 435 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
					//case 37: // Vip Player chat (helper chatting in global)
					//	PutString(10, 435 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
					//case 38: //Alpha Tester chat (helper chatting in global)
					//	PutString(10, 435 + i*15, m_stEventHistory[i].cTxt,Color(255,255,153,0), FALSE, 1, TRUE);
					//	break;
			}
		}
	if (m_bSkillUsingStatus == true)
	{
		//PutString(280 -29, 280 -52, SHOW_EVENT_LIST1,Color(255,235,235,235), FALSE, 1, TRUE);
		PutString(350, 330, SHOW_EVENT_LIST1, Color(255, 235, 235, 235), false, 1);
	}
}

void helbreath::RequestTeleportAndWaitData()
{

	bSendCommand(MSGID_REQUEST_TELEPORT);
	ChangeGameMode(GAMEMODE_ONWAITINGINITDATA);
}

void helbreath::InitDataResponseHandler(char * pData)
{
	int * ip, i;
	short * sp, sX, sY;
	char * cp, cMapFileName[32], cTxt[120], cPreCurLocation[12];
	bool  bIsObserverMode;
	HANDLE hFile;
	uint32_t  dwFileSize;

	ZeroMemory(cPreCurLocation, sizeof(cPreCurLocation));
	m_bParalyze = false;

	m_pMapData->Init();

	m_sMonsterID = 0;
	m_dwMonsterEventTime = 0;
#ifdef TitleClient
	m_dwReqTitlesTime = m_dwCurTime + 30000;
#endif
	DisableDialogBox(7);
	DisableDialogBox(11);
	DisableDialogBox(13);
	DisableDialogBox(14);
	DisableDialogBox(16);
	DisableDialogBox(22);
	DisableDialogBox(20);
	DisableDialogBox(21);
	DisableDialogBox(23);
	DisableDialogBox(51); // Gail's diag

	m_bHackMoveBlocked = false; // Anti Hack xRisenx

	m_cCommand = OBJECTSTOP;
	//m_bCommandAvailable = TRUE;
	m_cCommandCount = 0;
	m_bIsGetPointingMode = false;
	m_iPointCommandType = -1;
	m_iIlusionOwnerH = 0;
	m_cIlusionOwnerType = 0;
	m_bIsTeleportRequested = false;
	m_bIsConfusion = false;
	m_bSkillUsingStatus = false;

	m_bItemUsingStatus = false;

	m_cRestartCount = -1;
	m_dwRestartCountTime = 0;

	m_relicX = m_relicY = 0;

	m_armorDisabled = false;
	m_shieldDisabled = false;

	for (i = 0; i < m_stPartyMember.size(); i++)
		m_stPartyMember[i]->sX = m_stPartyMember[i]->sY = 0;

	for (i = 0; i < MAXMAGICTYPE; i++)
		m_magicDisabled[i] = false;

	for (i = 0; i < MAXEFFECTS; i++)
	{
		if (m_pEffectList[i] != 0) delete m_pEffectList[i];
		m_pEffectList[i] = 0;
	}

	for (i = 0; i < MAXWEATHEROBJECTS; i++)
	{
		m_stWeatherObject[i].sX = 0;
		m_stWeatherObject[i].sBX = 0;
		m_stWeatherObject[i].sY = 0;
		m_stWeatherObject[i].cStep = 0;
	}

	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		m_stGuildName[i].dwRefTime = 0;
		m_stGuildName[i].iGuildRank = -1;
		ZeroMemory(m_stGuildName[i].cCharName, sizeof(m_stGuildName[i].cCharName));
		ZeroMemory(m_stGuildName[i].cGuildName, sizeof(m_stGuildName[i].cGuildName));
	}

	for (i = 0; i < MAXCHATMSGS; i++)
	{
		if (m_pChatMsgList[i] != 0) delete m_pChatMsgList[i];
		m_pChatMsgList[i] = 0;
	}

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	// PlayerObjectID
	sp = (short *)cp;
	m_sPlayerObjectID = *sp;
	cp += 2;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerType = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr1 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr2 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr3 = *sp;
	cp += 2;

	sp = (short *)cp;
	m_sPlayerAppr4 = *sp;
	cp += 2;

	ip = (int *)cp;
	m_iPlayerApprColor = *ip;
	cp += 4;

	sp = (short *)cp;
	m_sPlayerHeadApprValue = *sp; // Re-Coding Sprite xRisenx
	cp += 2;

	sp = (short *)cp;
	m_sPlayerBodyApprValue = *sp; // Re-Coding Sprite xRisenx
	cp += 2;

	sp = (short *)cp;
	m_sPlayerArmApprValue = *sp; // Re-Coding Sprite xRisenx
	cp += 2;

	sp = (short *)cp;
	m_sPlayerLegApprValue = *sp; // Re-Coding Sprite xRisenx
	cp += 2;

	// CLEROTH - BLACK FIX <- you mean my fix I made 13 years ago. tyvm
	ip = (int *)cp;
	m_iPlayerStatus = *ip;
	cp += 4;

	ZeroMemory(m_cMapName, sizeof(m_cMapName));
	ZeroMemory(m_cMapMessage, sizeof(m_cMapMessage));
	memcpy(m_cMapName, cp, 10);
	m_cMapIndex = GetOfficialMapName(m_cMapName, m_cMapMessage);
	if (m_cMapIndex < 0)
	{
		m_dialogBoxes[9].sSizeX = -1;
		m_dialogBoxes[9].sSizeY = -1;
	}
	else
	{
		m_dialogBoxes[9].sSizeX = 128;
		m_dialogBoxes[9].sSizeY = 128;
	}
	cp += 10;

	strcpy(cPreCurLocation, m_cCurLocation);
	ZeroMemory(m_cCurLocation, sizeof(m_cCurLocation));
	memcpy(m_cCurLocation, cp, 10);
	cp += 10;

	G_cSpriteAlphaDegree = *cp;
	cp++;

	SetWeatherStatus((Weather)*cp);
	cp++;

	ip = (int *)cp;
	m_iContribution = *ip;
	//	m_iContributionPrice = 0;
	cp += 4;
	bIsObserverMode = (bool)*cp;
	cp++;
	ip = (int *)cp;
	//	m_iRating = *ip;
	cp += 4;
	ip = (int *)cp;
	m_iHP = *ip;
	cp += 4;
	ip = (int *)cp;
	m_iLucky = *ip;
	cp += 4;
	m_cDiscount = (char)*cp;
	cp++;


	ZeroMemory(cMapFileName, sizeof(cMapFileName));
	strcat(cMapFileName, "data\\mapdata\\");
	strcat(cMapFileName, m_cMapName);
	strcat(cMapFileName, ".amd");
	m_pMapData->OpenMapDataFile(cMapFileName);

	m_pMapData->m_sPivotX = sX;
	m_pMapData->m_sPivotY = sY;

	m_sPlayerX = sX + 14 + 5;
	m_sPlayerY = sY + 12 + 5;

	m_cPlayerDir = 5;

	if (bIsObserverMode == false)
	{
		m_pMapData->bSetOwner(m_sPlayerObjectID, m_sPlayerX, m_sPlayerY, m_sPlayerType, m_cPlayerDir,
			m_sPlayerAppr1, m_sPlayerAppr2, m_sPlayerAppr3, m_sPlayerAppr4, m_iPlayerApprColor,
			m_sPlayerHeadApprValue, m_sPlayerBodyApprValue, m_sPlayerArmApprValue, m_sPlayerLegApprValue, // Re-Coding Sprite xRisenx
			m_iPlayerStatus, player_name,
			OBJECTSTOP, 0, 0, 0);
	}

	//m_sViewDstX = m_sViewPointX = (sX+4+5)*32;
	//m_sViewDstY = m_sViewPointY = (sY+5+5)*32;
	m_sViewDstX = m_sViewPointX = (sX + 7) * 32; // 800x600 Resolution xRisenx Center Char xRisenx
	m_sViewDstY = m_sViewPointY = (sY + 8) * 32; // 800x600 Resolution xRisenx Center Char xRisenx
	//_ReadMapData(sX + 4 + 5, sY + 5 + 5, cp);
	_ReadMapData(sX + 7, sY + 8, cp); // 800x600 Resolution xRisenx Center Char xRisenx
	//_ReadMapData(sX + 4 + 5 - 2, sY + 5 + 5 - 2, cp); // Maybe this insted ? xRisenx
	m_bIsRedrawPDBGS = true;
	// ------------------------------------------------------------------------+
	fmt::format_to(cTxt, INITDATA_RESPONSE_HANDLER1, m_cMapMessage);
	AddEventList(cTxt, 10);

	/*if (  ( memcmp( m_cCurLocation, "middleland"	,10 ) == 0 )
		|| ( memcmp( m_cCurLocation, "dglv2"		, 5 ) == 0 )
		|| ( memcmp( m_cCurLocation, "middled1n"	, 9 ) == 0 ))
		EnableDialogBox(6, NULL,NULL, NULL);*/

		// Snoopy: removed for v351 compatibility. Maybe usefull later...
		/*	BOOL bPrevSafe, bNowSafe;
			if( memcmp( cPreCurLocation, m_cLocation, 3 ) == 0 )
				bPrevSafe = TRUE;
			else bPrevSafe = FALSE;

			if( memcmp( m_cCurLocation, m_cLocation, 3 ) == 0 )
				bNowSafe = TRUE;
			else bNowSafe = FALSE;

			if( memcmp( m_cCurLocation, "2nd", 3 ) == 0 ) bNowSafe = TRUE;
			if( m_iPKCount != 0 ) bNowSafe = FALSE;

			if( bPrevSafe )
			{	if( bNowSafe == FALSE ) SetTopMsg(MSG_DANGERZONE, 5);
			}else
			{	if( bNowSafe ) SetTopMsg(MSG_SAFEZONE, 5);
			}*/

			// ------------------------------------------------------------------------+

	ChangeGameMode(GAMEMODE_ONMAINGAME);
	//DIRECTX m_DDraw.ClearBackB4();

	//v1.41
	if ((m_sPlayerAppr2 & 0xF000) != 0)
		m_bIsCombatMode = true;
	else m_bIsCombatMode = false;

	//v1.42
	//if (m_bIsFirstConn == TRUE)
	//{	m_bIsFirstConn = FALSE;
	//	/*hFile = CreateFileA("contents\\contents1000.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	//	hFile = CreateFileA("contents\\contents1000.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);*/
	//	if (hFile == INVALID_HANDLE_VALUE)
	//		dwFileSize = 0;
	//	else
	//	{	dwFileSize = GetFileSize(hFile, NULL);
	//		CloseHandle(hFile);
	//	}
	//	bSendCommand(MSGID_REQUEST_NOTICEMENT, NULL, NULL, (int)dwFileSize, NULL, NULL, NULL);
	//}
	//cp += 2;

#ifdef TitleClient
	bSendCommand(MSGID_REQUEST_TITLES, 0, 0, 0, 0, 0, 0);
	m_cCommandCount--;
	m_dwReqTitlesTime = m_dwCurTime;
#endif
	// Gladiator Arena xRisenx
	// clear list if relog or log new char
	/*for (i = 0; i < MAXARENAPLAYERS; i++)
	{
	   m_stArenaPlayers[i].iKills = 0;
	   m_stArenaPlayers[i].iDeaths = 0;
	   ZeroMemory(m_stArenaPlayers[i].cCharName, sizeof(m_stArenaPlayers[i].cCharName));
	}*/
	// Gladiator Arena xRisenx
}

void helbreath::MotionEventHandler(char * pData)
{
	uint16_t * wp, wObjectID;
	uint16_t * sp, sX, sY, sType, sAppr1, sAppr2, sAppr3, sAppr4, sSprite, sSpriteFrame, sV1, sV2, sV3, sPrevAppr2, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue; // Re-Coding Sprite xRisenx
	UnitStatus status;
	Msgid eventType;
	uint8_t cDir, iLoc;
	char * cp, cName[12];
	int * ip, iApprColor;
	char    cTxt[300];
	int i;
	/*#ifdef RaiseCriticalLimit
	int iDamage = 0;
	#endif*/

	/*#ifdef RemoveCritical
	DWORD * dwp, dwDamage;
	#endif*/

	ZeroMemory(cName, sizeof(cName));
	sV1 = sV2 = sV3 =
		/*#ifdef RemoveCritical
		dwDamage =
		#endif*/
		0;

	cp = pData;
	Pop(cp, eventType);
	Pop(cp, wObjectID);

	iLoc = 0;
	if (wObjectID < 30000)
	{
		if (wObjectID < 10000) 	// Player
		{
			Pop(cp, sX);
			Pop(cp, sY);
			Pop(cp, sType);
			Pop(cp, cDir);
			Pop(cp, cName, 10);
			Pop(cp, sAppr1);
			Pop(cp, sAppr2);
			Pop(cp, sAppr3);
			Pop(cp, sAppr4);
			Pop(cp, (uint32_t &)iApprColor);
			Pop(cp, sHeadApprValue); // Re-Coding Sprite xRisenx
			Pop(cp, sBodyApprValue); // Re-Coding Sprite xRisenx
			Pop(cp, sArmApprValue); // Re-Coding Sprite xRisenx
			Pop(cp, sLegApprValue); // Re-Coding Sprite xRisenx
			Pop(cp, status);
			Pop(cp, iLoc);
		}
		else 	// Npc or mob
		{
			fmt::format_to(cName, "npc%d", wObjectID - 10000);
			Pop(cp, sX);
			Pop(cp, sY);
			Pop(cp, sType);
			Pop(cp, cDir);

			sAppr1 = sAppr3 = sAppr4 = sHeadApprValue = sBodyApprValue = sArmApprValue = sLegApprValue = 0; // Re-Coding Sprite xRisenx
			Pop(cp, sAppr2);
			Pop(cp, status);
			Pop(cp, iLoc);
		}
	}
	else
	{
		switch (eventType)
		{
			case MSGID_MOTION_MAGIC:
#ifdef RaiseCriticalLimit
				Pop(cp, cDir);
				Pop(cp, (uint8_t &)sV1);
				Pop(cp, (uint8_t &)sV2);
				break;
#endif
			case MSGID_MOTION_DAMAGEMOVE:
			case MSGID_MOTION_DAMAGE:
				Pop(cp, cDir);
#ifdef RemoveCriticalClient
				Pop(cp, (uint16_t &)sV1);
#else
				Pop(cp, (uint8_t &)sV1);
#endif
				Pop(cp, (uint8_t &)sV2);
				break;

			case MSGID_MOTION_DYING:
				Pop(cp, cDir);
#ifdef RemoveCriticalClient
				Pop(cp, (uint16_t &)sV1);
#else
				Pop(cp, (uint8_t &)sV1);
#endif
				Pop(cp, (uint8_t &)sV2);
				Pop(cp, sX);
				Pop(cp, sY);
				break;

			case MSGID_MOTION_ATTACK:
				Pop(cp, cDir);
#ifdef RemoveCriticalClient
				Pop(cp, (uint16_t &)sV1);
#else
				Pop(cp, (uint8_t &)sV1);
#endif
				Pop(cp, (uint8_t &)sV2);
				Pop(cp, sV3);
				break;

			default:
				Pop(cp, cDir);
				break;

		}
	}

	if (eventType == MSGID_MOTION_EVENT_CONFIRM)
	{
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4, iApprColor,
			sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, status, cName, OBJECTSTOP, 0, 0, 0); // Re-Coding Sprite xRisenx
		switch (sType)
		{
			case 43: // LWB
			case 44: // GHK
			case 45: // GHKABS
			case 46: // TK
			case 47: // BG
				bAddNewEffect(64, (sX) * 32, (sY) * 32, 0, 0, 0);
				break;
		}

		_RemoveChatMsgListByObjectID(wObjectID);

		return;
	}
	else if (eventType == MSGID_MOTION_EVENT_REJECT)
	{
		m_pMapData->bSetOwner(wObjectID, -1, -1, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4,
			iApprColor, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, status, cName, OBJECTSTOP, 0, 0, 0); // Re-Coding Sprite xRisenx

		_RemoveChatMsgListByObjectID(wObjectID);

		return;
	}


	if (eventType == MSGID_MOTION_NULL && cName == player_name)
	{
		m_sPlayerType = sType;
		m_sPlayerAppr1 = sAppr1;
		sPrevAppr2 = m_sPlayerAppr2;
		m_sPlayerAppr2 = sAppr2;
		m_sPlayerAppr3 = sAppr3;
		m_sPlayerAppr4 = sAppr4;
		m_iPlayerApprColor = iApprColor;
		m_sPlayerHeadApprValue = sHeadApprValue; // Re-Coding Sprite xRisenx
		m_sPlayerBodyApprValue = sBodyApprValue; // Re-Coding Sprite xRisenx
		m_sPlayerArmApprValue = sArmApprValue; // Re-Coding Sprite xRisenx
		m_sPlayerLegApprValue = sLegApprValue; // Re-Coding Sprite xRisenx
		m_iPlayerStatus = status;
		if ((sPrevAppr2 & 0xF000) == 0)
		{
			if ((sAppr2 & 0xF000) != 0)
			{
				AddEventList(MOTION_EVENT_HANDLER1, 10);
				m_bIsCombatMode = true;
			}
		}
		else
		{
			if ((sAppr2 & 0xF000) == 0)
			{
				AddEventList(MOTION_EVENT_HANDLER2, 10);
				m_bIsCombatMode = false;
			}
		}

		if (m_cCommand != OBJECTRUN && m_cCommand != OBJECTMAGIC)
		{
			m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4,
				iApprColor, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, status, cName, GET_MOTION_ACTIONID(eventType), sV1, sV2, sV3, iLoc); // Re-Coding Sprite xRisenx
		}
	}
	else if (!(wObjectID - 30000 == m_sPlayerObjectID &&
		eventType == MSGID_MOTION_DYING && (m_cCommand == OBJECTRUN || m_cCommand == OBJECTMOVE)))
	{
		m_pMapData->bSetOwner(wObjectID, sX, sY, sType, cDir, sAppr1, sAppr2, sAppr3, sAppr4,
			iApprColor, sHeadApprValue, sBodyApprValue, sArmApprValue, sLegApprValue, status, cName, GET_MOTION_ACTIONID(eventType), sV1, sV2, sV3, iLoc); // Re-Coding Sprite xRisenx
	}

	switch (eventType)
	{
		case MSGID_MOTION_MAGIC: // Casting
			_RemoveChatMsgListByObjectID(wObjectID - 30000);
			// 		if (abs(sX - m_sPlayerX > 12) || abs(sX + m_sPlayerX) > 12 || abs(sY - m_sPlayerY) > 9 || abs(sY + m_sPlayerY) > 9)
			// 		return;
			for (i = 1; i < MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
#ifdef RemoveCritical
					if (m_pMagicCfgList[dwDamage] != 0)
						fmt::format_to(cTxt, "%s!", m_pMagicCfgList[dwDamage]->m_cName);
#else
					fmt::format_to(cTxt, "%s!", m_pMagicCfgList[sV1]->m_cName);
#endif
					m_pChatMsgList[i] = new class CMsg(41, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
					if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == false)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					return;
				}
			break;

		case MSGID_MOTION_DYING:
			/*#ifdef RaiseCriticalLimit
			for (i = 1; i < MAXCHATMSGS; i++)
			if (m_pChatMsgList[i] == NULL)
			{    ZeroMemory(cTxt, sizeof(cTxt));
				fmt::format_to(cTxt, "-%dPts!", iDamage);
				int iFontType;
				if ((iDamage >= 0) && (iDamage < 12))        iFontType = 21;
				else if ((iDamage >= 12) && (iDamage < 40)) iFontType = 22;
				else if ((iDamage >= 40) || (iDamage < 0))    iFontType = 23;
				m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
				if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
				{    delete m_pChatMsgList[i];
					m_pChatMsgList[i] = NULL;
				}
				return;*/
				//#else
				//#ifdef RemoveCritical
				//_RemoveChatMsgListByObjectID(wObjectID - 30000);
				//for (i = 1; i < MAXCHATMSGS; i++)
				//if (m_pChatMsgList[i] == NULL)
				//{	ZeroMemory(cTxt, sizeof(cTxt));
				//	if (dwDamage > 0)
				//		fmt::format_to(cTxt, "-%dPts!", dwDamage); //pts
				//	else strcpy(cTxt, "Critical!");
				//	int iFontType;
				//	if ((dwDamage >= 0) && (dwDamage < 500))		iFontType = 21;
				//	else if ((dwDamage >= 500) && (dwDamage < 1250)) iFontType = 22;
				//	else if ((dwDamage >= 1250) || (dwDamage < 0))	iFontType = 23;
				//	m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
				//	m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
				//	if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
				//	{	delete m_pChatMsgList[i];
				//		m_pChatMsgList[i] = NULL;
				//	}
				//	return;
				//#else
		// 		if (abs(sX - m_sPlayerX > 12) || abs(sX + m_sPlayerX) > 12 || abs(sY - m_sPlayerY) > 9 || abs(sY + m_sPlayerY) > 9)
		// 		return;
				//do it here to save on processing
			for (i = 1; i < MAXCHATMSGS; i++)
			{
				if (m_pChatMsgList[i] == 0)
				{
					int index = m_pMapData->getChatMsgIndex(wObjectID - 30000);
					if (m_showAllDmg && m_pChatMsgList[index] && strlen(m_pChatMsgList[index]->m_pMsg) < sizeof(cTxt) - 30)
					{
						if (index != -1 && m_dwCurTime - m_pChatMsgList[index]->m_dwTime < 150 &&
							m_pChatMsgList[index]->m_cType >= 21 && m_pChatMsgList[index]->m_cType <= 23)
						{
							if (sV1 > 0)
								fmt::format_to(cTxt, "%s-%d!", m_pChatMsgList[index]->m_pMsg, sV1);
							else
								fmt::format_to(cTxt, "%s-Crit!", m_pChatMsgList[index]->m_pMsg, sV1);
						}
						else
						{
							if (sV1 > 0)
								fmt::format_to(cTxt, "-%d!", sV1);
							else strcpy(cTxt, "Crit!");
						}
					}
					else
					{
						if (sV1 > 0)
							fmt::format_to(cTxt, "-%d!", sV1);
						else strcpy(cTxt, COMMAND_PROCESSOR6);
					}
					int iFontType;
					if ((sV1 >= 0) && (sV1 < 500))		iFontType = 21;
					else if ((sV1 >= 500) && (sV1 < 1250)) iFontType = 22;
					else if ((sV1 >= 1250) || (sV1 < 0))	iFontType = 23;
					_RemoveChatMsgListByObjectID(wObjectID - 30000);
					m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
					if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == false)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}


					return;
				}
				//#endif
			}
			break;

		case MSGID_MOTION_DAMAGEMOVE:
		case MSGID_MOTION_DAMAGE:
			if (cName == player_name)
			{
				m_bIsGetPointingMode = false;
				m_iPointCommandType = -1;
				m_stMCursor.sCursorFrame = 0;
				ClearSkillUsingStatus();
			}
			//#ifdef RemoveCritical
			//for (i = 1; i < MAXCHATMSGS; i++)
			//if (m_pChatMsgList[i] == NULL)
			//{	ZeroMemory(cTxt, sizeof(cTxt));
			//	if (dwDamage != 0)
			//	{	
			//		if (dwDamage >= 99999)
			//			fmt::format_to(cTxt, "-%dPts", dwDamage-99999); //pts
			//		else if (dwDamage == 50000)
			//			fmt::format_to(cTxt, "Broken!"); //pts
			//		else if (dwDamage > 0)
			//			fmt::format_to(cTxt, "-%dPts", dwDamage); //pts
			//		else strcpy(cTxt, "Critical!");//
			//		int iFontType;
			//		if ((dwDamage >= 0) && (dwDamage < 500))		iFontType = 21;
			//		else if ((dwDamage >= 500) && (dwDamage < 1250)) iFontType = 22;
			//		else if ((dwDamage >= 99999) || (dwDamage == 50000)) iFontType = 25;
			//		else if ((dwDamage >= 1250) || (dwDamage < 0))	iFontType = 23;

			//		m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
			//	}else
			//	{	strcpy(cTxt, " * Failed! *");
			//		m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
			//		PlaySound('C', 17, 0);
			//	}
			//	m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
			//	if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == FALSE)
			//	{	delete m_pChatMsgList[i];
			//		m_pChatMsgList[i] = NULL;
			//	}
			//	return;
			//#else
	// 		if (abs(sX - m_sPlayerX) > 12 || abs(sX + m_sPlayerX) > 12 || abs(sY - m_sPlayerY) > 9 || abs(sY + m_sPlayerY) > 9)
	// 		return;
			for (i = 1; i < MAXCHATMSGS; i++)
				if (m_pChatMsgList[i] == 0)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					if (sV1 != 0)
					{
						int index = m_pMapData->getChatMsgIndex(wObjectID - 30000);
						if (index != -1 && m_showAllDmg && m_pChatMsgList[index] && strlen(m_pChatMsgList[index]->m_pMsg) < sizeof(cTxt) - 30)
						{
							if (index != -1 && m_dwCurTime - m_pChatMsgList[index]->m_dwTime < 150 &&
								m_pChatMsgList[index]->m_cType >= 21 && m_pChatMsgList[index]->m_cType <= 23)
							{
								if (sV1 > 0)
									fmt::format_to(cTxt, "%s-%d", m_pChatMsgList[index]->m_pMsg, sV1);
								else
									fmt::format_to(cTxt, "%s-Crit", m_pChatMsgList[index]->m_pMsg, sV1);
							}
							else
							{
								if (sV1 > 0)
									fmt::format_to(cTxt, "-%d", sV1);
								else strcpy(cTxt, "Crit");
							}
						}
						else
						{
							if (sV1 > 0)
								fmt::format_to(cTxt, "-%d", sV1);
							else strcpy(cTxt, COMMAND_PROCESSOR6);
						}

						int iFontType;
						if ((sV1 >= 0) && (sV1 < 500))		iFontType = 21;
						else if ((sV1 >= 500) && (sV1 < 1250)) iFontType = 22;
						else if ((sV1 >= 1250) || (sV1 < 0))	iFontType = 23;

						_RemoveChatMsgListByObjectID(wObjectID - 30000);
						m_pChatMsgList[i] = new class CMsg(iFontType, cTxt, m_dwCurTime);
					}
					else
					{
						strcpy(cTxt, " * Failed! *");
						_RemoveChatMsgListByObjectID(wObjectID - 30000);
						m_pChatMsgList[i] = new class CMsg(22, cTxt, m_dwCurTime);
						PlaySound('C', 17, 0);
					}
					m_pChatMsgList[i]->m_iObjectID = wObjectID - 30000;
					if (m_pMapData->bSetChatMsgOwner(wObjectID - 30000, -10, -10, i) == false)
					{
						delete m_pChatMsgList[i];
						m_pChatMsgList[i] = 0;
					}
					return;
					//#endif
				}
			break;
	}
}


void helbreath::DrawDialogBox_Commander()
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint64_t dwTime = G_dwGlobalTime;
	double dV1, dV2, dV3;
	int i, tX, tY;

	char onButton = m_dialogBoxes[36].OnButton();
	sX = m_dialogBoxes[36].m_X;
	sY = m_dialogBoxes[36].m_Y;
	szX = m_dialogBoxes[36].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("2ndmiddle", 3);
		_RequestMapStatus("2ndmiddle", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans); // Main image
	DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX + 1, sY, 15, false, m_bDialogTrans);

	switch (m_dialogBoxes[36].GetMode())
	{
		case 0: // Main dlg
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 3, dwTime); // btn
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime); // btn
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 340, 2, dwTime); // btn
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 340, 30, dwTime); // Btn TP
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime); // btn ?
			//PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"
			PutAlignedString(sX, sX + szX, sY + 37, DRAW_DIALOGBOX_COMMANDER1);//"Middleland warfare building structure situation"

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 17, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER2, 255, 255, 255);//"Middleland teleport position set"
			}
			else if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER3, 255, 255, 255);//"Teleport to the selected area"
			}
			else if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 340, 16, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER4, 255, 255, 255);//"Recall warfare units"
			}
			else if (onButton == 4)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 340, 24, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER5, 255, 255, 255);//"Middleland construction building set"
			}
			else if (onButton == 5)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER6, 255, 255, 255);//"Commander's duty help"
			}
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);// Map
			break;

		case 1: // Set TP
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime); //btn <-
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);  //btn ?
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER7); // "Click and select the teleport location."

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER8, 255, 255, 255);
			}
			else if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER9, 255, 255, 255);
			}
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);

			if (onButton == 1) // shows TP posit on map following the mouse
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, m_stMCursor.sX, m_stMCursor.sY, 42, false, true);
			}
			break;

		case 2: // Use TP
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);       // Btn TP
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime); // Btn <-
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);  // Btn ?
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER10); // "Teleport to the selected area"

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER11, 255, 255, 255);
			}
			else if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER12, 255, 255, 255);
			}
			else if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER13, 255, 255, 255);
			}
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);
			break;

		case 3: // Choose summon
			if (m_side == ARESDEN)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 6, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 5, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 7, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 35, dwTime);
			}
			else if (m_side == ELVINE)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 9, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 8, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 7, dwTime);
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 35, dwTime);
			}
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER14); // "Recall warfare units"

			fmt::format_to(G_cTxt, "%s %d", DRAW_DIALOGBOX_COMMANDER15, m_iConstructionPoint);
			PutAlignedString(sX, sX + 323, sY + 190, G_cTxt);

			if (m_side == ARESDEN)
			{
				if (onButton == 1)
				{
					if (m_iConstructionPoint >= 3000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 11, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER16, 255, 255, 255);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER17, 255, 255, 255);//"3000"
				}
				else if (onButton == 2)
				{
					if (m_iConstructionPoint >= 2000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 10, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER18, 255, 255, 255);//"(Temple Knight)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER19, 255, 255, 255);//"2000"
				}
				else if (onButton == 3)
				{
					if (m_iConstructionPoint >= 1000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 12, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER20, 255, 255, 255);//"(Light War Beetle)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER21, 255, 255, 255);//" 1000"
				}
				else if (onButton == 4)
				{
					if (m_iConstructionPoint >= 5000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 29, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER22, 255, 255, 255);//"(Catapult)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER23, 255, 255, 255);// 1500"
				}
				else if (onButton == 5)
				{
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER24, 255, 255, 255);
				}
				else if (onButton == 6)
				{
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER25, 255, 255, 255);
				}
				else if (onButton == 7)
				{
					m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER26, 255, 255, 255);
				}
				else if (onButton == 8)
				{
					m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER27, 255, 255, 255); //"Warfare units recall related help"
				}
			}
			else if (m_side == ELVINE)
			{
				if (onButton == 1)
				{
					if (m_iConstructionPoint >= 3000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 14, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER28, 255, 255, 255);//"(God's Hand Knight Cavalry)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER29, 255, 255, 255);//"3000"
				}
				else if (onButton == 2)
				{
					if (m_iConstructionPoint >= 2000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 13, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER30, 255, 255, 255);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER31, 255, 255, 255);//"2000"
				}
				else if (onButton == 3)
				{
					if (m_iConstructionPoint >= 1000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 12, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER32, 255, 255, 255);//"(Light War Beetle)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER33, 255, 255, 255);//" 1000"
				}
				else if (onButton == 4)
				{
					if (m_iConstructionPoint >= 5000)
					{
						m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 29, dwTime);
					}
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER34, 255, 255, 255);//"(Catapult)"
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 50, DRAW_DIALOGBOX_COMMANDER35, 255, 255, 255);//" 1500"
				}
				else if (onButton == 5)
				{
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER36, 255, 255, 255);
				}
				else if (onButton == 6)
				{
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER37, 255, 255, 255);
				}
				else if (onButton == 7)
				{
					m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER38, 255, 255, 255);

				}
				else if (onButton == 8)
				{
					m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
					PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER39, 255, 255, 255);
				}
			}
			PutAlignedString(sX, sX + 323, sY + 80, DRAW_DIALOGBOX_COMMANDER40);
			PutAlignedString(sX, sX + 323, sY + 95, DRAW_DIALOGBOX_COMMANDER41);
			PutAlignedString(sX, sX + 323, sY + 110, DRAW_DIALOGBOX_COMMANDER42);

			switch (m_dialogBoxes[36].sV1)
			{
				case 0:
					PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_COMMANDER43, 255, 255, 255);//"Guard Mode"
					PutAlignedString(sX, sX + 323, sY + 160, DRAW_DIALOGBOX_COMMANDER44, 4, 0, 50);//"Hold Mode"
					break;
				case 1:
					PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_COMMANDER43, 4, 0, 50);//"Guard Mode"
					PutAlignedString(sX, sX + 323, sY + 160, DRAW_DIALOGBOX_COMMANDER44, 255, 255, 255);//"Hold Mode"
					break;
			}
			break;

		case 4: // Set Construction point
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);
			m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_COMMANDER47); // "Select the construction area and click."

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER48, 255, 255, 255); // "Returns to commander's main menu"
			}
			else if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_COMMANDER49, 255, 255, 255); // "Construction area set related help"
			}
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21);
			if ((m_stMCursor.sX >= sX + 15) && (m_stMCursor.sX <= sX + 15 + 278)
				&& (m_stMCursor.sY >= sY + 60) && (m_stMCursor.sY <= sY + 60 + 272)) // shows posit on map following the mouse
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, m_stMCursor.sX, m_stMCursor.sY, 41, false, true);
			}
			break;
	}

	switch (m_dialogBoxes[36].GetMode())
	{
		case 0: // Main
		case 1: // Set TP
		case 2: // Use TP
		case 4: // Set construc
			szX = 0;
			szY = 0;
			MapSzX = 0;
			MapSzY = 0;
			if (strcmp(m_cStatusMapName, "aresden") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "elvine") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "middleland") == 0)
			{
				szX = 279;
				szY = 280;	  // Fix for ML
				MapSzX = 524; // Fix for ML
				MapSzY = 524; // Fix for ML
			}
			else if (strcmp(m_cStatusMapName, "2ndmiddle") == 0)
			{
				szX = 125; // 279 -> 125
				szY = 125; // 280 -> 125
				MapSzX = 250; // 524 -> 250
				MapSzY = 250; // 524 -> 250
			}
			if (szX != 0)
			{
				for (i = 0; i < MAXCRUSADESTRUCTURES; i++)
					if (m_stCrusadeStructureInfo[i].cType != 0)
					{
						dV1 = (double)MapSzX;
						dV2 = (double)m_stCrusadeStructureInfo[i].sX;
						dV3 = (dV2 * (double)szX) / dV1;
						tX = (int)dV3;
						dV1 = (double)MapSzY;
						dV2 = (double)m_stCrusadeStructureInfo[i].sY;
						dV3 = (dV2 * (double)szY) / dV1;
						tY = (int)dV3;
						switch (m_stCrusadeStructureInfo[i].cType)
						{
							case 38:
								if (m_stCrusadeStructureInfo[i].cSide == 1)
									DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 39, false, true); // Base
								else DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 37, false, true);
								break;
							case 36:
							case 37:
							case 39:
								if (m_stCrusadeStructureInfo[i].cSide == 1)
									DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 38, false, true); // Base
								else DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 36, false, true);
								break;
							case 42:
								DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
								break;
						}
					}
				if (m_iTeleportLocX != -1)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_iTeleportLocX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_iTeleportLocY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					if ((m_dialogBoxes[36].GetMode() == 1) && (tY >= 30) && (tY <= 494)) // Place the TP
					{
						DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
					}
					else
						DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
				}
				if ((m_dialogBoxes[36].GetMode() != 2) && (m_iConstructLocX != -1))
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_iConstructLocX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_iConstructLocY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 41, false, true); // Contr pt
				}
				if (strcmp(m_cMapName, "2ndmiddle") == 0)
				{
					dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
					dV2 = (double)m_sPlayerX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
					dV2 = (double)m_sPlayerY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
				}
			}
			if (m_dialogBoxes[36].GetMode() != 3)
			{
				if ((m_stMCursor.sX >= sX + 15) && (m_stMCursor.sX <= sX + 15 + (MapSzX)) // 278 -> (MapSzX-30)
					&& (m_stMCursor.sY >= sY + 60) && (m_stMCursor.sY <= sY + 60 + (MapSzY))) // 272 -> (MapSzY-30) Draw mouse coordinates
				{
					dV1 = (double)(m_stMCursor.sX - (sX + 15));
					dV2 = (double)MapSzX;//(752.0f);
					dV3 = (dV2 * dV1) / szX;//280.0f;
					tX = (int)dV3;
					dV1 = (double)(m_stMCursor.sY - (sY + 60));
					dV2 = (double)MapSzX;//(680.0f);
					dV3 = (dV2 * dV1) / szY;//253.0f;
					tY = (int)dV3;
					if (tX < 30) tX = 30;
					if (tY < 30) tY = 30;
					if (tX > MapSzX - 30) tX = MapSzX - 30;
					if (tY > MapSzY - 30) tY = MapSzY - 30;
					fmt::format_to(G_cTxt, "%d,%d", tX, tY);
					PutString_SprFont3(m_stMCursor.sX + 10, m_stMCursor.sY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
				}
			}
			break;
	}
}

void helbreath::DrawDialogBox_Constructor()
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint64_t dwTime = G_dwGlobalTime;
	double dV1, dV2, dV3;
	int tX, tY;
	char cMapName[12];

	char onButton = m_dialogBoxes[37].OnButton();
	sX = m_dialogBoxes[37].m_X;
	sY = m_dialogBoxes[37].m_Y;
	szX = m_dialogBoxes[37].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("2ndmiddle", 3);
		_RequestMapStatus("2ndmiddle", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans); // Main image
	DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 16, false, m_bDialogTrans);

	switch (m_dialogBoxes[37].GetMode())
	{
		case 0: // Main dlg
			if (m_iConstructLocX != -1)
			{
				ZeroMemory(cMapName, sizeof(cMapName));
				GetOfficialMapName(m_cConstructMapName, cMapName);
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_CONSTRUCTOR1, cMapName, m_iConstructLocX, m_iConstructLocY);
				PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);
			}
			else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR2); //"Construction unavailable: Unable to construct"
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans); // Map

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 24, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 30, dwTime);

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);

			if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

			if (onButton == 1)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR3, 255, 255, 255);
			}
			else if (onButton == 2)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR4, 255, 255, 255);
			}
			else if (onButton == 3)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR5, 255, 255, 255);
			}
			break;

		case 1: // Select building
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR6); //"Select war building"
			PutAlignedString(sX, sX + 323, sY + 80, DRAW_DIALOGBOX_CONSTRUCTOR7); //"Constructs the war building here."
			PutAlignedString(sX, sX + 323, sY + 95, DRAW_DIALOGBOX_CONSTRUCTOR8); //"Press the building icon and"
			PutAlignedString(sX, sX + 323, sY + 110, DRAW_DIALOGBOX_CONSTRUCTOR9); //"the base will be formed and slowly finished"
			PutAlignedString(sX, sX + 323, sY + 125, DRAW_DIALOGBOX_CONSTRUCTOR10);//"Attack the building with Pickaxe."
			PutAlignedString(sX, sX + 323, sY + 140, DRAW_DIALOGBOX_CONSTRUCTOR11);//"Building is not activated"
			PutAlignedString(sX, sX + 323, sY + 155, DRAW_DIALOGBOX_CONSTRUCTOR12);//"while constructing."

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 27, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 220, 33, dwTime);

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 28, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 220, 34, dwTime);

			if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 26, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100, sY + 220, 32, dwTime);

			if (onButton == 4)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 25, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150, sY + 220, 31, dwTime);

			if (onButton == 5)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 322, 19, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 322, 20, dwTime);

			if (onButton == 6)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 322, 18, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 322, 4, dwTime);

			if (onButton == 1)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR13, 255, 255, 255);//"(Mana Collector)"
			}
			else if (onButton == 2)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR14, 255, 255, 255);//"(Detector)"
			}
			else if (onButton == 3)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR15, 255, 255, 255);//"(Arrow Guard Tower)"
			}
			else if (onButton == 4)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR16, 255, 255, 255);//(Cannon Guard Tower)"
			}
			else if (onButton == 5)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR17, 255, 255, 255);
			}
			else if (onButton == 6)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR18, 255, 255, 255);
			}
			break;

		case 2: // Teleport
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_CONSTRUCTOR19); //"Teleport to position that commander pointed"
			DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans); // map

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 15, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 50, sY + 340, 1, dwTime);

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 19, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 100 + 74, sY + 340, 20, dwTime);

			if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

			if (onButton == 1)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR20, 255, 255, 255);
			}
			else if (onButton == 2)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR21, 255, 255, 255);
			}
			else if (onButton == 3)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_CONSTRUCTOR22, 255, 255, 255);
			}
			break;
	}

	switch (m_dialogBoxes[37].GetMode())
	{
		case 0: // Main dlg
		case 2: // TP
			szX = 0;
			szY = 0;
			MapSzX = 0;
			MapSzY = 0;
			if (strcmp(m_cStatusMapName, "aresden") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "elvine") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "middleland") == 0)
			{
				szX = 279;
				szY = 280;	  // Fix for ML
				MapSzX = 524; // Fix for ML
				MapSzY = 524; // Fix for ML
			}
			else if (strcmp(m_cStatusMapName, "2ndmiddle") == 0)
			{
				szX = 125; // 279 -> 125
				szY = 125; // 280 -> 125
				MapSzX = 250; // 524 -> 250
				MapSzY = 250; // 524 -> 250
			}
			if (szX != 0)
			{
				for (int i = 0; i < MAXCRUSADESTRUCTURES; i++)
					if (m_stCrusadeStructureInfo[i].cType == 42)
					{
						dV1 = (double)MapSzX;
						dV2 = (double)m_stCrusadeStructureInfo[i].sX;
						dV3 = (dV2 * (double)szX) / dV1;
						tX = (int)dV3;
						dV1 = (double)MapSzY;
						dV2 = (double)m_stCrusadeStructureInfo[i].sY;
						dV3 = (dV2 * (double)szY) / dV1;
						tY = (int)dV3;
						switch (m_stCrusadeStructureInfo[i].cType)
						{
							case 42:
								DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
								break;
						}
					}
				if (m_iTeleportLocX != -1)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_iTeleportLocX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_iTeleportLocY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
				}
				if ((m_dialogBoxes[37].GetMode() != 2) && (m_iConstructLocX != -1))
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_iConstructLocX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_iConstructLocY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 41, false, true); // Contr pt
				}
				if (strcmp(m_cMapName, "2ndmiddle") == 0)
				{
					dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
					dV2 = (double)m_sPlayerX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
					dV2 = (double)m_sPlayerY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
				}
			}
			if ((m_stMCursor.sX >= sX + 15) && (m_stMCursor.sX <= sX + 15 + (MapSzX)) // 278 -> (MapSzX-30)
				&& (m_stMCursor.sY >= sY + 60) && (m_stMCursor.sY <= sY + 60 + (MapSzY))) // 272 -> (MapSzY-30) Draw mouse coordinates
			{
				dV1 = (double)(m_stMCursor.sX - (sX + 15));
				dV2 = (double)MapSzX;//(752.0f);
				dV3 = (dV2 * dV1) / szX;//280.0f;
				tX = (int)dV3;
				dV1 = (double)(m_stMCursor.sY - (sY + 60));
				dV2 = (double)MapSzX;//(680.0f);
				dV3 = (dV2 * dV1) / szY;//253.0f;
				tY = (int)dV3;
				if (tX < 30) tX = 30;
				if (tY < 30) tY = 30;
				if (tX > MapSzX - 30) tX = MapSzX - 30;
				if (tY > MapSzY - 30) tY = MapSzY - 30;
				fmt::format_to(G_cTxt, "%d,%d", tX, tY);
				PutString_SprFont3(m_stMCursor.sX + 10, m_stMCursor.sY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
			}
			break;
	}
}

void helbreath::DrawDialogBox_Soldier()
{
	short sX, sY, szX, szY, MapSzX, MapSzY;
	uint64_t dwTime = G_dwGlobalTime;
	char cMapName[120];
	double dV1, dV2, dV3;
	int tX, tY;

	char onButton = m_dialogBoxes[38].OnButton();
	sX = m_dialogBoxes[38].m_X;
	sY = m_dialogBoxes[38].m_Y;
	szX = m_dialogBoxes[38].sSizeX;
	if ((dwTime - m_dwCommanderCommandRequestedTime) > 1000 * 10)
	{
		_RequestMapStatus("2ndmiddle", 3);
		_RequestMapStatus("2ndmiddle", 1);
		m_dwCommanderCommandRequestedTime = dwTime;
	}

	DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY - 5, 0, false, m_bDialogTrans);
	DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX, sY, 21, false, m_bDialogTrans);
	DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX + 1, sY, 17, false, m_bDialogTrans); // Crusade Soldier Menu Text

	switch (m_dialogBoxes[38].GetMode())
	{
		case 0: // Main dlg, Map
			if (m_iTeleportLocX != -1)
			{
				ZeroMemory(cMapName, sizeof(cMapName));
				GetOfficialMapName(m_cTeleportMapName, cMapName);
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_SOLDIER1, cMapName, m_iTeleportLocX, m_iTeleportLocY);
				PutAlignedString(sX, sX + szX, sY + 40, G_cTxt);					// "Teleport position: %s near %d, %d"
			}
			else PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER2); //"Teleport position is not set."

			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 15, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 1, dwTime);

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

			if (onButton == 1)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_SOLDIER3, 255, 255, 255); // "Teleport to position that commander pointed"
			}
			else if (onButton == 2)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_SOLDIER4, 255, 255, 255); // "Help for soldier"
			}
			break;

		case 1: // TP now
			PutAlignedString(sX, sX + szX, sY + 40, DRAW_DIALOGBOX_SOLDIER5); // "Teleport to position that commander pointed"
			if (onButton == 1)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 15, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20, sY + 340, 1, dwTime);

			if (onButton == 2)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74 - 50, sY + 340, 19, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74 - 50, sY + 340, 20, dwTime);

			if (onButton == 3)
			{
				m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 18, dwTime);
			}
			else m_pSprite[SPRID_INTERFACE_ND_CRUSADE]->PutSpriteFast(sX + 20 + 150 + 74, sY + 340, 4, dwTime);

			if (onButton == 1)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_SOLDIER6, 255, 255, 255);
			}
			else if (onButton == 2)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_SOLDIER7, 255, 255, 255);
			}
			else if (onButton == 3)
			{
				PutString2(m_stMCursor.sX + 20, m_stMCursor.sY + 35, DRAW_DIALOGBOX_SOLDIER8, 255, 255, 255);//"Help for teleport"
			}
			break;
	}

	switch (m_dialogBoxes[38].GetMode())
	{
		case 0: // Main
		case 1: // TP
			szX = 0;
			szY = 0;
			MapSzX = 0;
			MapSzY = 0;
			if (strcmp(m_cStatusMapName, "aresden") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "elvine") == 0)
			{
				szX = 250;
				szY = 250;
			}
			else if (strcmp(m_cStatusMapName, "middleland") == 0)
			{
				szX = 279;
				szY = 280;	  // Fix for ML
				MapSzX = 524; // Fix for ML
				MapSzY = 524; // Fix for ML
			}
			else if (strcmp(m_cStatusMapName, "2ndmiddle") == 0)
			{
				szX = 125; // 279 -> 125
				szY = 125; // 280 -> 125
				MapSzX = 250; // 524 -> 250
				MapSzY = 250; // 524 -> 250
			}
			if (szX != 0)
			{
				for (int i = 0; i < MAXCRUSADESTRUCTURES; i++)
					if (m_stCrusadeStructureInfo[i].cType == 42)
					{
						dV1 = (double)MapSzX;
						dV2 = (double)m_stCrusadeStructureInfo[i].sX;
						dV3 = (dV2 * (double)szX) / dV1;
						tX = (int)dV3;
						dV1 = (double)MapSzY;
						dV2 = (double)m_stCrusadeStructureInfo[i].sY;
						dV3 = (dV2 * (double)szY) / dV1;
						tY = (int)dV3;
						switch (m_stCrusadeStructureInfo[i].cType)
						{
							case 42:
								DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 40); // ManaStone
								break;
						}
					}
				if (m_iTeleportLocX != -1)
				{
					dV1 = (double)MapSzX;
					dV2 = (double)m_iTeleportLocX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;
					dV2 = (double)m_iTeleportLocY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 42, false, true); //TP
				}
				if (strcmp(m_cMapName, "2ndmiddle") == 0)
				{
					dV1 = (double)MapSzX;//m_pMapData->m_sMapSizeX;
					dV2 = (double)m_sPlayerX;
					dV3 = (dV2 * (double)szX) / dV1;
					tX = (int)dV3;
					dV1 = (double)MapSzY;//m_pMapData->m_sMapSizeY;
					dV2 = (double)m_sPlayerY;
					dV3 = (dV2 * (double)szY) / dV1;
					tY = (int)dV3;
					DrawNewDialogBox(SPRID_INTERFACE_ND_CRUSADE, sX + tX + 15, sY + tY + 60, 43); // Player place
				}
			}
			if ((m_stMCursor.sX >= sX + 15) && (m_stMCursor.sX <= sX + 15 + (MapSzX)) // 278 -> (MapSzX-30)
				&& (m_stMCursor.sY >= sY + 60) && (m_stMCursor.sY <= sY + 60 + (MapSzY))) // 272 -> (MapSzY-30) Draw mouse coordinates
			{
				dV1 = (double)(m_stMCursor.sX - (sX + 15));
				dV2 = (double)MapSzX;//(752.0f);
				dV3 = (dV2 * dV1) / szX;//280.0f;
				tX = (int)dV3;
				dV1 = (double)(m_stMCursor.sY - (sY + 60));
				dV2 = (double)MapSzX;//(680.0f);
				dV3 = (dV2 * dV1) / szY;//253.0f;
				tY = (int)dV3;
				if (tX < 30) tX = 30;
				if (tY < 30) tY = 30;
				if (tX > MapSzX - 30) tX = MapSzX - 30;
				if (tY > MapSzY - 30) tY = MapSzY - 30;
				fmt::format_to(G_cTxt, "%d,%d", tX, tY);
				PutString_SprFont3(m_stMCursor.sX + 10, m_stMCursor.sY - 10, G_cTxt, m_wR[13] * 4, m_wG[13] * 4, m_wB[13] * 4, false, 2);
			}
			break;
	}
}

void helbreath::GrandMagicResult(char * pMapName, int iV1, int iV2, int iV3, int iV4, int iHP1, int iHP2, int iHP3, int iHP4)
{
	int i, iTxtIdx = 0;
	char cTemp[120];

	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	if (strcmp(pMapName, "aresden") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE2, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE3, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE4, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE5, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE6, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE58, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0)
		{
			PlaySound('E', 25, 0, 0);
			if (m_side == ELVINE)
			{
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE59, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE60, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE61, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE62, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if (m_side == ARESDEN)
			{
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE69, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE70, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE71, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE72, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE73, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
		}
		else
		{
			if (iV1 != 0)
			{
				if (m_side == ELVINE)
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE63, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE64, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE65, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if (m_side == ARESDEN)
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE74, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE75, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE76, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE77, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE78, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE79, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE80, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE81, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if (m_side == ELVINE)
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE66, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE67, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE68, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if (m_side == ARESDEN)
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE82, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE83, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE84, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE85, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE86, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE87, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE88, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE89, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}
	else if (strcmp(pMapName, "elvine") == 0)
	{
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE7, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE8, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE4, iV1);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE5, iV2);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE6, iV3);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d", CRUSADE_MESSAGE58, iV4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		ZeroMemory(cTemp, sizeof(cTemp));
		fmt::format_to(cTemp, "%s %d %d %d %d", NOTIFY_MSG_STRUCTURE_HP, iHP1, iHP2, iHP3, iHP4);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, cTemp, 0);
		m_pMsgTextList[iTxtIdx++] = new class CMsg(0, " ", 0);

		if (iV2 == 0)
		{
			if (m_side == ARESDEN)
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE59, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE60, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE61, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE62, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else if (m_side == ELVINE)
			{
				PlaySound('E', 25, 0, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE69, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE70, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE71, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE72, 0);
				m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE73, 0);
				for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
			}
			else PlaySound('E', 25, 0, 0);
		}
		else
		{
			if (iV1 != 0)
			{
				if (m_side == ARESDEN)
				{
					PlaySound('E', 23, 0, 0);
					PlaySound('C', 21, 0, 0);
					PlaySound('C', 22, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE63, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE64, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE65, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if (m_side == ELVINE)
				{
					PlaySound('E', 24, 0, 0);
					PlaySound('C', 12, 0, 0);
					PlaySound('C', 13, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE74, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE75, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE76, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE77, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE78, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE79, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE80, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE81, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
			else
			{
				if ((true) && (m_side == ARESDEN))
				{
					PlaySound('E', 23, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE66, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE67, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE68, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else if ((true) && (m_side == ELVINE))
				{
					PlaySound('E', 24, 0, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE82, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE83, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE84, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE85, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE86, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE87, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE88, 0);
					m_pMsgTextList[iTxtIdx++] = new class CMsg(0, CRUSADE_MESSAGE89, 0);
					for (i = iTxtIdx; i < 18; i++) m_pMsgTextList[i] = new class CMsg(0, " ", 0);
				}
				else PlaySound('E', 25, 0, 0);
			}
		}
	}

	EnableDialogBox(18, 0, 0, 0);
}

void helbreath::DrawDialogBox_Help()
{
	short sX, sY, szX;
	char onButton = m_dialogBoxes[35].OnButton();
	sX = m_dialogBoxes[35].m_X;
	sY = m_dialogBoxes[35].m_Y;

	//uncomment
// 	if (onButton == 1)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(1), DRAW_DIALOGBOX_HELP2,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(1), DRAW_DIALOGBOX_HELP2,Color(255,4,0,50));
// 	if (onButton == 2)
// 		 PutAlignedString(&m_dialogBoxes[35].GetButton(2), DRAW_DIALOGBOX_HELP1,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(2), DRAW_DIALOGBOX_HELP1,Color(255,4,0,50));
// 	if (onButton == 3)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(3), DRAW_DIALOGBOX_HELP3,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(3), DRAW_DIALOGBOX_HELP3,Color(255,4,0,50));
// 	if (onButton == 4)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(4), DRAW_DIALOGBOX_HELP4,RGB(255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(4), DRAW_DIALOGBOX_HELP4,Color(255,4,0,50));
// 	if (onButton == 5)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(5), DRAW_DIALOGBOX_HELP5,RGB(255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(5), DRAW_DIALOGBOX_HELP5,Color(255,4,0,50));
// 	if (onButton == 6)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(6), DRAW_DIALOGBOX_HELP6,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(6), DRAW_DIALOGBOX_HELP6,Color(255,4,0,50));
// 	if (onButton == 7)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(7), DRAW_DIALOGBOX_HELP7,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(7), DRAW_DIALOGBOX_HELP7,Color(255,4,0,50));
// 	if (onButton == 8)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(8), DRAW_DIALOGBOX_HELP8,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(8), DRAW_DIALOGBOX_HELP8,Color(255,4,0,50));
// 	if (onButton == 9)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(9), DRAW_DIALOGBOX_HELP9,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(9), DRAW_DIALOGBOX_HELP9,Color(255,4,0,50));
// 	if (onButton == 10)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(10), DRAW_DIALOGBOX_HELP10,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(10), DRAW_DIALOGBOX_HELP10,Color(255,4,0,50));
// 	if (onButton == 11)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(11), DRAW_DIALOGBOX_HELP11,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(11), DRAW_DIALOGBOX_HELP11,Color(255,4,0,50));
// 	if (onButton == 12)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(12), DRAW_DIALOGBOX_HELP12,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(12), DRAW_DIALOGBOX_HELP12,Color(255,4,0,50));
// 	if (onButton == 13)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(13), "F.A.Q.",Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(13), "F.A.Q.",Color(255,4,0,50));
// 	if (onButton == 14)
// 		PutAlignedString(&m_dialogBoxes[35].GetButton(14), DRAW_DIALOGBOX_HELP13,Color(255,255,255,255));
// 	else PutAlignedString(&m_dialogBoxes[35].GetButton(14),DRAW_DIALOGBOX_HELP13,RGB(4,0,50));

	if (onButton == 15)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
}

void helbreath::DrawDialogBox_Mailbox()
{
	Point pointerLoc;
	std::vector<CItem *> * items;

	CDialogBox & dlg = m_dialogBoxes[DIALOG_MAILBOX];
	char onButton = dlg.OnButton();
	short sX = dlg.m_X;
	short sY = dlg.m_Y;
	short szX = dlg.sSizeX;
	bool viewing = false;
	if (isItemLoaded == false)
	{
		_LoadItemContents();		// Item Display - ShadowEvil
		isItemLoaded = true;
	}
	isCommon = isUncommon = isRare = isEpic = isLegendary = false;
	PutString_SprFont(sX + 102, sY + 13, DRAW_DIALOGBOX_MAILBOX, 7, 0, 0);
	//PutString_SprFont2(sX + 102, sY + 13, DRAW_DIALOGBOX_MAILBOX, 210, 30, 0);

	switch (dlg.GetMode())
	{
		case 0:
			if (m_mails.size() > 16)
			{
				Point pointerLoc = dlg.HandleScroll(16, m_mails.size());

				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX1, SEND_MAIL_COST);
			//uncomment		ButtonString(dlg, 1, G_cTxt);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX18, m_mails.size());
			PutAlignedString(sX + 161, sX + szX, sY + 35, G_cTxt);

			PutAlignedString(sX - 20, sX + szX / 2, sY + 55, DRAW_DIALOGBOX_MAILBOX2);
			PutAlignedString(sX + 56, sX + szX, sY + 55, DRAW_DIALOGBOX_MAILBOX3);
			PutAlignedString(sX + 158, sX + szX, sY + 55, DRAW_DIALOGBOX_MAILBOX4);

			for (int i = 0; i < 16; i++)
			{
				int idx = i + dlg.sView;
				if (idx < m_mails.size())
				{
					idx = m_mails.size() - 1 - idx;
					PutAlignedString(sX + 25, sX + szX / 3 * 2, sY + 75 + 15 * i, m_mails[idx]->title.c_str(), (onButton == i + 3));
					PutAlignedString(sX + 56, sX + szX, sY + 75 + 15 * i, m_mails[idx]->sender.c_str(), (onButton == i + 3));
					fmt::format_to(G_cTxt, "%.2u/%.2u", m_mails[idx]->date.day, m_mails[idx]->date.month);
					PutAlignedString(sX + 158, sX + szX, sY + 75 + 15 * i, G_cTxt, (onButton == i + 3));
				}
			}
			break;

		case 1:
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX29, SEND_MAIL_COST + dlg.vvec.size() * SEND_MAIL_ITEM_COST);
			PutAlignedString(sX + 150, sX + szX, sY + 35, G_cTxt);

			//uncomment		ButtonString(dlg, 1, DRAW_DIALOGBOX_MAILBOX5, POS_LEFT);
			PutAlignedString(dlg.GetButton(1).left + 20, dlg.GetButton(1).right, dlg.GetButton(1).top - 1, dlg.cStr, false);

			//uncomment		ButtonString(dlg, 2, DRAW_DIALOGBOX_MAILBOX6, POS_LEFT);
			PutAlignedString(dlg.GetButton(2).left + 30, dlg.GetButton(2).right, dlg.GetButton(2).top - 1, dlg.cStr2, false);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX7, strlen(dlg.txt), MAX_MAIL_MSG_LENGTH - 1);
			//uncomment		ButtonString(dlg, 3, G_cTxt, POS_LEFT);
					//uncomment PutAlignedString(dlg.GetButton(3).left, dlg.GetButton(3).right, dlg.GetButton(3).top + 15, dlg.txt, false, true);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX8, dlg.vvec.size());
			//uncomment		ButtonString(dlg, 4, G_cTxt);

			//uncomment		if(!dlg.bFlag)
			//uncomment			ButtonString(dlg, 5, DRAW_DIALOGBOX_MAILBOX9);
			//uncomment		else
			//uncomment			ButtonString(dlg, 5, DRAW_DIALOGBOX_MAILBOX10);

			//uncomment		ButtonString(dlg, 6, DRAW_DIALOGBOX_MAILBOX11);
			break;

		case 2:
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX12, m_mails[dlg.sV1]->sender.c_str());
			//uncomment PutLabel(dlg.GetButton(1), G_cTxt, POS_LEFT);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX17, m_mails[dlg.sV1]->title.c_str());
			//uncomment PutLabel(dlg.GetButton(2), G_cTxt, POS_LEFT);

			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX13, strlen(dlg.txt), MAX_MAIL_MSG_LENGTH - 1);
			//uncomment PutLabel(dlg.GetButton(3), G_cTxt, POS_LEFT);

			if (m_mails[dlg.sV1]->msg)
				//uncomment PutAlignedString(dlg.GetButton(3).left, dlg.GetButton(3).right, dlg.GetButton(3).top + 15, m_mails[dlg.sV1]->msg->c_str(), false, true);

				if (m_mails[dlg.sV1]->items.size() > 0)
				{
					fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX14, m_mails[dlg.sV1]->items.size());
					//uncomment			ButtonString(dlg, 4, G_cTxt);
				}

			//uncomment		ButtonString(dlg, 5, DRAW_DIALOGBOX_MAILBOX15);
			//uncomment		ButtonString(dlg, 6, DRAW_DIALOGBOX_MAILBOX16);
			break;

		case 3:
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_DIALOGBOX_MAILBOX24);
			PutAlignedString(sX, sX + szX, sY + 60, DRAW_DIALOGBOX_MAILBOX25);
			PutAlignedString(sX, sX + szX, sY + 75, DRAW_DIALOGBOX_MAILBOX26);
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_MAILBOX27, dlg.vvec.size(), MAX_MAIL_ITEMS);
			PutAlignedString(sX, sX + szX, sY + 90, G_cTxt, 255, 255, 255);

			for (int i = 0; i < 10; i++)
			{
				if (i < dlg.vvec.size())
				{
					const char * itemname = GetItemName(m_pItemList[dlg.vvec[i].index], true)->begin()->c_str();
					//uncomment				if(dlg.vvec[i].count == 1)
					//uncomment					ButtonString(dlg, i+1, itemname);
					//uncomment				else {
					//uncomment					fmt::format_to(G_cTxt, "%u %s", dlg.vvec[i].count, itemname);
					//uncomment					ButtonString(dlg, i+1, G_cTxt);
					//uncomment				}
				}
			}

			//uncomment		ButtonString(dlg, 11, DRAW_DIALOGBOX_MAILBOX28);
			//uncomment		ButtonString(dlg, 12, DRAW_DIALOGBOX_MAILBOX11);
			break;

		case 4:
			//uncomment		ButtonString(dlg, 15, DRAW_DIALOGBOX_MAILBOX16);

			if (isItemLoaded == false)
			{
				_LoadItemContents();		// Item Display - ShadowEvil
				isItemLoaded = true;
			}
			isCommon = isUncommon = isRare = isEpic = isLegendary = false;


			items = &m_mails[dlg.sV1]->items;

			for (int i = 0;
				i < 13, i + dlg.sView < items->size();
				i++)
			{
				std::vector<string> * lines = GetItemName((*items)[i + dlg.sView], true);		// Added true, since we're not counting the number of items in a stack.
				std::vector<string>::iterator iter = lines->begin(), end = lines->end();

				if (onButton == i + 1)
				{
					viewing = true;

					if (iter != end)
					{
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), 255, 255, 255);
					}

					uint32_t maxWidth = 0;

					while (iter != end)
					{
						if (iter->size() > maxWidth)
							maxWidth = iter->size();

						++iter;
					}

					//DIRECTX m_DDraw.DrawShadowBox(sX + 70 - 3, sY + 25 - 1, sX + 70 + maxWidth * 5.5, sY + 25 + 13*lines->size());

					iter = lines->begin();

					int iLoc = 0;
					if (iter != end)
					{
						PutString(sX + 70, sY + 25, iter->c_str(), m_itemColor, false, 1);
						iLoc += 13;
						++iter;
					}

					while (iter != end)
					{
						PutString(sX + 70, sY + 25 + iLoc, iter->c_str(), Color(255, 150, 150, 150), false, 1);
						iLoc += 13;
						++iter;
					}

					uint32_t ItemColor = (*items)[i + dlg.sView]->m_ItemColor;
					{
						if ((*items)[i + dlg.sView]->m_cEquipPos == EQUIPPOS_LHAND
							|| (*items)[i + dlg.sView]->m_cEquipPos == EQUIPPOS_RHAND
							|| (*items)[i + dlg.sView]->m_cEquipPos == EQUIPPOS_TWOHAND)
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + (*items)[i + dlg.sView]->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, (*items)[i + dlg.sView]->m_sSpriteFrame,
								ItemColor, m_dwCurTime);
						}
						else
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + (*items)[i + dlg.sView]->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, (*items)[i + dlg.sView]->m_sSpriteFrame,
								ItemColor, m_dwCurTime);
					}
				}
				else if (iter != end)
				{
					if (Color(m_itemColor) != Color(255, 255, 255, 255))
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), Color(m_itemColor));
					else
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), Color(255, 0, 0, 0));
				}
			}

			pointerLoc = dlg.HandleScroll(13, items->size());
			if (items->size() > 13)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			if (!viewing)
			{
				PutAlignedString(sX, sX + szX, sY + 35, DRAW_DIALOGBOX_MAILBOX30);
			}
			break;

		case 5:
			PutAlignedString(sX, sX + szX, sY + 70, DRAW_DIALOGBOX_MAILBOX31);
			break;
	}
}

void helbreath::ItemDrop_Mailbox()
{
	if (m_dialogBoxes[DIALOG_MAILBOX].GetMode() != 1 &&
		m_dialogBoxes[DIALOG_MAILBOX].GetMode() != 3)
	{
		return;
	}

	uint32_t itemi = m_stMCursor.sSelectedObjectID;

	if (m_cCommand < 0 || !m_pItemList[itemi] || m_bIsItemDisabled[itemi])
		return;

	if (m_bIsDialogEnabled[DIALOG_QUERYDROPITEMAMOUNT] || m_bIsDialogEnabled[DIALOG_SELLORREPAIRITEM] ||
		m_bIsDialogEnabled[DIALOG_ITEMDROP] ||
		(m_bIsDialogEnabled[DIALOG_NPCACTIONQUERY] &&
			(m_dialogBoxes[DIALOG_NPCACTIONQUERY].GetMode() == 1 || m_dialogBoxes[DIALOG_NPCACTIONQUERY].GetMode() == 2))
		)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_pItemList[itemi]->m_cItemType == ITEMTYPE_CONSUME ||
		m_pItemList[itemi]->m_cItemType == ITEMTYPE_ARROW) &&
		m_pItemList[itemi]->m_dwCount > 1)
	{
		m_dialogBoxes[17].m_X = m_stMCursor.sX - 140;
		m_dialogBoxes[17].m_Y = m_stMCursor.sY - 70;
		if (m_dialogBoxes[17].m_Y < 0) m_dialogBoxes[17].m_Y = 0;

		m_dialogBoxes[17].sV1 = m_sPlayerX + 1;
		m_dialogBoxes[17].sV2 = m_sPlayerY + 1;
		m_dialogBoxes[17].sV3 = 1004;// NPC
		m_dialogBoxes[17].sV4 = itemi;

		ZeroMemory(m_dialogBoxes[17].cStr, sizeof(m_dialogBoxes[17].cStr));
		EnableDialogBox(17, itemi, m_pItemList[itemi]->m_dwCount, 0);
	}
	else
	{
		if (m_dialogBoxes[DIALOG_MAILBOX].vvec.size() < MAX_MAIL_ITEMS)
		{
			m_bIsItemDisabled[itemi] = true;

			MailItemSend item;
			item.index = itemi;
			item.count = 1;
			m_dialogBoxes[DIALOG_MAILBOX].vvec.push_back(item);
		}
		else
		{
			AddEventList(DLGBOX_CLICK_NPCACTION_QUERY10, 10);
		}
	}
}

void helbreath::DrawDialogBox_ItemUpgrade()
{
	int i, sX, sY, iValue;
	char cItemColor, cStr1[120], cStr2[120], cStr3[120];
	uint64_t dwTime = unixtime();

	char onButton = m_dialogBoxes[34].OnButton();
	sX = m_dialogBoxes[34].m_X;
	sY = m_dialogBoxes[34].m_Y;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT , sX, sY, 5); //Item Upgrade Text

	switch (m_dialogBoxes[34].GetMode())
	{
		case 1://Gizon box Drag item needed to be upgraded"
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE1); // Drag item needed to be upgraded"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE2); // "from the inventory. Then press"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE3); // 'Upgrade' button."
			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);		// "Item upgrade point : %d"
			PutAlignedString(sX + 24, sX + 248, sY + 100, G_cTxt);
			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
				iValue = (m_pItemList[m_dialogBoxes[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
				iValue = iValue * (iValue + 6) / 8 + 2;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos >= 11)
					&& (m_pItemList[m_dialogBoxes[34].sV1]->m_cItemType == 1))
				{
					if ((memcmp(m_pItemList[m_dialogBoxes[34].sV1]->m_cName, "AngelicPendant(STR)", 19) == 0)
						|| (memcmp(m_pItemList[m_dialogBoxes[34].sV1]->m_cName, "AngelicPendant(DEX)", 19) == 0)
						|| (memcmp(m_pItemList[m_dialogBoxes[34].sV1]->m_cName, "AngelicPendant(INT)", 19) == 0)
						|| (memcmp(m_pItemList[m_dialogBoxes[34].sV1]->m_cName, "AngelicPendant(MAG)", 19) == 0))
					{
						iValue = (m_pItemList[m_dialogBoxes[34].sV1]->m_dwAttribute & 0xF0000000) >> 28;
						switch (iValue)
						{
							case 0: iValue = 50; break;
							case 1: iValue = 75; break;
							case 2: iValue = 100; break;
							case 3: iValue = 125; break;
							case 4: iValue = 150; break;
							case 5: iValue = 300; break;
							case 6: iValue = 400; break;
							case 7: iValue = 500; break;
							case 8: iValue = 600; break;
							case 9: iValue = 700; break;
							case 10: iValue = 1000; break;
							case 11: iValue = 1250; break;
							case 12: iValue = 1500; break;
							case 13: iValue = 1750; break;
							case 14: iValue = 2000; break;
						}
					}
				}
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE12, iValue); //"Needed upgrade point : %d"
				if (m_iGizonItemUpgradeLeft < iValue)
					PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt, 195, 25, 25);
				else PutAlignedString(sX + 24, sX + 248, sY + 115, G_cTxt);
				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
				if (m_iGizonItemUpgradeLeft < iValue)
					DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
				else
				{
					if (onButton == 1)
						DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 47);
					else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
				}
			}
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
			// Cancel
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 2: // in progress
			PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 - 117 - 170, DRAW_DIALOGBOX_ITEMUPGRADE5);
			PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 - 117 - 170, DRAW_DIALOGBOX_ITEMUPGRADE6);
			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}
				if ((rand() % 5) == 0) m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutTransSprite25(sX + 134, sY + 182, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, dwTime);
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
			}
			if (((dwTime - m_dialogBoxes[34].dwV1) / 1000 > 4) && (m_dialogBoxes[34].dwV1 != 0))
			{
				m_dialogBoxes[34].dwV1 = 0;
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_UPGRADEITEM, 0, m_dialogBoxes[34].sV1, 0, 0, 0);
			}
			break;

		case 3: // Congratulations
			PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 - 117 - 170, DRAW_DIALOGBOX_ITEMUPGRADE7);//"Congratulation! item upgrade"
			PutAlignedString(sX + 24, sX + 248, sY + 55 + 45 + 282 - 117 - 170, DRAW_DIALOGBOX_ITEMUPGRADE8);//"has been succeeded."
			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
			}
			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 4: // Failed
			PutAlignedString(sX + 24, sX + 248, sY + 55 + 30 + 282 - 117 - 170, DRAW_DIALOGBOX_ITEMUPGRADE9);//"Item upgrade has failed."
			if ((m_dialogBoxes[34].sV1 != -1) && (m_pItemList[m_dialogBoxes[34].sV1] == 0))
			{
				PlaySound('E', 24, 0, 0);
				m_dialogBoxes[34].SetMode(7);
				return;
			}
			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
			}

			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 5: // select Stone/ Gizon
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE13); // "Select which kind of items to upgrade."
			if (onButton == 1)
			{
				PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 255, 255, 255); // "Normal item upgrade"
				PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE16); // "Upgrading a normal item."
				PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE17); // "With upgrading weapon"
				PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE18); // "items, Stone of Xelima"
				PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE19); // "is needed. With upgrading"
				PutAlignedString(sX + 24, sX + 248, sY + 210, DRAW_DIALOGBOX_ITEMUPGRADE20); // "armor items, Stone of"
				PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE21); // "Merien is needed."
				PutAlignedString(sX + 24, sX + 248, sY + 255, DRAW_DIALOGBOX_ITEMUPGRADE26); // "* Majestic items cannot be"
				PutAlignedString(sX + 24, sX + 248, sY + 270, DRAW_DIALOGBOX_ITEMUPGRADE27); // "upgraded with this performance."
			}
			else PutAlignedString(sX + 24, sX + 248, sY + 100, DRAW_DIALOGBOX_ITEMUPGRADE14, 4, 0, 50); // "Normal item upgrade"
			if (onButton == 2)
			{
				PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 255, 255, 255); // "Majestic item upgrade"
				PutAlignedString(sX + 24, sX + 248, sY + 150, DRAW_DIALOGBOX_ITEMUPGRADE22); // "Upgrading majestic items."
				PutAlignedString(sX + 24, sX + 248, sY + 165, DRAW_DIALOGBOX_ITEMUPGRADE23); // "In order to upgrade majestic items,"
				PutAlignedString(sX + 24, sX + 248, sY + 180, DRAW_DIALOGBOX_ITEMUPGRADE24); // "enough upgrade points for"
				PutAlignedString(sX + 24, sX + 248, sY + 195, DRAW_DIALOGBOX_ITEMUPGRADE25); // "majestic items are required."
				PutAlignedString(sX + 24, sX + 248, sY + 225, DRAW_DIALOGBOX_ITEMUPGRADE28); // "* Normal items cannot be"
				PutAlignedString(sX + 24, sX + 248, sY + 240, DRAW_DIALOGBOX_ITEMUPGRADE29); // "upgraded with this performance."
			}
			else PutAlignedString(sX + 24, sX + 248, sY + 120, DRAW_DIALOGBOX_ITEMUPGRADE15, 4, 0, 50); // "Majestic item upgrade"
		   // Cancel
			if (onButton == 3)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);

			if (onButton == 4) // Upgrade Hero System xRisenx
			{
				PutAlignedString(sX + 24, sX + 248, sY + 140, DRAW_DIALOGBOX_ITEMUPGRADE43, 255, 255, 255); // "Hero item upgrade"
				PutAlignedString(sX + 24, sX + 248, sY + 160, DRAW_DIALOGBOX_ITEMUPGRADE44); // "Upgrading a normal item."
				PutAlignedString(sX + 24, sX + 248, sY + 175, DRAW_DIALOGBOX_ITEMUPGRADE45); // "With upgrading weapon"
				PutAlignedString(sX + 24, sX + 248, sY + 190, DRAW_DIALOGBOX_ITEMUPGRADE46); // "items, Stone of Xelima"
				//PutAlignedString(sX + 24, sX + 248, sY + 205, DRAW_DIALOGBOX_ITEMUPGRADE47); // "is needed. With upgrading"
				//PutAlignedString(sX + 24, sX + 248, sY + 220, DRAW_DIALOGBOX_ITEMUPGRADE48); // "armor items, Stone of"
				//PutAlignedString(sX + 24, sX + 248, sY + 235, DRAW_DIALOGBOX_ITEMUPGRADE49); // "Merien is needed."
				PutAlignedString(sX + 24, sX + 248, sY + 250, DRAW_DIALOGBOX_ITEMUPGRADE26); // "* Majestic items cannot be"
				PutAlignedString(sX + 24, sX + 248, sY + 265, DRAW_DIALOGBOX_ITEMUPGRADE27); // "upgraded with this performance."
			}
			else PutAlignedString(sX + 24, sX + 248, sY + 140, DRAW_DIALOGBOX_ITEMUPGRADE43, 4, 0, 50); // "Normal item upgrade"

			break;

		case 6: // Stone upgrade
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE31); // "After bring a normal item to"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE32); //
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE33); //
			if (m_dialogBoxes[34].sV2 == 0)
			{
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, DRAW_DIALOGBOX_ITEMUPGRADE41, 195, 25, 25);//"You can upgrade only armor."
			}
			else
			{
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE34, m_dialogBoxes[34].sV2);//"The number of upgrade(weapon): %d"
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 80, G_cTxt);
			}
			if (m_dialogBoxes[34].sV3 == 0)
			{
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, DRAW_DIALOGBOX_ITEMUPGRADE42, 195, 25, 25);//"You can upgrade only weapon."
			}
			else
			{
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE35, m_dialogBoxes[34].sV3);//"The number of upgrade(armor): %d"
				PutAlignedString(sX + 24, sX + 248, sY + 20 + 95, G_cTxt);
			}

			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);

			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}

				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
				if (onButton == 1)
					DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 47);
				else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
			}
			// Cancel
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;

		case 7: // lost item
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE36);//"Due to the failure of upgrade, the"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 145, DRAW_DIALOGBOX_ITEMUPGRADE37);//"item is gone. Try next time!"
			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 8: // impossible deja an max
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE38);//"Upgrading the item is not possible any more."
			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 9: // impossible
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE39);//"Upgrading the item is not possible."
			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 10: // plus de gizons
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 130, DRAW_DIALOGBOX_ITEMUPGRADE40);//"A point to upgrade items is not present"
			// OK
			if (onButton == 1)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
			break;

		case 13: // Upgrade Hero System xRisenx
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 30, DRAW_DIALOGBOX_ITEMUPGRADE31); // "After bring a normal item to"
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 45, DRAW_DIALOGBOX_ITEMUPGRADE32); //
			PutAlignedString(sX + 24, sX + 248, sY + 20 + 60, DRAW_DIALOGBOX_ITEMUPGRADE33); //
			DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE47, m_iGizonItemUpgradeLeft);		// "Item upgrade point : %d"
			PutAlignedString(sX + 24, sX + 248, sY + 100, G_cTxt);
			if (m_dialogBoxes[34].sV1 != -1)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME3, sX, sY, 3);





				i = m_dialogBoxes[34].sV1;
				cItemColor = m_pItemList[m_dialogBoxes[34].sV1]->m_ItemColor;
				if ((m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_LHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_RHAND)
					|| (m_pItemList[m_dialogBoxes[34].sV1]->m_cEquipPos == EQUIPPOS_TWOHAND))
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], dwTime);
				}
				else
				{
					m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemList[m_dialogBoxes[34].sV1]->m_sSprite]->PutSpriteRGB(sX + 134, sY + 182
						, m_pItemList[m_dialogBoxes[34].sV1]->m_sSpriteFrame, m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], dwTime);
				}

				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));
				GetItemName(m_pItemList[m_dialogBoxes[34].sV1], cStr1, cStr2, cStr3);
				PutAlignedString(sX + 24, sX + 248, sY + 230 + 20, cStr1);
				PutAlignedString(sX + 24, sX + 248, sY + 245 + 20, cStr2);
				PutAlignedString(sX + 24, sX + 248, sY + 260 + 20, cStr3);
				if (onButton == 1)
					DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 47);
				else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 46);
			}
			// Cancel
			if (onButton == 2)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;
	}
}

LONG helbreath::GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata)
{
	HKEY hkey;
	LONG retval = RegOpenKeyEx(key, subkey, 0, KEY_QUERY_VALUE, &hkey);
	if (retval == ERROR_SUCCESS)
	{
		long datasize = MAX_PATH;
		TCHAR data[MAX_PATH];
		RegQueryValue(hkey, 0, data, &datasize);
		lstrcpy(retdata, data);
		RegCloseKey(hkey);
	}
	return retval;
}

void helbreath::GoHomepage(bool _web)
{
	// 	wchar_t * url;
	// 	if (_web)
	// 	url = MSG_HOMEPAGE;
	// 	else url = MSG_HOMEPAGE2; // Added Forum button xRisenx
	// 	int		showcmd = SW_SHOW;
	// 	wchar_t	key[MAX_PATH + MAX_PATH];
	// 	SendMessage( G_hWnd, WM_ACTIVATEAPP, 0, 0 );
	//     // First try ShellExecute()
	//     HINSTANCE result = ShellExecuteA(NULL, "open", url, NULL,NULL, showcmd);
	// 
	//     // If it failed, get the .htm regkey and lookup the program
	//     if ((UINT)result <= HINSTANCE_ERROR)
	// 	{
	// 		if (GetRegKey(HKEY_CLASSES_ROOT, L".htm", key) == ERROR_SUCCESS)
	// 		{
	// 			lstrcatW(key, L"\\shell\\open\\command");
	// 
	//             if (GetRegKey(HKEY_CLASSES_ROOT,key,key) == ERROR_SUCCESS)
	// 			{
	// 				wchar_t *pos;
	// 				pos = wcsstr(key, L"\"%1\"");
	// 				if (pos == NULL)					// No quotes found
	// 				{
	// 					pos = wcsstr(key, L"%1");			// Check for %1, without quotes
	//                     if (pos == NULL)				// No parameter at all...
	//                         pos = key+lstrlen(key)-1;
	//                     else *pos = '\0';				// Remove the parameter
	//                 }
	// 				else    *pos = '\0';				// Remove the parameter
	//                 lstrcatW(pos, L" ");
	//                 lstrcatW(pos, url);
	//                 result = (HINSTANCE) WinExec(key,showcmd);
	// 			}
	// 		}
	// 	}
}

// num : 1 - F2, 2 - F3
void helbreath::UseShortCut(int num)
{
	int index;
	if (num < 3) index = num + 1;
	else index = num + 7;
	if (m_cGameMode != GAMEMODE_ONMAINGAME) return;
	if (m_bCtrlPressed == true)
	{
		if (m_sRecentShortCut == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			fmt::format_to(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			fmt::format_to(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else
		{
			m_sShortCut[num] = m_sRecentShortCut;
			if (m_sShortCut[num] < 100)
			{
				if (m_pItemList[m_sShortCut[num]] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				char cStr1[64], cStr2[64], cStr3[64];
				ZeroMemory(cStr1, sizeof(cStr1));
				ZeroMemory(cStr2, sizeof(cStr2));
				ZeroMemory(cStr3, sizeof(cStr3));

				GetItemName(m_pItemList[m_sShortCut[num]], cStr1, cStr2, cStr3);
				fmt::format_to(G_cTxt, MSG_SHORTCUT4, cStr1, cStr2, cStr3, index);// (%s %s %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
			else if (m_sShortCut[num] >= 100)
			{
				if (m_pMagicCfgList[m_sShortCut[num] - 100] == 0)
				{
					m_sShortCut[num] = -1;
					m_sRecentShortCut = -1;
					return;
				}
				fmt::format_to(G_cTxt, MSG_SHORTCUT5, m_pMagicCfgList[m_sShortCut[num] - 100]->m_cName, index);// %s) [F%d]
				AddEventList(G_cTxt, 10);
			}
		}
	}
	else
	{
		if (m_sShortCut[num] == -1)
		{
			AddEventList(MSG_SHORTCUT1, 10);
			fmt::format_to(G_cTxt, MSG_SHORTCUT2, index);// [F%d]
			AddEventList(G_cTxt, 10);
			fmt::format_to(G_cTxt, MSG_SHORTCUT3, index);// [Control]-[F%d]
			AddEventList(G_cTxt, 10);
		}
		else if (m_sShortCut[num] < 100)
		{
			ItemEquipHandler((char)m_sShortCut[num]);
		}
		else if (m_sShortCut[num] >= 100) UseMagic(m_sShortCut[num] - 100);
	}
}

int helbreath::iGetManaCost(int iMagicNo)
{
	int i, iManaSave, iManaCost;
	iManaSave = 0;
	if (iMagicNo < 0 || iMagicNo >= 100) return 1;
	for (i = 0; i < MAXITEMS; i++)
	{
		if (m_pItemList[i] == 0) continue;
		if (m_bIsItemEquipped[i] == true)
		{
			if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS10)") == 0)		iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS20)") == 0)		iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicWand(MS30-LLF)") == 0) iManaSave += 30;
			else if (strcmp(m_pItemList[i]->m_cName, "WizMagicWand(MS10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "WizMagicWand(MS20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS15)") == 0) iManaSave += 15;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS18)") == 0) iManaSave += 18;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS20)") == 0) iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS22)") == 0) iManaSave += 22;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS25)") == 0) iManaSave += 25;
			else if (strcmp(m_pItemList[i]->m_cName, "MagicNecklace(MS30)") == 0) iManaSave += 30;
			else if (strcmp(m_pItemList[i]->m_cName, "DMMagicStaff") == 0)		iManaSave += 22;
			else if (strcmp(m_pItemList[i]->m_cName, "DMMagicWand") == 0)			iManaSave += 25;
			else if (strcmp(m_pItemList[i]->m_cName, "BlackMageTemple") == 0)		iManaSave += 28;
			else if (strcmp(m_pItemList[i]->m_cName, "NecklaceOfLiche") == 0)   	iManaSave += 35;
			else if (strcmp(m_pItemList[i]->m_cName, "BerserkWand(MS.20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "BerserkWand(MS.10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "KlonessWand(MS.20)") == 0)	iManaSave += 20;
			else if (strcmp(m_pItemList[i]->m_cName, "KlonessWand(MS.10)") == 0)	iManaSave += 10;
			else if (strcmp(m_pItemList[i]->m_cName, "DameWand(MS10)") == 0)		iManaSave += 10; // Magic Save Ratio xRisenx
			else if (strcmp(m_pItemList[i]->m_cName, "MasterWand(MS20)") == 0)	iManaSave += 20; // Magic Save Ratio xRisenx
			else if (strcmp(m_pItemList[i]->m_cName, "LegendWand(MS25)") == 0)	iManaSave += 25; // Magic Save Ratio xRisenx
			else if (strcmp(m_pItemList[i]->m_cName, "WandOfWitch") == 0)			iManaSave += 15; // Magic Save Ratio xRisenx
			else if (strcmp(m_pItemList[i]->m_cName, "WandOfGWitch") == 0)		iManaSave += 10; // Magic Save Ratio xRisenx
			else if (strcmp(m_pItemList[i]->m_cName, "WandOfAncWitch") == 0)		iManaSave += 5; // Magic Save Ratio xRisenx

		}
	}
	iManaCost = m_pMagicCfgList[iMagicNo]->m_sValue1;
	if (m_bIsSafeAttackMode) iManaCost *= 1.1;
	if (iManaSave > 0)
	{
		double dV1 = (double)iManaSave;
		double dV2 = (double)(dV1 / 100.0f);
		double dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;
	}
	if (iManaCost < 1) iManaCost = 1;
	return iManaCost;
}

void helbreath::UseMagic(int iMagicNo)
{
	char cTemp[100];

	if (iMagicNo < 0 || iMagicNo >= MAXMAGICTYPE) return;
	if ((m_cMagicMastery[iMagicNo] == 0) || (m_pMagicCfgList[iMagicNo] == 0)) return;

	// Casting
	if (m_iHP <= 0) return;
	if (m_bIsGetPointingMode == true) return;
	if (iGetManaCost(iMagicNo) > m_iMP) return;
	if (_bIsItemOnHand() == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC1, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(DLGBOX_CLICK_MAGIC2, 10);
		return;
	}
	if (m_magicDisabled[iMagicNo])
	{
		fmt::format_to(cTemp, NOTIFYMSG_SPELLDISABLED, m_pMagicCfgList[iMagicNo]->m_cName);
		AddEventList(cTemp, 10);
		return;
	}
	if ((m_sPlayerAppr2 & 0xF000) == 0) bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_TOGGLECOMBATMODE, 0, 0, 0, 0, 0);
	m_cCommand = OBJECTMAGIC;
	m_iCastingMagicType = iMagicNo;
	m_sMagicShortCut = iMagicNo;
	m_sRecentShortCut = iMagicNo + 100;
	m_iPointCommandType = iMagicNo + 100;
	//m_bIsGetPointingMode = TRUE;
	DisableDialogBox(3);
}


void helbreath::ReleaseEquipHandler(char cEquipPos)
{
	char cStr1[64], cStr2[64], cStr3[64];
	if (m_sItemEquipmentStatus[cEquipPos] < 0) return;
	// Remove Angelic Stats
	if ((cEquipPos >= 11)
		&& (m_pItemList[m_sItemEquipmentStatus[cEquipPos]]->m_cItemType == 1))
	{
		char cItemID = m_sItemEquipmentStatus[cEquipPos];
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(STR)", 19) == 0)
		{
			m_angelStat[STAT_STR] = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(DEX)", 19) == 0)
		{
			m_angelStat[STAT_DEX] = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(INT)", 19) == 0)
		{
			m_angelStat[STAT_INT] = 0;
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(MAG)", 19) == 0)
		{
			m_angelStat[STAT_MAG] = 0;
		}
	}

	GetItemName(m_pItemList[m_sItemEquipmentStatus[cEquipPos]], cStr1, cStr2, cStr3);
	fmt::format_to(G_cTxt, ITEM_EQUIPMENT_RELEASED, cStr1);
	AddEventList(G_cTxt, 10);
	m_bIsItemEquipped[m_sItemEquipmentStatus[cEquipPos]] = false;
	m_sItemEquipmentStatus[cEquipPos] = -1;
}

void helbreath::ItemEquipHandler(char cItemID)
{
	if (bCheckItemOperationEnabled(cItemID) == false) return;
	if (m_bIsItemEquipped[cItemID] == true) return;
	if (m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_NONE)
	{
		AddEventList(BITEMDROP_CHARACTER3, 10);//"The item is not available."
		return;
	}
	if (m_pItemList[cItemID]->m_wCurLifeSpan == 0)
	{
		AddEventList(BITEMDROP_CHARACTER1, 10); //"The item is exhausted. Fix it to use it."
		return;
	}
	if (m_pItemList[cItemID]->m_wWeight / 100 > m_stat[STAT_STR])
	{
		AddEventList(BITEMDROP_CHARACTER2, 10);
		return;
	}
	if (((m_pItemList[cItemID]->m_dwAttribute & 0x00000001) == 0) && (m_pItemList[cItemID]->m_sLevelLimit > m_iLevel))
	{
		AddEventList(BITEMDROP_CHARACTER4, 10);
		return;
	}
	if (m_bSkillUsingStatus == true)
	{
		AddEventList(BITEMDROP_CHARACTER5, 10);
		return;
	}
	if (m_pItemList[cItemID]->m_cGenderLimit != 0)
	{
		switch (m_sPlayerType)
		{
			case 1:
			case 2:
			case 3:
				if (m_pItemList[cItemID]->m_cGenderLimit != 1)
				{
					AddEventList(BITEMDROP_CHARACTER6, 10);
					return;
				}
				break;
			case 4:
			case 5:
			case 6:
				if (m_pItemList[cItemID]->m_cGenderLimit != 2)
				{
					AddEventList(BITEMDROP_CHARACTER7, 10);
					return;
				}
				break;
		}
	}
	if (m_armorDisabled &&
		(m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_HEAD ||
			m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_ARMS ||
			m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_BODY ||
			m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_PANTS))
	{
		AddEventList(NOTIFYMSG_ARMORDISABLED, 10);//"Use of armors have been disabled."
		return;
	}
	if (m_shieldDisabled && m_pItemList[cItemID]->m_cEquipPos == EQUIPPOS_LHAND)
	{
		AddEventList(NOTIFYMSG_SHIELDDISABLED, 10);//"Shields have been disabled."
		return;
	}

	bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_EQUIPITEM, 0, cItemID, 0, 0, 0);
	m_sRecentShortCut = cItemID;
	ReleaseEquipHandler(m_pItemList[cItemID]->m_cEquipPos);
	switch (m_pItemList[cItemID]->m_cEquipPos)
	{
		case EQUIPPOS_HEAD:
		case EQUIPPOS_BODY:
		case EQUIPPOS_ARMS:
		case EQUIPPOS_PANTS:
		case EQUIPPOS_BOOTS:
		case EQUIPPOS_BACK:
			ReleaseEquipHandler(EQUIPPOS_FULLBODY);
			break;
		case EQUIPPOS_FULLBODY:
			ReleaseEquipHandler(EQUIPPOS_HEAD);
			ReleaseEquipHandler(EQUIPPOS_BODY);
			ReleaseEquipHandler(EQUIPPOS_ARMS);
			ReleaseEquipHandler(EQUIPPOS_PANTS);
			ReleaseEquipHandler(EQUIPPOS_BOOTS);
			ReleaseEquipHandler(EQUIPPOS_BACK);
			break;
		case EQUIPPOS_LHAND:
		case EQUIPPOS_RHAND:
			ReleaseEquipHandler(EQUIPPOS_TWOHAND);
			break;
		case EQUIPPOS_TWOHAND:
			ReleaseEquipHandler(EQUIPPOS_RHAND);
			ReleaseEquipHandler(EQUIPPOS_LHAND);
			break;
	}

	m_sItemEquipmentStatus[m_pItemList[cItemID]->m_cEquipPos] = cItemID;
	m_bIsItemEquipped[cItemID] = true;

	// Add Angelic Stats
	if ((m_pItemList[cItemID]->m_cItemType == 1)
		&& (m_pItemList[cItemID]->m_cEquipPos >= 11))
	{
		int iAngelValue = 0;
		if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(STR)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			//m_angelStat[STAT_STR] = 1 + iAngelValue; // Angel Stats xRisenx
			m_angelStat[STAT_STR] = 12 * iAngelValue; // Angel Stats xRisenx
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(DEX)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			//m_angelStat[STAT_DEX] = 1 + iAngelValue; // Angel Stats xRisenx
			m_angelStat[STAT_DEX] = 12 * iAngelValue; // Angel Stats xRisenx
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(INT)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			//m_angelStat[STAT_INT] = 1 + iAngelValue; // Angel Stats xRisenx
			m_angelStat[STAT_INT] = 12 * iAngelValue; // Angel Stats xRisenx
		}
		else if (memcmp(m_pItemList[cItemID]->m_cName, "AngelicPendant(MAG)", 19) == 0)
		{
			iAngelValue = (m_pItemList[cItemID]->m_dwAttribute & 0xF0000000) >> 28;
			//m_angelStat[STAT_MAG] = 1 + iAngelValue; // Angel Stats xRisenx
			m_angelStat[STAT_MAG] = 12 * iAngelValue; // Angel Stats xRisenx
		}
	}

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(m_pItemList[cItemID], cStr1, cStr2, cStr3);
	fmt::format_to(G_cTxt, BITEMDROP_CHARACTER9, cStr1);
	AddEventList(G_cTxt, 10);
	PlaySound('E', 28, 0);
}

/*********************************************************************************************************************
**  void CheckActiveAura(short sX, short sY, DWORD dwTime, short sOwnerType)( initially Cleroth fixed by Snoopy )	**
**  description			: Generates special auras around players													**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void helbreath::CheckActiveAura(short sX, short sY, uint64_t dwTime, short sOwnerType)
{	// Used at the beginning of character drawing
	// DefenseShield
	if ((_tmp_iStatus & STATUS_DEFENSESHIELD) != 0)
		//m_pEffectSpr[80]->PutTransSprite(sX+75, sY+107, _tmp_iEffectFrame%17, dwTime);
		m_pEffectSpr[80]->PutTransSprite50(sX + 75, sY + 107, _tmp_iEffectFrame % 17, dwTime);

	// Protection From Magic
	if ((_tmp_iStatus & STATUS_PFM) != 0)
		//m_pEffectSpr[79]->PutTransSprite(sX+101, sY+135, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[79]->PutTransSprite70(sX + 101, sY + 135, _tmp_iEffectFrame % 15, dwTime);

	// Protection From Arrow
	if ((_tmp_iStatus & STATUS_PFA) != 0)
		//m_pEffectSpr[72]->PutTransSprite(sX, sY+35, _tmp_iEffectFrame%30, dwTime);
		m_pEffectSpr[72]->PutTransSprite70(sX, sY + 35, _tmp_iEffectFrame % 30, dwTime);

	// Illusion
	if ((_tmp_iStatus & STATUS_ILLUSION) != 0)
		//m_pEffectSpr[73]->PutTransSprite(sX+125, sY+95, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[73]->PutTransSprite70(sX + 125, sY + 130 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, dwTime);

	// Illusion movement
	if ((_tmp_iStatus & STATUS_ILLUSIONMOVEMENT) != 0)
		//m_pEffectSpr[151]->PutTransSprite(sX+90, sY+55, _tmp_iEffectFrame%24, dwTime);
		m_pEffectSpr[151]->PutTransSprite70(sX + 90, sY + 90 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 24, dwTime);

	// Slate red  (HP)  Flame au sol
	if ((_tmp_iStatus & STATUS_REDSLATE) != 0)
		//m_pEffectSpr[149]->PutTransSprite(sX+90, sY+120, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[149]->PutTransSprite70(sX + 90, sY + 120, _tmp_iEffectFrame % 15, dwTime);

	// Slate Blue (Mana) Bleu au sol
	if ((_tmp_iStatus & STATUS_BLUESLATE) != 0)
		//m_pEffectSpr[150]->PutTransSprite(sX+1, sY+26, _tmp_iEffectFrame%15, dwTime);
		m_pEffectSpr[150]->PutTransSprite70(sX + 1, sY + 26, _tmp_iEffectFrame % 15, dwTime);

	// Slate Green (XP) Mauve au sol
	if ((_tmp_iStatus & STATUS_GREENSLATE) != 0)
		//m_pEffectSpr[148]->PutTransSprite(sX, sY+32, _tmp_iEffectFrame%23, dwTime);
		m_pEffectSpr[148]->PutTransSprite70(sX, sY + 32, _tmp_iEffectFrame % 23, dwTime);

	// the ZZZ's
	if ((_tmp_iStatus & STATUS_AFK) != 0)
		m_pEffectSpr[85]->PutTransSprite70(sX + 50, sY + 30, _tmp_iEffectFrame % 29, dwTime);

	if (_tmp_iStatus & STATUS_RELICHOLDER)
	{
		int framesNum = m_pEffectSpr[26]->m_iTotalFrame - 4;
		m_pEffectSpr[26]->PutTransSprite(sX, sY,
			4 + _tmp_iEffectFrame % framesNum
			, dwTime);
		m_pEffectSpr[26]->PutTransSprite70(sX, sY,
			4 + (_tmp_iEffectFrame + framesNum / 2) % framesNum
			, dwTime);
		// 		m_pEffectSpr[150]->PutTransSprite50(sX+1, sY+26, (_tmp_iEffectFrame+7)%15, dwTime);
		// 		m_pEffectSpr[148]->PutTransSprite50(sX, sY+32, (_tmp_iEffectFrame+15)%23, dwTime);
	}
}

/*********************************************************************************************************************
**  void CheckActiveAura2(short sX, short sY, DWORD dwTime,  _tmp_sOwnerType) ( initially Cleroth fixed by Snoopy )	**
**  description			: Generates poison aura around players. This one should be use later...						**
**						: v351 implements this in each drawn function,beter to regroup in single function.			**
**********************************************************************************************************************/
void helbreath::CheckActiveAura2(short sX, short sY, uint64_t dwTime, short sOwnerType)
{	// Poison
	if ((_tmp_iStatus & STATUS_POISON) != 0)
		//m_pEffectSpr[81]->PutTransSprite(sX+115, sY+85, _tmp_iEffectFrame%21, dwTime);
		m_pEffectSpr[81]->PutTransSprite70(sX + 115, sY + 120 - _iAttackerHeight[sOwnerType], _tmp_iEffectFrame % 21, dwTime);
	//	_iAttackerHeight[]

	if ((m_bIsHeldenianMode) && (m_bIsHeldenianMap))
	{
		if ((_tmp_iStatus & 0x00400000) != 0)			// BloodyMantle
			m_pEffectSpr[107]->PutTransSprite70(sX - 5, sY, _tmp_iEffectFrame % 15, dwTime);
		else if ((_tmp_iStatus & 0x00800000) != 0)		// Magic Mantle
			m_pEffectSpr[114]->PutTransSprite70(sX - 5, sY, _tmp_iEffectFrame % 15, dwTime);
		else if ((_tmp_iStatus & 0x00010000) != 0)		// ArrowMantle
			m_pEffectSpr[115]->PutTransSprite70(sX - 5, sY, _tmp_iEffectFrame % 15, dwTime);
		else if ((_tmp_iStatus & 0x00020000) != 0)
			m_pEffectSpr[87]->PutTransSprite70(sX + 53, sY + 54, _tmp_iEffectFrame % 29, dwTime);
	}
}

// 3.51 Level Up Dialog - Changes stats Using Majestic points - Diuuude
void helbreath::DrawDialogBox_ChangeStatsMajestic()
{
	short sX, sY, szX;
	uint64_t dwTime = m_dwCurTime;
	char cTxt[120];
	int iStats, statsChanged, majPointsUsed;

	char onButton = m_dialogBoxes[42].OnButton();
	sX = m_dialogBoxes[42].m_X;
	sY = m_dialogBoxes[42].m_Y;
	szX = m_dialogBoxes[42].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 2);
	DrawNewDialogBox(SPRID_INTERFACE_ND_GAME4, sX + 16, sY + 100, 4);

	PutAlignedString(sX, sX + szX, sY + 50, DRAW_DIALOGBOX_LEVELUP_SETTING14);
	PutAlignedString(sX, sX + szX, sY + 65, DRAW_DIALOGBOX_LEVELUP_SETTING15);

	statsChanged = 0;
	for (int i = 0; i < 6; i++) statsChanged -= m_luStat[i];
	majPointsUsed = (statsChanged + 2) / 3;

	PutString(sX + 20, sY + 85, DRAW_DIALOGBOX_LEVELUP_SETTING16, Color(255, 0, 0, 0));
	fmt::format_to(cTxt, "%d", m_iGizonItemUpgradeLeft - majPointsUsed);
	if (majPointsUsed > 0)
	{
		PutString(sX + 75, sY + 102, cTxt, Color(255, 0, 255, 0));
	}
	else
	{
		PutString(sX + 75, sY + 102, cTxt, Color(255, 0, 0, 0));
	}

	// Strength
	PutString(sX + 24, sY + 125, DRAW_DIALOGBOX_LEVELUP_SETTING4, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_STR] - m_angelStat[STAT_STR]);
	PutString(sX + 109, sY + 125, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_STR] + m_luStat[STAT_STR] - m_angelStat[STAT_STR];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_STR] != 0)
	{
		PutString(sX + 162, sY + 125, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 125, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 1 && m_luStat[STAT_STR] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 127, 5, dwTime);
	if (onButton == 7 && m_stat[STAT_STR] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 127, 6, dwTime);


	PutString(sX + 24, sY + 144, DRAW_DIALOGBOX_LEVELUP_SETTING5, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_VIT]);
	PutString(sX + 109, sY + 144, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_VIT] + m_luStat[STAT_VIT];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_VIT] != 0)
	{
		PutString(sX + 162, sY + 144, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 144, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 2 && m_luStat[STAT_VIT] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 146, 5, dwTime);
	if (onButton == 8 && m_stat[STAT_VIT] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 146, 6, dwTime);

	// Dexterity
	PutString(sX + 24, sY + 163, DRAW_DIALOGBOX_LEVELUP_SETTING6, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_DEX] - m_angelStat[STAT_DEX]);
	PutString(sX + 109, sY + 163, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_DEX] + m_luStat[STAT_DEX] - m_angelStat[STAT_DEX];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_DEX] != 0)
	{
		PutString(sX + 162, sY + 163, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 163, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 3 && m_luStat[STAT_DEX] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 165, 5, dwTime);
	if (onButton == 9 && m_stat[STAT_DEX] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 165, 6, dwTime);

	// Intelligence
	PutString(sX + 24, sY + 182, DRAW_DIALOGBOX_LEVELUP_SETTING7, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_INT] - m_angelStat[STAT_INT]);
	PutString(sX + 109, sY + 182, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_INT] + m_luStat[STAT_INT] - m_angelStat[STAT_INT];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_INT] != 0)
	{
		PutString(sX + 162, sY + 182, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 182, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 4 && m_luStat[STAT_INT] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 184, 5, dwTime);
	if (onButton == 10 && m_stat[STAT_INT] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 184, 6, dwTime);

	// Magic
	PutString(sX + 24, sY + 201, DRAW_DIALOGBOX_LEVELUP_SETTING8, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_MAG] - m_angelStat[STAT_MAG]);
	PutString(sX + 109, sY + 201, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_MAG] + m_luStat[STAT_MAG] - m_angelStat[STAT_MAG];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_MAG] != 0)
	{
		PutString(sX + 162, sY + 201, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 201, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 5 && m_luStat[STAT_MAG] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 203, 5, dwTime);
	if (onButton == 11 && m_stat[STAT_MAG] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 203, 6, dwTime);

	// Charisma
	PutString(sX + 24, sY + 220, DRAW_DIALOGBOX_LEVELUP_SETTING9, Color(255, 5, 5, 5));
	fmt::format_to(cTxt, "%d", m_stat[STAT_CHR]);
	PutString(sX + 109, sY + 220, cTxt, Color(255, 25, 35, 25));
	iStats = m_stat[STAT_CHR] + m_luStat[STAT_CHR];
	fmt::format_to(cTxt, "%d", iStats);
	if (m_luStat[STAT_CHR] != 0)
	{
		PutString(sX + 162, sY + 220, cTxt, Color(255, 255, 0, 0));
	}
	else
	{
		PutString(sX + 162, sY + 220, cTxt, Color(255, 25, 35, 25));
	}
	if (onButton == 6 && m_luStat[STAT_CHR] != 0)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 195, sY + 222, 5, dwTime);
	if (onButton == 12 && m_stat[STAT_CHR] > 10)
		m_pSprite[SPRID_INTERFACE_ND_GAME4]->PutSpriteFast(sX + 210, sY + 222, 6, dwTime);

	if (onButton == 14)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 17);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 16);

	if (onButton == 13)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);
}


// 3.51 LevelUp Box - Change stats using Majestic - Diuuude
void helbreath::DlgBoxClick_ChangeStatsMajestic()
{
	char onButton = m_dialogBoxes[42].OnButton();

	if (!onButton) return;

	int statChanged = onButton > 6 ? onButton - 7 : onButton - 1;
	int changeAmount = m_bCtrlPressed ? 5 : 1;
	int totalChanged = 0;

	for (int i = 0; i < 6; i++) totalChanged -= m_luStat[i];

	if (totalChanged && onButton <= 6)
	{
		if (m_luStat[statChanged])
		{
			changeAmount = changeAmount > -m_luStat[statChanged] ? -m_luStat[statChanged] : changeAmount;
			m_luStat[statChanged] += changeAmount;
			m_iLU_Point -= changeAmount;
		}
	}

	if ((totalChanged / 3) < m_iGizonItemUpgradeLeft && onButton >= 7 && onButton <= 12)
	{
		if ((totalChanged + changeAmount + 2) / 3 > m_iGizonItemUpgradeLeft)
			changeAmount = (m_iGizonItemUpgradeLeft * 3) - totalChanged;

		if (m_stat[statChanged] + m_luStat[statChanged] - changeAmount < 10)
			changeAmount = m_stat[statChanged] + m_luStat[statChanged] - 10;

		m_luStat[statChanged] -= changeAmount;
		m_iLU_Point += changeAmount;
	}

	if (statChanged && onButton == 13)
	{
		bSendCommand(MSGID_STATECHANGEPOINT);
		DisableDialogBox(42);
	}

	if (onButton == 14)
	{
		for (int i = 0; i < 6; i++)	m_luStat[i] = 0;
		m_iLU_Point -= totalChanged;
		DisableDialogBox(42);
	}

	PlaySound('E', 14, 5);
}

void helbreath::DrawAngel(int iSprite, short sX, short sY, char cFrame, uint64_t dwTime)
{
	if ((_tmp_iStatus & 0x1000) != 0) m_pSprite[SPRID_TUTELARYANGELS_PIVOTPOINT + iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime);  //AngelicPendant(STR)
	else if ((_tmp_iStatus & 0x2000) != 0) m_pSprite[SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 1) + iSprite]->PutSpriteFast(sX, sY, cFrame, dwTime); //AngelicPendant(DEX)
	else if ((_tmp_iStatus & 0x4000) != 0) m_pSprite[SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 2) + iSprite]->PutSpriteFast(sX, sY - 20, cFrame, dwTime);//AngelicPendant(INT)
	else if ((_tmp_iStatus & 0x8000) != 0) m_pSprite[SPRID_TUTELARYANGELS_PIVOTPOINT + (50 * 3) + iSprite]->PutSpriteFast(sX, sY - 20, cFrame, dwTime);//AngelicPendant(MAG)

}
/*********************************************************************************************************************
**  int CGame::bHasHeroSet( short m_sAppr3, short m_sAppr3, char OwnerType)		( Snoopy )							**
**  description			:: check weather the object (is character) is using a hero set (1:war, 2:mage)				**
**********************************************************************************************************************/
//int CGame::bHasHeroSet(short Appr3, short Appr4, char OwnerType)
int helbreath::bHasHeroSet(short HeadApprValue, short BodyApprValue, short ArmApprValue, short LegApprValue, char OwnerType)
{
	char cArmor, cLeg, cBerk, cHat;
	cArmor = BodyApprValue;
	cLeg = LegApprValue;
	cHat = HeadApprValue;
	cBerk = ArmApprValue;
	//cArmor = (Appr3 & 0xF000) >> 12;
	//cLeg   = (Appr3 & 0x0F00) >> 8;
	//cHat   = (Appr3 & 0x00F0) >> 4;
	//cBerk  =  Appr3 & 0x000F;
	switch (OwnerType)
	{
		case 1:
		case 2:
		case 3:
			if ((cArmor == 8) && (cLeg == 5) && (cHat == 9) && (cBerk == 3)) return (1); // Warr elv M
			if ((cArmor == 9) && (cLeg == 6) && (cHat == 10) && (cBerk == 4)) return (1); // Warr ares M
			if ((cArmor == 12) && (cLeg == 7) && (cHat == 13) && (cBerk == 5)) return (1); // Ancient War M
			if ((cArmor == 10) && (cLeg == 5) && (cHat == 11) && (cBerk == 3)) return (2); // Mage elv M
			if ((cArmor == 11) && (cLeg == 6) && (cHat == 12) && (cBerk == 4)) return (2); // Mage ares M
			if ((cArmor == 13) && (cLeg == 7) && (cHat == 14) && (cBerk == 5)) return (2); // Ancient Mage M
			break;
		case 4:
		case 5:
		case 6: // fixed
			if ((cArmor == 9) && (cLeg == 6) && (cHat == 9) && (cBerk == 4)) return (1); //warr elv W
			if ((cArmor == 10) && (cLeg == 7) && (cHat == 10) && (cBerk == 5)) return (1); //warr ares W
			if ((cArmor == 13) && (cLeg == 8) && (cHat == 13) && (cBerk == 6)) return (1); // Ancient War W
			if ((cArmor == 11) && (cLeg == 6) && (cHat == 11) && (cBerk == 4)) return (2); //mage elv W
			if ((cArmor == 12) && (cLeg == 7) && (cHat == 12) && (cBerk == 5)) return (2); //mage ares W
			if ((cArmor == 14) && (cLeg == 8) && (cHat == 14) && (cBerk == 6)) return (2); // Ancient Mage W
			break;
	}
	return 0;
}
/*********************************************************************************************************************
**  void ShowHeldenianVictory( short sSide)				( Snoopy )													**
**  description			: Shows the Heldenian's End window															**
**********************************************************************************************************************/
void helbreath::ShowHeldenianVictory(short sSide)
{
	int i;
	DisableDialogBox(18);
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	switch (m_side)
	{
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
			m_pMsgTextList[3] = new class CMsg(0, "in a tie.", 0);
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
			m_pMsgTextList[3] = new class CMsg(0, "in favor of Aresden.", 0);
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Heldenian holy war has been closed!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Heldenian Holy war ended", 0);
			m_pMsgTextList[3] = new class CMsg(0, "in favor of Elvine.", 0);
			break;
	}
	m_pMsgTextList[4] = new class CMsg(0, " ", 0);

	if (((m_side != 1) && (m_side != 2))   // Player not a normal citizen
		|| (sSide == 0))								// or no winner
	{
		PlaySound('E', 25, 0, 0);
		m_pMsgTextList[5] = new class CMsg(0, " ", 0);
		m_pMsgTextList[6] = new class CMsg(0, " ", 0);
		m_pMsgTextList[7] = new class CMsg(0, " ", 0);
		m_pMsgTextList[8] = new class CMsg(0, " ", 0);
	}
	else
	{
		if (sSide == m_side)
		{
			PlaySound('E', 23, 0, 0);
			PlaySound('C', 21, 0, 0);
			PlaySound('C', 22, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "Congratulations.", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As a victorious citizen,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You will receive a reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "      ", 0);
		}
		else
		{
			PlaySound('E', 24, 0, 0);
			PlaySound('C', 12, 0, 0);
			PlaySound('C', 13, 0, 0);
			m_pMsgTextList[5] = new class CMsg(0, "To our regret", 0);
			m_pMsgTextList[6] = new class CMsg(0, "As a defeated citizen,", 0);
			m_pMsgTextList[7] = new class CMsg(0, "You won't receive any reward.", 0);
			m_pMsgTextList[8] = new class CMsg(0, "     ", 0);
		}
	}
	for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	EnableDialogBox(18, 0, 0, 0);
	DisableDialogBox(36);
	DisableDialogBox(37);
	DisableDialogBox(38);
}

void helbreath::DrawDialogBox_Resurect()
{
	char onButton = m_dialogBoxes[50].OnButton();
	short sX = m_dialogBoxes[50].m_X;
	short sY = m_dialogBoxes[50].m_Y;
	short szX = m_dialogBoxes[50].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	PutAlignedString(sX, sX + szX, sY + 20, DLGBOX_RESURRECT1, 4, 0, 50);
	PutAlignedString(sX, sX + szX, sY + 35, DLGBOX_RESURRECT2, 4, 0, 50);

	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 65, 19);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 65, 18);

	if (onButton == 2)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 65, 3);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 65, 2);
}

void helbreath::DlgBoxClick_Resurect()
{
	char onButton = m_dialogBoxes[50].OnButton();
	if (onButton == 1)
	{   // yes
		bSendCommand(MSGID_REQUEST_RESURRECTPLAYER_YES, 0, 0, 0, 0, 0, 0, 0);
		DisableDialogBox(50);
	}
	else if (onButton == 2)
	{	// no
		bSendCommand(MSGID_REQUEST_RESURRECTPLAYER_NO, 0, 0, 0, 0, 0, 0, 0);
		DisableDialogBox(50);
	}
}

void helbreath::DrawDialogBox_GuildSummons()
{
	char onButton = m_dialogBoxes[49].OnButton();
	short sX = m_dialogBoxes[49].m_X;
	short sY = m_dialogBoxes[49].m_Y;
	short szX = m_dialogBoxes[49].sSizeX;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME1, sX, sY, 2);

	PutAlignedString(sX, sX + szX, sY + 15, DLGBOX_GLDSUMMONS1, 4, 0, 50);
	PutAlignedString(sX, sX + szX, sY + 30, m_dialogBoxes[49].cStr, 40, 225, 50);
	PutAlignedString(sX, sX + szX, sY + 45, DLGBOX_GLDSUMMONS2, 4, 0, 50);


	if (onButton == 1)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 65, 19);
	else
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 30, sY + 65, 18);


	if (onButton == 2)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 65, 3);
	else
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + 170, sY + 65, 2);
}

void helbreath::DlgBoxClick_GuildSummons()
{
	char onButton = m_dialogBoxes[49].OnButton();

	if (onButton == 1)
	{
		// yes
		if (unixtime() - m_dwDamagedTime < 10 * 1000)
		{
			AddEventList(DLGBOXCLICK_GUILDSUMMONS1, CHAT_GM);
		}
		else
		{
			bSendCommand(MSGID_RSPGUILDSUMMONS, 0, 0, true, 0, 0, 0, 0);
			DisableDialogBox(49);
		}
	}
	else if (onButton == 2)
	{
		// no
		bSendCommand(MSGID_RSPGUILDSUMMONS, 0, 0, false, 0, 0, 0, 0);
		DisableDialogBox(49);
	}
}

/*********************************************************************************************************************
**  void 	ResponseHeldenianTeleportList(char *pData)									(  Snoopy )					**
**  description			: Gail's TP																					**
**********************************************************************************************************************/
void helbreath::ResponseHeldenianTeleportList(char * pData)
{
	char * cp;
	int * ip, i;
#ifdef _DEBUG
	AddEventList("Teleport ???", 10);
#endif
	cp = pData + 6;
	ip = (int *)cp;
	m_iTeleportMapCount = *ip;
	cp += 4;
	for (i = 0; i < m_iTeleportMapCount; i++)
	{
		ip = (int *)cp;
		m_stTeleportList[i].iIndex = *ip;
		cp += 4;
		ZeroMemory(m_stTeleportList[i].mapname, sizeof(m_stTeleportList[i].mapname));
		memcpy(m_stTeleportList[i].mapname, cp, 10);
		cp += 10;
		ip = (int *)cp;
		m_stTeleportList[i].iX = *ip;
		cp += 4;
		ip = (int *)cp;
		m_stTeleportList[i].iY = *ip;
		cp += 4;
		ip = (int *)cp;
		m_stTeleportList[i].iCost = *ip;
		cp += 4;
	}
}

/*********************************************************************************************************************
**  void DrawDialogBox_CMDHallMenu()
**  description			: Draw the diag																				**
**********************************************************************************************************************/
void helbreath::DrawDialogBox_CMDHallMenu()
{
	short sX, sY, szX;
	char cTxt[120];

	char onButton = m_dialogBoxes[51].OnButton();
	sX = m_dialogBoxes[51].m_X;
	sY = m_dialogBoxes[51].m_Y;
	szX = m_dialogBoxes[51].sSizeX;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	switch (m_dialogBoxes[51].GetMode())
	{
		case 0: // initial diag
			if (onButton == 1)
				PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL1, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL1, 4, 0, 50);

			if (onButton == 2)
				PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL2, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL2, 4, 0, 50);

			if (onButton == 3)
				PutAlignedString(sX, sX + szX, sY + 120, DRAW_CMDHALL3, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 120, DRAW_CMDHALL3, 4, 0, 50);
			// Angels
			if (onButton == 4)
				PutAlignedString(sX, sX + szX, sY + 145, DRAW_CMDHALL4, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 145, DRAW_CMDHALL4, 4, 0, 50);
			// Dragons
			if (onButton == 5)
				PutAlignedString(sX, sX + szX, sY + 170, DRAW_CMDHALL32, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 170, DRAW_CMDHALL32, 4, 0, 50);
			break;

		case 1: // TP diag
			if (m_iTeleportMapCount > 0)
			{
				for (int i = 0; i < m_iTeleportMapCount; i++)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					GetOfficialMapName(m_stTeleportList[i].mapname, cTxt);
					fmt::format_to(G_cTxt, DRAW_DIALOGBOX_CITYHALL_MENU77, cTxt, m_stTeleportList[i].iCost);

					if (onButton == i + 1)
						PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, 255, 255, 255);
					else
						PutAlignedString(sX, sX + szX, sY + 130 + i * 15, G_cTxt, 250, 250, 0);
				}
			}
			else if (m_iTeleportMapCount == -1)
			{
				PutAlignedString(sX, sX + szX, sY + 125, DRAW_DIALOGBOX_CITYHALL_MENU73, 55, 25, 25);
				PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU74, 55, 25, 25);
			}
			else
			{
				PutAlignedString(sX, sX + szX, sY + 150, DRAW_DIALOGBOX_CITYHALL_MENU76, 55, 25, 25);//"There is no area that you can teleport."
			}
			break;

		case 2: // Soldier diag
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_CMDHALL5, 255, 255, 255);
			if ((m_iConstructionPoint >= 2000) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 1)
					PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL6, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL6, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL6, 65, 65, 65);

			if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 2)
					PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL7, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL7, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL7, 65, 65, 65);

			if ((m_iConstructionPoint >= 1500) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 3)
					PutAlignedString(sX, sX + szX, sY + 120, DRAW_CMDHALL8, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 120, DRAW_CMDHALL8, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 120, DRAW_CMDHALL8, 65, 65, 65);

			if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 4)
					PutAlignedString(sX, sX + szX, sY + 145, DRAW_CMDHALL9, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 145, DRAW_CMDHALL9, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 145, DRAW_CMDHALL9, 65, 65, 65);

			if ((m_iConstructionPoint >= 4000) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 5)
					PutAlignedString(sX, sX + szX, sY + 170, DRAW_CMDHALL10, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 170, DRAW_CMDHALL10, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 170, DRAW_CMDHALL10, 65, 65, 65);

			if ((m_iConstructionPoint >= 3000) && (m_bIsCrusadeMode == false))
			{
				if (onButton == 6)
					PutAlignedString(sX, sX + szX, sY + 195, DRAW_CMDHALL11, 255, 255, 255);
				else PutAlignedString(sX, sX + szX, sY + 195, DRAW_CMDHALL11, 4, 0, 50);
			}
			else PutAlignedString(sX, sX + szX, sY + 195, DRAW_CMDHALL11, 65, 65, 65);

			PutAlignedString(sX, sX + szX, sY + 220, DRAW_CMDHALL12, 4, 0, 50);
			fmt::format_to(G_cTxt, DRAW_CMDHALL13, m_iConstructionPoint);
			PutAlignedString(sX, sX + szX, sY + 250, G_cTxt, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 280, DRAW_CMDHALL14, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 300, DRAW_CMDHALL15, 4, 0, 50);
			break;

		case 3: // Hire a Flag Diag
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_CMDHALL16, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL17, 4, 0, 50);
			if (onButton == 1)
				PutAlignedString(sX, sX + szX, sY + 140, DRAW_CMDHALL18, 255, 255, 255);
			else
				PutAlignedString(sX, sX + szX, sY + 140, DRAW_CMDHALL18, 250, 250, 0);
			break;

		case 4: // Tutelar Angel Diag
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_CMDHALL19, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL20, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL21, 4, 0, 50);
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);// "Item upgrade point : %d"
			PutAlignedString(sX, sX + szX, sY + 140, G_cTxt, 0, 0, 0);

			if (onButton == 1 && (m_iGizonItemUpgradeLeft > 99))
				PutAlignedString(sX, sX + szX, sY + 175, DRAW_CMDHALL22, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 175, DRAW_CMDHALL22, 250, 250, 0);

			if (onButton == 2 && (m_iGizonItemUpgradeLeft > 99))
				PutAlignedString(sX, sX + szX, sY + 200, DRAW_CMDHALL23, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 200, DRAW_CMDHALL23, 250, 250, 0);

			if (onButton == 3 && (m_iGizonItemUpgradeLeft > 99))
				PutAlignedString(sX, sX + szX, sY + 225, DRAW_CMDHALL24, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 225, DRAW_CMDHALL24, 250, 250, 0);

			if (onButton == 4 && (m_iGizonItemUpgradeLeft > 99))
				PutAlignedString(sX, sX + szX, sY + 250, DRAW_CMDHALL25, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 250, DRAW_CMDHALL25, 250, 250, 0);

			break;

		case 5: // Dragons Diag
			PutAlignedString(sX, sX + szX, sY + 45, DRAW_CMDHALL26, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 70, DRAW_CMDHALL27, 4, 0, 50);
			PutAlignedString(sX, sX + szX, sY + 95, DRAW_CMDHALL28, 4, 0, 50);
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_ITEMUPGRADE11, m_iGizonItemUpgradeLeft);// "Item upgrade point : %d"
			PutAlignedString(sX, sX + szX, sY + 140, G_cTxt, 0, 0, 0);

			if (onButton == 1 && (m_iGizonItemUpgradeLeft > 4999))
				PutAlignedString(sX, sX + szX, sY + 175, DRAW_CMDHALL29, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 175, DRAW_CMDHALL29, 250, 250, 0);

			if (onButton == 2 && (m_iGizonItemUpgradeLeft > 4999))
				PutAlignedString(sX, sX + szX, sY + 200, DRAW_CMDHALL30, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 200, DRAW_CMDHALL30, 250, 250, 0);

			if (onButton == 3 && (m_iGizonItemUpgradeLeft > 4999))
				PutAlignedString(sX, sX + szX, sY + 225, DRAW_CMDHALL31, 255, 255, 255);
			else PutAlignedString(sX, sX + szX, sY + 225, DRAW_CMDHALL31, 250, 250, 0);

			break;
	}
}

/*********************************************************************************************************************
**  void DlgBoxClick_CMDHallMenu();											**
**  description			: Response of the player if he accepts resurection or not									**
**********************************************************************************************************************/
void helbreath::DlgBoxClick_CMDHallMenu()
{
	char onButton = m_dialogBoxes[51].OnButton();
	switch (m_dialogBoxes[51].GetMode())
	{
		case 0: // initial diag
			if (onButton == 1)
			{
				m_dialogBoxes[51].SetMode(1); // TP diag
				m_iTeleportMapCount = -1;
				bSendCommand(MSGID_REQUEST_TELEPORT_LIST, 0, 0, 0, 0, 0, "Gail");
				PlaySound('E', 14, 5);
			}
			if (onButton == 2)
			{
				m_dialogBoxes[51].SetMode(2); // Soldier Diag
				PlaySound('E', 14, 5);
			}
			if (onButton == 3
				/*&& (m_iEnemyKillCount >= 3)*/)
			{
				m_dialogBoxes[51].SetMode(3); // Flag Diag
				PlaySound('E', 14, 5);
			}

			if (onButton == 4)
			{
				m_dialogBoxes[51].SetMode(4); // Angel Diag
				PlaySound('E', 14, 5);
			}

			if (onButton == 5)
			{
				m_dialogBoxes[51].SetMode(5); // Dragon Diag
				PlaySound('E', 14, 5);
			}
			break;

		case 1: // TP now
			if (m_iTeleportMapCount > 0 && onButton)
			{
				bSendCommand(MSGID_REQUEST_CHARGED_TELEPORT, 0, 0, m_stTeleportList[onButton - 1].iIndex, 0, 0, 0);
				DisableDialogBox(51);
				return;
			}
			break;

		case 2: // Buy a soldier scroll
			if (onButton == 1
				&& (m_iConstructionPoint >= 2000))// Sorceress
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 875, 1, 2, 3, 4, "Gail", 5);
				PlaySound('E', 14, 5);
			}
			if (onButton == 2
				&& (m_iConstructionPoint >= 3000)) // ATK
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 876, 0, 0, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			if (onButton == 3
				&& (m_iConstructionPoint >= 1500)) // Elf
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 877, 0, 0, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			if (onButton == 4
				&& (m_iConstructionPoint >= 3000)) // DSK
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 878, 0, 0, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			if (onButton == 5
				&& (m_iConstructionPoint >= 4000)) // HBT
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 879, 0, 0, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			if (onButton == 6
				&& (m_iConstructionPoint >= 3000)) // Barbarian
			{
				bSendCommand(MSGID_REQUEST_HELDENIAN_SCROLL, 880, 0, 0, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			break;

		case 3: // Buy a Flag
			if (onButton == 1 && (m_iEnemyKillCount >= 3))
			{
				bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_REQ_GETOCCUPYFLAG, 0, 0, 0, 0, 0, 0);
				PlaySound('E', 14, 5);
			}
			break;

		case 4: // Buy an Angel
			if (onButton && (m_iGizonItemUpgradeLeft >= 100)) // Changed Angel Cost from 5 to 100 xRisenx
			{
				bSendCommand(MSGID_REQUEST_ANGEL, 0, 0, onButton, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			break;

		case 5: // Buy an Dragon
			if (onButton && (m_iGizonItemUpgradeLeft >= 5000))
			{
				bSendCommand(MSGID_REQUEST_ANGEL, 0, 0, onButton, 0, 0, "Gail", 0);
				PlaySound('E', 14, 5);
			}
			break;
	}
}
/*********************************************************************************************************************
**  bool DKGlare(int iWeaponIndex, int iWeaponIndex, int *iWeaponGlare)	( Snoopy )									**
**  description			: test glowing condition for DK set															**
**********************************************************************************************************************/
void helbreath::DKGlare(int iWeaponColor, int iWeaponIndex, int * iWeaponGlare)
{
	if (iWeaponColor != 9) return;
	if (((iWeaponIndex >= SPRID_WEAPON_M + 64 * 14) && (iWeaponIndex < SPRID_WEAPON_M + 64 * 14 + 56)) //msw3
		|| ((iWeaponIndex >= SPRID_WEAPON_W + 64 * 14) && (iWeaponIndex < SPRID_WEAPON_W + 64 * 14 + 56))) //wsw3
	{
		*iWeaponGlare = 3;
	}
	else if (((iWeaponIndex >= SPRID_WEAPON_M + 64 * 37) && (iWeaponIndex < SPRID_WEAPON_M + 64 * 37 + 56)) //MStaff3
		|| ((iWeaponIndex >= SPRID_WEAPON_W + 64 * 37) && (iWeaponIndex < SPRID_WEAPON_W + 64 * 37 + 56)))//WStaff3
	{
		*iWeaponGlare = 2;
	}
}
/*********************************************************************************************************************
**  void DrawDruncncity()	( Snoopy )																				**
**  description			: 	Placeholder for Druncncity effects (nota: bubbles already coded)						**
**********************************************************************************************************************/
void helbreath::DrawDruncncity()
{	//DebugLog("druncncity");
}

/*********************************************************************************************************************
**  void CGame::Abaddon_corpse(int sX, int sY);		( Snoopy )														**
**  description			: Placeholder for abaddon's death lightnings												**
**********************************************************************************************************************/
void helbreath::Abaddon_corpse(int sX, int sY)
{
	int ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir, ir, 1);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir + 2, ir, 2);
	_DrawThunderEffect(sX + 30, 0, sX + 30, sY - 10, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir, ir, 1);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir + 2, ir, 2);
	_DrawThunderEffect(sX - 20, 0, sX - 20, sY - 35, ir - 2, ir, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir, ir, 1);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX - 10, 0, sX - 10, sY + 30, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir, ir, 1);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 50, 0, sX + 50, sY + 35, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir, ir, 1);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 65, 0, sX + 65, sY - 5, ir - 2, ir + 2, 2);
	ir = (rand() % 20) - 10;
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir, ir, 1);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir + 2, ir + 2, 2);
	_DrawThunderEffect(sX + 45, 0, sX + 45, sY - 50, ir - 2, ir + 2, 2);

	for (int x = sX - 50; x <= sX + 100; x += rand() % 35)
		for (int y = sY - 30; y <= sY + 50; y += rand() % 45)
		{
			ir = (rand() % 20) - 10;
			_DrawThunderEffect(x, 0, x, y, ir, ir, 2);
		}
}

/*********************************************************************************************************************
**  void DebugLog(char * cStr)			( Snoopy )																	**
**  description			: writes data into "Debug.txt"																**
**********************************************************************************************************************/
void helbreath::DebugLog(const char * cStr)
{
	FILE * pFile;
	char cBuffer[512];
	SYSTEMTIME SysTime;
	pFile = fopen("Debug.txt", "at");
	if (pFile == 0) return;
	ZeroMemory(cBuffer, sizeof(cBuffer));
	GetLocalTime(&SysTime);
	sprintf(cBuffer, "(%4d:%2d:%2d_%2d:%2d:%2d) - ", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute, SysTime.wSecond);
	strcat(cBuffer, cStr);
	strcat(cBuffer, "\n");
	fwrite(cBuffer, 1, strlen(cBuffer), pFile);
	fclose(pFile);
}

void helbreath::DrawQuestHelper()
{
	char cTemp[21], cTxt[120];
	if (m_stQuest.sQuestType != 0)
	{
		PutString2(530 + 160, 130, QUESTHELPER, 255, 200, 0); // Fixed Quest Details xRisenx

		if (m_stQuest.bIsQuestCompleted)
		{
			PutString2(530 + 160, 154, QUESTHELPERCOMPLETE, 255, 0, 0); // Fixed Quest Details xRisenx
		}
		else
		{
			if (m_stQuest.sX != 0)
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				fmt::format_to(cTxt, "%d,%d Range: %d", m_stQuest.sX, m_stQuest.sY, m_stQuest.sRange);
				PutString2(520 + 160, 142, cTxt, 55, 255, 255); // Fixed Quest Details xRisenx
			}
			else
			{
				ZeroMemory(cTemp, sizeof(cTemp));
				GetNpcName(m_stQuest.sTargetType, cTemp);
				ZeroMemory(cTxt, sizeof(cTxt));
				fmt::format_to(cTxt, "%s: %d/%d", cTemp, (m_stQuest.sTargetCount - m_stQuest.sCurrentCount), m_stQuest.sTargetCount);
				PutString2(530 + 160, 142, cTxt, 55, 255, 255); // Fixed Quest Details xRisenx
			}
		}
	}
}

void helbreath::DrawDialogBox_FriendList()
{
	short sX, sY, szX, szY;
	int y;
	char cTxt[120];
	int nickheight = 16;

	char onButton = m_dialogBoxes[43].OnButton();
	sX = m_dialogBoxes[43].m_X;
	sY = m_dialogBoxes[43].m_Y;
	szX = m_dialogBoxes[43].sSizeX;
	szY = m_dialogBoxes[43].sSizeY;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	PutString_SprFont(sX + 90, sY + 35, MSG_FRIENDSLIST3, 1, 1, 8);
	switch (m_dialogBoxes[43].GetMode())
	{
		case 0:
			int i = 0;
			for (i = 0; i < m_iTotalFriends; i++)
			{
				if (strcmp(friendsList[i].friendName, "") != 0)
				{
					y = sY + 45 + ((i + 1) * nickheight);
					PutString(sX + 25, y, friendsList[i].friendName, Color(255, 0, 0, 0));
					if (friendsList[i].online)
					{
						PutString(sX + 90, y, MSG_FRIENDSLIST4, Color(255, 0, 200, 0));
					}
					else
					{
						PutString(sX + 90, y, MSG_FRIENDSLIST4B, Color(255, 200, 0, 0));
					}
				}
			}
			if (m_iFriendIndex != -1)
			{
				PutString(sX + 25, sY + 45 + ((m_iFriendIndex + 1) * nickheight), friendsList[m_iFriendIndex].friendName, Color(255, 255, 255, 255));
				fmt::format_to(cTxt, MSG_FRIENDSLIST5, friendsList[m_iFriendIndex].friendName);
			}
			else
			{
				fmt::format_to(cTxt, MSG_FRIENDSLIST6);
			}
			m_dialogBoxes[43].sV1 = m_iFriendIndex;
			PutString(sX + 25, sY + 45 + (13 * nickheight), cTxt, Color(255, 0, 0, 0));
			if (onButton == 2)
			{
				PutString(sX + 25, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST7, Color(255, 255, 255, 255));
			}
			else
			{
				PutString(sX + 25, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST7, Color(255, 0, 0, 0));
			}
			if (onButton == 3)
			{
				PutString(sX + 80, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST8, Color(255, 255, 255, 255));
			}
			else
			{
				PutString(sX + 80, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST8, Color(255, 0, 0, 0));
			}
			if (onButton == 4)
			{
				PutString(sX + 140, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST9, Color(255, 255, 255, 255));
			}
			else
			{
				PutString(sX + 140, sY + 45 + (14 * nickheight), MSG_FRIENDSLIST9, Color(255, 0, 0, 0));
			}
			break;
	}
}

void helbreath::DlgBoxClick_FriendList() // 43 - drajwer
{
	short sX, sY, szX, szY;
	int tmp, i;
	char cTxt[100];

	sX = m_dialogBoxes[43].m_X;
	sY = m_dialogBoxes[43].m_Y;
	szX = m_dialogBoxes[43].sSizeX;
	szY = m_dialogBoxes[43].sSizeY;
	short msY = m_stMCursor.sY;

	char onButton = m_dialogBoxes[43].OnButton();
	if (onButton == 1)
	{
		tmp = msY - sY - 45 - 16;
		tmp = tmp / 16;
		if (strcmp(friendsList[tmp].friendName, "") != 0)
		{
			m_iFriendIndex = tmp;
		}
		else
		{
			m_iFriendIndex = -1;
		}
		return;
	}
	if (onButton == 2)
	{
		if (m_iTotalFriends == 12)
		{
			AddEventList(MSG_FRIENDSLIST1, 10);
			return;
		}
		m_bIsGetPointingMode = true;
		m_iPointCommandType = 250;
		PlaySound('E', 14, 5);
		AddEventList(MSG_FRIENDSLIST2, 10); //pointing mode
		return;
	}

	if (m_iFriendIndex == -1) return;

	if (onButton == 3)
	{
		for (i = m_iFriendIndex + 1; i < 13; i++)
		{
			ZeroMemory(friendsList[i - 1].friendName, sizeof(friendsList[i - 1].friendName));
			memcpy(friendsList[i - 1].friendName, friendsList[i].friendName, 10);
			ZeroMemory(friendsList[i].friendName, sizeof(friendsList[i].friendName));
			friendsList[i - 1].online = friendsList[i].online;
		}
		m_iTotalFriends--;
		SaveFriendList();
	}

	if (onButton == 4)
	{
		ZeroMemory(cTxt, sizeof(cTxt));
		fmt::format_to(cTxt, "/to %s", friendsList[m_iFriendIndex].friendName);
		bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, cTxt);
	}
}

void helbreath::SaveFriendList()
{
	char cFn[256]/*, cTemp[255]*/;
	ZeroMemory(cFn, sizeof(cFn));
	if (!player_name.empty()) fmt::format_to(cFn, "data\\shops\\friends\\%s.txt", player_name.c_str());
	FILE * f = fopen(cFn, "w");
	int i;
	char wr[12];
	_mkdir("data\\shops\\friends");
	//_mkdir(cFn);
	for (i = 0; i < m_iTotalFriends; i++)
	{
		ZeroMemory(wr, sizeof(wr));
		fmt::format_to(wr, "%s\n", friendsList[i].friendName);
		fputs(wr, f);
	}
	fclose(f);
}
void helbreath::LoadFriendList()
{
	char buf[1024];
	int konieclinii;
	unsigned long linie = 0;
	//new load by char name
	char cFn[256]/*, cTemp[255]*/;

	ZeroMemory(cFn, sizeof(cFn));
	if (!player_name.empty()) fmt::format_to(cFn, "data\\shops\\friends\\%s.txt", player_name.c_str());
	FILE * f = fopen(cFn, "rt");
	m_iTotalFriends = 0;
	if (f == 0)
	{
		_mkdir("data\\shops\\friends");
		return;
	}
	while (fgets(buf, 1024, f))
	{
		konieclinii = 0;
		int i = strlen(buf);
		if (i > 0 && buf[--i] == '\n')
		{
			buf[i] = 0;
			konieclinii = 1;
			linie++;
		}
		if (linie - 1 < 13)
		{
			strcpy(friendsList[linie - 1].friendName, buf);
			m_iTotalFriends++;
		}
	}
	fclose(f);
}

void helbreath::UpdateFriendsStatus()
{
	if ((G_dwGlobalTime - lastFriendUpdate) < 4000) return;
	lastFriendUpdate = G_dwGlobalTime;
	char namesBuf[255];
	ZeroMemory(namesBuf, sizeof(namesBuf));
	for (int i = 0; i < m_iTotalFriends; i++)
	{
		friendsList[i].updated = false;
		strcat(namesBuf, friendsList[i].friendName);
		strcat(namesBuf, " ");
	}
	bSendCommand(MSGID_REQUEST_UPDATE_FRIENDS, 0, 0, 0, 0, 0, namesBuf);
}

void helbreath::DrawDialogBox_Shop()
{
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	int  i, iTemp;
	char cTemp[255], cStr2[255], cStr3[255];

	int  iCost/*, iDiscountCost, iDiscountRatio*/;

	double dTmp1, dTmp2, dTmp3;
	int  iTotalLines, iPointerLoc;
	bool bFlagStatLow = false;
	bool bFlagRedShown = false;
	double d1, d2, d3;
	Point pointerLoc;

	char onButton = m_dialogBoxes[11].OnButton();
	sX = m_dialogBoxes[11].m_X;
	sY = m_dialogBoxes[11].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 11);

	switch (m_dialogBoxes[11].GetMode())
	{
		case 0:
			iTotalLines = 0;
			for (i = 0; i < MAXMENUITEMS; i++)
				if (m_pItemForSaleList[i] != 0) iTotalLines++;

			pointerLoc = m_dialogBoxes[11].HandleScroll(13, iTotalLines);

			if (iTotalLines > 13)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}

			PutAlignedString(sX + 22, sX + 165, sY + 45, DRAW_DIALOGBOX_SHOP1); // "ITEM"
			PutAlignedString(sX + 23, sX + 166, sY + 45, DRAW_DIALOGBOX_SHOP1);
			PutAlignedString(sX + 153, sX + 250, sY + 45, DRAW_DIALOGBOX_SHOP3);
			PutAlignedString(sX + 154, sX + 251, sY + 45, DRAW_DIALOGBOX_SHOP3);

			for (i = 0; i < 13; i++)
				if (((i + m_dialogBoxes[11].sView) < MAXMENUITEMS) && (m_pItemForSaleList[i + m_dialogBoxes[11].sView] != 0))
				{
					ZeroMemory(cTemp, sizeof(cTemp));
					GetItemName(m_pItemForSaleList[i + m_dialogBoxes[11].sView], cTemp, cStr2, cStr3);
					if (onButton == i + 1)
					{
						PutAlignedString(sX + 10, sX + 190, sY + i * 18 + 65, cTemp, 255, 255, 255);
					}
					else PutAlignedString(sX + 10, sX + 190, sY + i * 18 + 65, cTemp, 4, 0, 50);
				}

			for (i = 0; i < 13; i++)
				if (((i + m_dialogBoxes[11].sView) < MAXMENUITEMS) && (m_pItemForSaleList[i + m_dialogBoxes[11].sView] != 0))
				{
					/*iDiscountRatio = ((m_stat[STAT_CHR] - 10)  / 4) ;
					dTmp1 = (double)iDiscountRatio;
					dTmp2 = dTmp1 / 100.0f;
					dTmp1 = (double)m_pItemForSaleList[i + m_dialogBoxes[11].sView]->m_wPrice;
					dTmp3 = dTmp1 * dTmp2;
					iDiscountCost = (int)dTmp3;
					iCost = (int)(m_pItemForSaleList[i + m_dialogBoxes[11].sView]->m_wPrice * ((100 + m_cDiscount)/100.) );
					iCost = iCost - iDiscountCost;

					if (iCost < (m_pItemForSaleList[i + m_dialogBoxes[11].sView]->m_wPrice/2))
						iCost = (m_pItemForSaleList[i + m_dialogBoxes[11].sView]->m_wPrice/2) - 1;*/

					iCost = (int)(m_pItemForSaleList[i + m_dialogBoxes[11].sView]->m_wPrice * ((100 + m_cDiscount) / 100.));

					ZeroMemory(cTemp, sizeof(cTemp));
					fmt::format_to(cTemp, "%6d", iCost);
					if (onButton == i + 1)
						PutAlignedString(sX + 148, sX + 260, sY + i * 18 + 65, cTemp, 255, 255, 255);
					else	PutAlignedString(sX + 148, sX + 260, sY + i * 18 + 65, cTemp, 4, 0, 50);
				}
			break;

		default:
			m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sSprite]->PutSpriteFast(sX + 62 + 30 - 35, sY + 84 + 30 - 10,
				m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sSpriteFrame, dwTime);

			ZeroMemory(cTemp, sizeof(cTemp));
			GetItemName(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1], cTemp, cStr2, cStr3);

			PutAlignedString(sX + 25, sX + 240, sY + 50, cTemp, 255, 255, 255);
			PutAlignedString(sX + 26, sX + 241, sY + 50, cTemp, 255, 255, 255);

			strcpy(cTemp, DRAW_DIALOGBOX_SHOP3); //"PRICE"
			PutString3(sX + 90, sY + 78 + 30 - 10, cTemp, Color(255, 40, 10, 10));
			strcpy(cTemp, DRAW_DIALOGBOX_SHOP6); // "Weight"
			PutString3(sX + 90, sY + 93 + 30 - 10, cTemp, Color(255, 40, 10, 10));

			/*iDiscountRatio = ((m_stat[STAT_CHR] -10) / 4) ;
			dTmp1 = (double)iDiscountRatio;
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wPrice;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
			iCost = (int)(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wPrice * ((100 +m_cDiscount)/100.) );
			iCost = iCost - iDiscountCost;

			if (iCost < (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wPrice/2))
					iCost = (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wPrice/2) - 1;*/

			iCost = (int)(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wPrice * ((100 + m_cDiscount) / 100.));

			fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP7, iCost);
			//": %d Gold"
			PutString(sX + 140, sY + 98, cTemp, Color(255, 45, 25, 25));

			iTemp = m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100;
			fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP8, iTemp);
			//": %d Stone"
			PutString(sX + 140, sY + 113, cTemp, Color(255, 45, 25, 25));

			switch (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cEquipPos)
			{
				case EQUIPPOS_RHAND:
				case EQUIPPOS_TWOHAND:
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP9);  // Damage
					PutString3(sX + 90, sY + 145, cTemp, Color(255, 40, 10, 10));
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP10); //"Speed(Min.~Max.)"
					PutString3(sX + 40, sY + 175, cTemp, Color(255, 40, 10, 10));

					if (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue3 != 0)
					{
						fmt::format_to(cTemp, ": %dD%d+%d (S-M)", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue1,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue2,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue3);
					}
					else
					{
						fmt::format_to(cTemp, ": %dD%d (S-M)", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue1,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue2);
					}
					PutString(sX + 140, sY + 145, cTemp, Color(255, 45, 25, 25));
					if (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue6 != 0)
					{
						fmt::format_to(cTemp, ": %dD%d+%d (L)", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue4,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue6);
					}
					else
					{
						fmt::format_to(cTemp, ": %dD%d (L)", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue4,
							m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
					}
					PutString(sX + 140, sY + 160, cTemp, Color(255, 45, 25, 25));
					if (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cSpeed == 0)   fmt::format_to(cTemp, ": 0(10~10)");
					else fmt::format_to(cTemp, ": %d(%d ~ %d)", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cSpeed, iTemp, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cSpeed * 13);
					PutString(sX + 140, sY + 175, cTemp, Color(255, 45, 25, 25));

					if ((m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100) > m_stat[STAT_STR])
					{
						fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100));
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25);
						PutAlignedString(sX + 26, sX + 241, sY + 258, cTemp, 195, 25, 25); // *Your STR should be at least %d to use this item."
						bFlagRedShown = true;
					}
					break;

				case EQUIPPOS_LHAND:
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP12); // "Defence"
					PutString3(sX + 90, sY + 145, cTemp, Color(255, 40, 10, 10));
					fmt::format_to(cTemp, ": +%d%", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue1);
					PutString(sX + 140, sY + 145, cTemp, Color(255, 45, 25, 25));
					if ((m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100) > m_stat[STAT_STR])
					{
						fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100));
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25); // "*Your STR should be at least %d to use this item."
						PutAlignedString(sX + 26, sX + 241, sY + 258, cTemp, 195, 25, 25);
						bFlagRedShown = true;
					}
					break;

				case EQUIPPOS_HEAD:
				case EQUIPPOS_BODY:
				case EQUIPPOS_BOOTS:
				case EQUIPPOS_ARMS:
				case EQUIPPOS_PANTS:
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP12); // "Defence"
					PutString3(sX + 90, sY + 145, cTemp, Color(255, 40, 10, 10));
					fmt::format_to(cTemp, ": +%d%", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue1);
					PutString(sX + 140, sY + 145, cTemp, Color(255, 45, 25, 25));
					strcpy(cTemp, DRAW_DIALOGBOX_SHOP28); // "Defence"
					PutString3(sX + 90, sY + 170, cTemp, Color(255, 40, 10, 10));
					fmt::format_to(cTemp, ": +%d%", m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue2);
					PutString(sX + 140, sY + 170, cTemp, Color(255, 45, 25, 25));
					bFlagStatLow = false;
					switch (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue4)
					{
						case 10://"Available for above Str %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP15, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_STR] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;
						case 11: // "Available for above Dex %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP16, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_DEX] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;
						case 12: // "Available for above Vit %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP17, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_VIT] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;
						case 13: // "Available for above Int %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP18, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_INT] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;
						case 14: // "Available for above Mag %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP19, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_MAG] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;
						case 15: // "Available for above Chr %d"
							fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP20, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5);
							if (m_stat[STAT_CHR] >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sItemEffectValue5)
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 45, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 45, 25, 25);
							}
							else
							{
								PutAlignedString(sX + 25, sX + 240, sY + 160, cTemp, 125, 25, 25);
								PutAlignedString(sX + 26, sX + 241, sY + 160, cTemp, 125, 25, 25);
								bFlagStatLow = true; // Means some red msg need to be shown at the bottom
							}
							break;

						default:
							break;
					}
					if ((m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100) > m_stat[STAT_STR])
					{
						fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP11, (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_wWeight / 100));
						PutAlignedString(sX + 25, sX + 240, sY + 288, cTemp, 195, 25, 25);
						PutAlignedString(sX + 26, sX + 241, sY + 288, cTemp, 195, 25, 25); // "*Your STR should be at least %d to use this item."
						bFlagRedShown = true;
					}
					else if (bFlagStatLow == true) // Means some stat is too low
					{
						strcpy(cTemp, DRAW_DIALOGBOX_SHOP21); // "(Warning!) Your stat is too low for this item."
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25);
						PutAlignedString(sX + 26, sX + 241, sY + 258, cTemp, 195, 25, 25);
						bFlagRedShown = true;
					}
					else if ((strstr(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "(M)") != 0)
						&& (m_sPlayerType > 3))
					{
						strcpy(cTemp, DRAW_DIALOGBOX_SHOP22); // "(Warning!) only for male."
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25);
						PutAlignedString(sX + 26, sX + 241, sY + 258, cTemp, 195, 25, 25);
						bFlagRedShown = true;
					}
					else if ((strstr(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "(W)") != 0)
						&& (m_sPlayerType <= 3))
					{
						strcpy(cTemp, DRAW_DIALOGBOX_SHOP23); // "(Warning!) only for female."
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25);
						PutAlignedString(sX + 26, sX + 241, sY + 258, cTemp, 195, 25, 25);
						bFlagRedShown = true;
					}
					break;

				case EQUIPPOS_NONE:
					break;
			}

			if (m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sLevelLimit != 0)
			{
				strcpy(cTemp, DRAW_DIALOGBOX_SHOP24); // "Level"
				if (m_iLevel >= m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sLevelLimit)
				{
					PutString(sX + 90, sY + 190, cTemp, Color(255, 40, 10, 10));
					PutString(sX + 91, sY + 190, cTemp, Color(255, 40, 10, 10));
					fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP25, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sLevelLimit);
					PutString(sX + 140, sY + 190, cTemp, Color(255, 45, 25, 25));// ": above %d"
				}
				else
				{
					PutString(sX + 90, sY + 190, cTemp, Color(255, 40, 10, 10));
					PutString(sX + 91, sY + 190, cTemp, Color(255, 40, 10, 10));
					fmt::format_to(cTemp, DRAW_DIALOGBOX_SHOP25, m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_sLevelLimit);
					PutString(sX + 140, sY + 190, cTemp, Color(255, 125, 25, 25));// ": above %d"
					if (bFlagRedShown == false)
					{
						strcpy(cTemp, DRAW_DIALOGBOX_SHOP26); // "(Warning!) Your level is too low for this item."
						PutAlignedString(sX + 25, sX + 240, sY + 258, cTemp, 195, 25, 25);
						PutAlignedString(sX + 25 + 1, sX + 240 + 1, sY + 258, cTemp, 195, 25, 25);
						bFlagRedShown = true;
					}
				}
			}

			m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 156, sY + 219, 19, dwTime);
			m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 170, sY + 219, 19, dwTime);
			PutString(sX + 123 - 35, sY + 237 - 10, DRAW_DIALOGBOX_SHOP27, Color(255, 40, 10, 10)); // "Quantity:"
			PutString(sX + 124 - 35, sY + 237 - 10, DRAW_DIALOGBOX_SHOP27, Color(255, 40, 10, 10));
			if (iGetTopDialogBoxIndex() == 11 && m_stMCursor.sZ != 0)
			{
				m_dialogBoxes[11].sV3 = m_dialogBoxes[11].sV3 + m_stMCursor.sZ / 60;
				//DIRECTX m_dInput.m_sZ = 0;
			}

			int maxWeight = m_stat[STAT_STR] * 5 + m_iLevel * 5;
			if (strcmp(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "100Arrows") == 0)
			{
				if (m_weight + (m_dialogBoxes[11].sV3 * 10) > maxWeight)
				{
					m_dialogBoxes[11].sV3 = (maxWeight - m_weight) / 10;
				}
				if (m_dialogBoxes[11].sV3 > 99) m_dialogBoxes[11].sV3 = 99;
			}
			else if (strcmp(m_pItemForSaleList[m_dialogBoxes[11].GetMode() - 1]->m_cName, "10Arrows") == 0)
			{
				if (m_weight + m_dialogBoxes[11].sV3 > maxWeight)
				{
					m_dialogBoxes[11].sV3 = (maxWeight - m_weight);
				}
				if (m_dialogBoxes[11].sV3 > 99) m_dialogBoxes[11].sV3 = 99;
			}
			else if (m_dialogBoxes[11].sV3 > (75 - _iGetTotalItemNum())) // Bag Fix xRisenx
				m_dialogBoxes[11].sV3 = (75 - _iGetTotalItemNum()); // Bag Fix xRisenx

			if (m_dialogBoxes[11].sV3 < 1) m_dialogBoxes[11].sV3 = 1;

			if (m_dialogBoxes[11].sV3 >= 10)
			{
				ZeroMemory(cTemp, sizeof(cTemp));
				_itoa(m_dialogBoxes[11].sV3, cTemp, 10);
				cTemp[1] = 0;
				PutString(sX - 35 + 186, sY - 10 + 237, cTemp, Color(255, 40, 10, 10));
				PutString(sX - 35 + 187, sY - 10 + 237, cTemp, Color(255, 40, 10, 10));
				ZeroMemory(cTemp, sizeof(cTemp));
				_itoa(m_dialogBoxes[11].sV3, cTemp, 10);
				PutString(sX - 35 + 200, sY - 10 + 237, (cTemp + 1), Color(255, 40, 10, 10));
				PutString(sX - 35 + 201, sY - 10 + 237, (cTemp + 1), Color(255, 40, 10, 10));
			}
			else
			{
				PutString(sX - 35 + 186, sY - 10 + 237, "0", Color(255, 40, 10, 10));
				PutString(sX - 35 + 187, sY - 10 + 237, "0", Color(255, 40, 10, 10));
				ZeroMemory(cTemp, sizeof(cTemp));
				_itoa(m_dialogBoxes[11].sV3, cTemp, 10);
				PutString(sX - 35 + 200, sY - 10 + 237, (cTemp), Color(255, 40, 10, 10));
				PutString(sX - 35 + 201, sY - 10 + 237, (cTemp), Color(255, 40, 10, 10));
			}
			m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 156, sY + 244, 20, dwTime);
			m_pSprite[SPRID_INTERFACE_ND_GAME2]->PutSpriteFast(sX + 170, sY + 244, 20, dwTime);

			if (onButton == 5)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 31);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + LBTNPOSX, sY + BTNPOSY, 30);

			if (onButton == 6)
				DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 17);
			else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 16);
			break;
	}
}

void helbreath::DrawDialogBox_DKMenuWeapons()
{
	short sX, sY, szX;

	char onButton = m_dialogBoxes[53].OnButton();
	sX = m_dialogBoxes[53].m_X;
	sY = m_dialogBoxes[53].m_Y;
	szX = m_dialogBoxes[53].sSizeX;
	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);

	if (onButton == 1)
		PutAlignedString(sX, sX + szX, sY + 50 + 15 * 0, "Dark Mage Wand", 255, 255, 255);
	else PutAlignedString(sX, sX + szX, sY + 50 + 15 * 0, "Dark Mage Wand", 4, 0, 50);

	if (onButton == 2)
		PutAlignedString(sX, sX + szX, sY + 50 + 15 * 1, "Dark Knight Rapier", 255, 255, 255);
	else PutAlignedString(sX, sX + szX, sY + 50 + 15 * 1, "Dark Knight Rapier", 4, 0, 50);

	if (onButton == 3)
		PutAlignedString(sX, sX + szX, sY + 50 + 15 * 2, "Dark Knight Great Sword", 255, 255, 255);
	else PutAlignedString(sX, sX + szX, sY + 50 + 15 * 2, "Dark Knight Great Sword", 4, 0, 50);

	if (onButton == 4)
		PutAlignedString(sX, sX + szX, sY + 50 + 15 * 3, "Dark Knight Flameberge", 255, 255, 255);
	else PutAlignedString(sX, sX + szX, sY + 50 + 15 * 3, "Dark Knight Flameberge", 4, 0, 50);

	if (onButton == 5)
		DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 1);
	else DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX + RBTNPOSX, sY + BTNPOSY, 0);

}

void helbreath::DlgBoxClick_DKMenuWeapons()
{
	char onButton = m_dialogBoxes[53].OnButton();
	// DK Weapons
	if (onButton == 1 && (m_iLevel >= MAXLEVEL)) // Dark Mage Staff
	{
		bSendCommand(MSGID_REQUEST_DKITEM, 0, 0, 10, 0, 0, "Gail", 0);
		PlaySound('E', 14, 5);
	}
	if (onButton == 2 && (m_iLevel >= MAXLEVEL)) // Dark Knight Rapier
	{
		bSendCommand(MSGID_REQUEST_DKITEM, 0, 0, 11, 0, 0, "Gail", 0);
		PlaySound('E', 14, 5);
	}
	if (onButton == 3 && (m_iLevel >= MAXLEVEL)) // Dark Knight Great Sword
	{
		bSendCommand(MSGID_REQUEST_DKITEM, 0, 0, 12, 0, 0, "Gail", 0);
		PlaySound('E', 14, 5);
	}
	if (onButton == 4 && (m_iLevel >= MAXLEVEL)) // Dark Knight Flameberge
	{
		bSendCommand(MSGID_REQUEST_DKITEM, 0, 0, 13, 0, 0, "Gail", 0);
		PlaySound('E', 14, 5);
	}
	if (onButton == 5)
	{
		PlaySound('E', 14, 5);
		DisableDialogBox(53);
	}
}


void helbreath::LoadMuteList()
{
	char buffer[64];
	char fileLocation[64];

	m_MuteList.clear();
	ZeroMemory(fileLocation, sizeof(fileLocation));
	if (!player_name.empty()) fmt::format_to(fileLocation, "data\\shops\\mutes\\%s.txt", player_name.c_str());
	FILE * f = fopen(fileLocation, "rt");
	if (f == 0)
	{
		_mkdir("data\\shops\\mutes");
		return;
	}
	while (fgets(buffer, 64, f))
	{
		int i = strlen(buffer);
		if (i > 0 && buffer[--i] == '\n')
		{
			buffer[i] = 0;
			m_MuteList.insert(string(buffer));
		}
	}
	fclose(f);
}

void helbreath::SaveMuteList()
{
	char fileLocation[64];

	ZeroMemory(fileLocation, sizeof(fileLocation));
	if (!player_name.empty()) fmt::format_to(fileLocation, "data\\shops\\mutes\\%s.txt", player_name.c_str());
	FILE * f = fopen(fileLocation, "w");
	_mkdir("data\\shops\\mutes");

	for (std::set<string>::iterator it = m_MuteList.begin(); it != m_MuteList.end(); ++it)
	{
		fputs((*it).c_str(), f);
		fputs("\n", f);
	}
	fclose(f);
}

void helbreath::DlgBoxClick_GuideMap()
{
	if (m_bCtrlPressed == false) return;

	short shX;
	short shY;
	int recallPoint = 0;
	int town;
	int range = 25;
	int recallPoints[2][5][2] = {
		{{140,49}, {68,125}, {170,145}, {140,205}, {116,245}}, //Aresden
		{{158,57}, {110,89}, {170,145}, {242,129}, {158,249}} //Elvine
	};

	if (m_bZoomMap)
	{
		shX = m_sPlayerX - 64;
		shY = m_sPlayerY - 64;
		if (shX < 0) shX = 0;
		else if (shX > m_pMapData->m_sMapSizeX - 128) shX = m_pMapData->m_sMapSizeX - 128;
		if (shY < 0) shY = 0;
		else if (shY > m_pMapData->m_sMapSizeY - 128) shY = m_pMapData->m_sMapSizeY - 128;
		shX += m_stMCursor.sX - m_dialogBoxes[9].m_X;
		shY += m_stMCursor.sY - m_dialogBoxes[9].m_Y;
	}
	else
	{
		shX = (m_stMCursor.sX - m_dialogBoxes[9].m_X) * m_pMapData->m_sMapSizeX / 128;
		shY = (m_stMCursor.sY - m_dialogBoxes[9].m_Y) * m_pMapData->m_sMapSizeY / 128;
	}

	if (m_cMapIndex == 11) town = 0;
	else if (m_cMapIndex == 3) town = 1;
	else return;

	for (int i = 0; i < 6; i++)
		if (shX > (recallPoints[town][i][0] - range) && shX < (recallPoints[town][i][0] + range) &&
			shY >(recallPoints[town][i][1] - range) && shY < (recallPoints[town][i][1] + range))
		{
			recallPoint = i + 1;
			break;
		}

	if (recallPoint != 0)
	{
		bSendCommand(MSGID_REQUEST_SETRECALLPNT, 0, 0, recallPoint, 0, 0, 0, 0);
		PlaySound('E', 14, 5);
	}
}

void helbreath::DlgBoxClick_GuildBank()
{
	int i;
	short sX, sY;

	char onButton = m_dialogBoxes[56].OnButton();
	sX = m_dialogBoxes[56].m_X;
	sY = m_dialogBoxes[56].m_Y;

	ItemMapIter it = m_guildBankIt;
	int j = 0;

	switch (m_dialogBoxes[56].GetMode())
	{
		case 0:
			for (i = 0; i < m_dialogBoxes[56].sV1; i++)
			{
				if (onButton == i + 1)
				{
					if (_iGetTotalItemNum() >= 75)
					{ // Bag Fix xRisenx
						AddEventList(DLGBOX_CLICK_BANK1, 10);
						return;
					}

					if (m_iGuildRank == GUILDRANK_NONE || !gldRankPerm[m_iGuildRank].canWithdrawWH)
					{
						AddEventList(DLGBOX_CLICK_BANK2, 10);
						return;
					}

					while (j < i && it != m_guildBankMap.end())
					{
						++it;
						j++;
					}

					if (it == m_guildBankMap.end()) return;

					bSendCommand(MSGID_REQUEST_RETRIEVEITEM_GUILDBANK, 0, 0, (*it).second, 0, 0, 0);
					m_dialogBoxes[56].SetMode(-1);
					PlaySound('E', 56, 5);
				}
			}
			break;
	}
}

void helbreath::DrawDialogBox_GuildBank()
{
	short sX, sY, szX;
	int  iTotalLines;
	double d1, d2, d3;
	char cItemColor, cStr1[64], cStr2[64], cStr3[64];
	bool bFlag = false;
	Point pointerLoc;
	int iPointerLoc;
	char onButton = m_dialogBoxes[56].OnButton();
	sX = m_dialogBoxes[56].m_X;
	sY = m_dialogBoxes[56].m_Y;
	szX = m_dialogBoxes[56].sSizeX - 5;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 2);
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 21);
	ZeroMemory(cStr1, sizeof(cStr1));
	ZeroMemory(cStr2, sizeof(cStr2));
	ZeroMemory(cStr3, sizeof(cStr3));


	ItemMapIter it;
	CItem * item;

	switch (m_dialogBoxes[56].GetMode())
	{
		case -1:
			PutString(sX + 30 + 15, sY + 70, DRAW_DIALOGBOX_BANK1, Color(255, 0, 0, 0));
			PutString(sX + 30 + 15, sY + 85, DRAW_DIALOGBOX_BANK2, Color(255, 0, 0, 0));
			break;

		case 0:
			iTotalLines = m_guildBankMap.size();
			iPointerLoc = 0;
			if (iTotalLines > m_dialogBoxes[56].sV1)
			{
				d1 = (double)m_dialogBoxes[56].sView;
				d2 = (double)(iTotalLines - m_dialogBoxes[56].sV1);
				d3 = (274.0f * d1) / d2;
				iPointerLoc = (int)d3;
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX + 242, sY + iPointerLoc + 35, 7);
			}

			it = m_guildBankIt;
			for (int i = 0; i < m_dialogBoxes[56].sV1 && it != m_guildBankMap.end(); i++, ++it)
			{
				item = (*it).first;
				if (!item) continue;
				if (isItemLoaded == false)
				{
					_LoadItemContents();		// Item Display - ShadowEvil
					isItemLoaded = true;
				}
				std::vector<string> * lines = GetItemName(item, true);
				std::vector<string>::iterator iter = lines->begin(), end = lines->end();
				if (onButton == i + 1)
				{
					bFlag = true;

					if (iter != end)
					{
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), 255, 255, 255);
					}

					uint32_t maxWidth = 0;

					while (iter != end)
					{
						if (iter->size() > maxWidth)
							maxWidth = iter->size();

						++iter;
					}

					//DIRECTX m_DDraw.DrawShadowBox(sX + 70 - 3, sY + 25 - 1, sX + 70 + maxWidth * 5.5, sY + 25 + 13*lines->size());

					iter = lines->begin();

					int iLoc = 0;
					if (iter != end)
					{
						PutString(sX + 70, sY + 25, iter->c_str(), Color(m_itemColor), false, 1);
						iLoc += 13;
						++iter;
					}

					while (iter != end)
					{
						PutString(sX + 70, sY + 25 + iLoc, iter->c_str(), Color(255, 150, 150, 150), false, 1);
						iLoc += 13;
						++iter;
					}

					cItemColor = item->m_ItemColor;
					if (cItemColor == 0)
					{
						m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + item->m_sSprite]->PutSpriteFast(sX + 40, sY + 68, item->m_sSpriteFrame, m_dwCurTime);
					}
					else
					{
						if (item->m_cEquipPos == EQUIPPOS_LHAND
							|| item->m_cEquipPos == EQUIPPOS_RHAND
							|| item->m_cEquipPos == EQUIPPOS_TWOHAND)
						{
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + item->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, item->m_sSpriteFrame,
								m_wWR[cItemColor] - m_wR[0], m_wWG[cItemColor] - m_wG[0], m_wWB[cItemColor] - m_wB[0], m_dwCurTime);
						}
						else
							m_pSprite[SPRID_ITEMPACK_PIVOTPOINT + item->m_sSprite]->PutSpriteRGB(sX + 40, sY + 68, item->m_sSpriteFrame,
								m_wR[cItemColor] - m_wR[0], m_wG[cItemColor] - m_wG[0], m_wB[cItemColor] - m_wB[0], m_dwCurTime);
					}
				}
				else
				{
					if (Color(m_itemColor) != Color(255, 255, 255, 255))
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), Color(m_itemColor));
					else
						PutAlignedString(sX, sX + szX, sY + 110 + i * 15, iter->c_str(), Color(255, 0, 0, 0));
				}
			}

			int32_t oldView = m_dialogBoxes[56].sView;

			if (m_stMCursor.LB != 0 && (iGetTopDialogBoxIndex() == 56) && iTotalLines > m_dialogBoxes[56].sV1)
			{
				if ((m_stMCursor.sX >= sX + 230) && (m_stMCursor.sX <= sX + 260) && (m_stMCursor.sY >= sY + 40) && (m_stMCursor.sY <= sY + 320))
				{
					d1 = (double)(m_stMCursor.sY - (sY + 35));
					d2 = (double)(iTotalLines - m_dialogBoxes[56].sV1);
					d3 = (d1 * d2) / 274.0f;
					m_dialogBoxes[56].sView = (int)(d3 + 0.5);
				}
				else if ((m_stMCursor.sX >= sX + 230) && (m_stMCursor.sX <= sX + 260) && (m_stMCursor.sY > sY + 10) && (m_stMCursor.sY < sY + 40)) m_dialogBoxes[56].sView = 0;
			}
			else m_dialogBoxes[56].bIsScrollSelected = false;
			if (iGetTopDialogBoxIndex() == 56 && m_stMCursor.sZ != 0)
			{
				if (iTotalLines > 50)
					m_dialogBoxes[56].sView = m_dialogBoxes[56].sView - m_stMCursor.sZ / 30;
				else
				{
					if (m_stMCursor.sZ > 0 && m_guildBankIt != m_guildBankMap.begin())
					{
						m_dialogBoxes[56].sView--;
					}
					if (m_stMCursor.sZ < 0 && iTotalLines - m_dialogBoxes[56].sV1 - m_dialogBoxes[56].sView > 0)
					{
						m_dialogBoxes[56].sView++;
					}
				}
				//DIRECTX m_dInput.m_sZ = 0;
			}
			if (iTotalLines > m_dialogBoxes[56].sV1 && m_dialogBoxes[56].sView > iTotalLines - m_dialogBoxes[56].sV1) m_dialogBoxes[56].sView = iTotalLines - m_dialogBoxes[56].sV1;
			if (iTotalLines <= m_dialogBoxes[56].sV1) m_dialogBoxes[56].sView = 0;

			if (m_dialogBoxes[56].sView < 0) m_dialogBoxes[56].sView = 0;


			if (oldView < m_dialogBoxes[56].sView)
			{
				while (oldView != m_dialogBoxes[56].sView)
				{
					oldView++;
					++m_guildBankIt;
				}
			}
			else if (oldView > m_dialogBoxes[56].sView)
			{
				while (oldView != m_dialogBoxes[56].sView)
				{
					oldView--;
					--m_guildBankIt;
				}
			}


			if (bFlag == false)
			{
				PutAlignedString(sX, sX + szX, sY + 45, DRAW_DIALOGBOX_BANK3);
				PutAlignedString(sX, sX + szX, sY + 60, DRAW_DIALOGBOX_BANK4);
				PutAlignedString(sX, sX + szX, sY + 75, DRAW_DIALOGBOX_BANK5);
				fmt::format_to(G_cTxt, DRAW_DIALOGBOX_BANK6, iTotalLines, maxGWHItems[m_guild.m_upgrades[GU_WAREHOUSE]]);
				PutAlignedString(sX, sX + szX, sY + 90, G_cTxt, 255, 255, 255);
			}
			break;
	}
}


void helbreath::bItemDrop_GuildBank()
{
	m_dialogBoxes[39].sV1 = m_stMCursor.sSelectedObjectID;

	if (m_cCommand < 0 || !m_pItemList[m_dialogBoxes[39].sV1] || m_bIsItemDisabled[m_dialogBoxes[39].sV1])
		return;

	if (m_bIsDialogEnabled[DIALOG_QUERYDROPITEMAMOUNT] || m_bIsDialogEnabled[DIALOG_SELLORREPAIRITEM] ||
		m_bIsDialogEnabled[DIALOG_ITEMDROP] ||
		(m_bIsDialogEnabled[DIALOG_NPCACTIONQUERY] &&
			(m_dialogBoxes[DIALOG_NPCACTIONQUERY].GetMode() == 1 || m_dialogBoxes[DIALOG_NPCACTIONQUERY].GetMode() == 2))
		)
	{
		AddEventList(BITEMDROP_SKILLDIALOG1, 10);
		return;
	}

	if ((m_pItemList[m_dialogBoxes[39].sV1]->m_cItemType == ITEMTYPE_CONSUME ||
		m_pItemList[m_dialogBoxes[39].sV1]->m_cItemType == ITEMTYPE_ARROW) &&
		m_pItemList[m_dialogBoxes[39].sV1]->m_dwCount > 1)
	{
		m_dialogBoxes[17].m_X = m_stMCursor.sX - 140;
		m_dialogBoxes[17].m_Y = m_stMCursor.sY - 70;
		if (m_dialogBoxes[17].m_Y < 0) m_dialogBoxes[17].m_Y = 0;

		m_dialogBoxes[17].sV1 = m_sPlayerX + 1;
		m_dialogBoxes[17].sV2 = m_sPlayerY + 1;
		m_dialogBoxes[17].sV3 = 1003;// NPC
		m_dialogBoxes[17].sV4 = m_dialogBoxes[39].sV1;

		ZeroMemory(m_dialogBoxes[17].cStr, sizeof(m_dialogBoxes[17].cStr));
		EnableDialogBox(17, m_dialogBoxes[39].sV1, m_pItemList[m_dialogBoxes[39].sV1]->m_dwCount, 0);
	}
	else
	{
		if (m_guildBankMap.size() < maxGWHItems[m_guild.m_upgrades[GU_WAREHOUSE]])
			bSendCommand(MSGID_COMMAND_COMMON, COMMONTYPE_GIVEITEMTOCHAR, m_dialogBoxes[39].sV1, 1, m_dialogBoxes[39].sV5, m_dialogBoxes[39].sV6, m_pItemList[m_dialogBoxes[39].sV1]->m_cName, m_dialogBoxes[39].sV4); //v1.4
		else
			AddEventList(DLGBOX_CLICK_NPCACTION_QUERY9, 10);
	}
}

void helbreath::ReceiveGuildInfo(char * data)
{
	uint8_t tmpUpgrades[GU_MAX];

	for (int i = 0; i < GU_MAX; i++)
	{
		Pop(data, tmpUpgrades[i]);

		if (m_guild.m_upgrades[i] != -1 && tmpUpgrades[i] > m_guild.m_upgrades[i])
		{
			fmt::format_to(G_cTxt, DRAW_DIALOGBOX_GUILD42, gldUps[i].name.c_str(), tmpUpgrades[i]);
			AddEventList(G_cTxt, CHAT_GM);
		}

		m_guild.m_upgrades[i] = tmpUpgrades[i];
	}

	Pop(data, m_guild.m_gold);
	Pop(data, m_guild.m_maj);
	Pop(data, m_guild.m_cont);

	Pop(data, m_guild.m_captains);
	Pop(data, m_guild.m_raidmasters);
	Pop(data, m_guild.m_huntmasters);

	uint32_t memberCnt;
	Pop(data, memberCnt);

	while (memberCnt > 0)
	{
		char name[11];
		ZeroMemory(name, sizeof(name));
		GuildMember member;
		member.summonTime = 0;
		Pop(data, name, 10);
		Pop(data, member.rank);
		Pop(data, member.map);
		m_guild.AddMember(member, name);
		memberCnt--;
	}
}

void helbreath::ReceiveGuildsmanStatus(char * data)
{
	char name[11];
	ZeroMemory(name, sizeof(name));

	Pop(data, name, 10);

	bool online;
	Pop(data, (uint8_t &)online);

	MemberList::iterator it = m_guild.m_onlineList.find(name);

	char txt[100];
	if (online)
	{
		if (name == player_name)
		{
			GuildMember member;
			Pop(data, member.rank);

			fmt::format_to(txt, GUILD_MEMBERRANKCHANGE,
				GetGuildRankName(m_iGuildRank), GetGuildRankName(member.rank));
			AddEventList(txt, CHAT_GUILD);

			m_iGuildRank = (GuildRank)member.rank;
		}
		else if (it == m_guild.m_onlineList.end())
		{
			GuildMember member;
			Pop(data, member.rank);
			Pop(data, member.map);
			member.summonTime = 0;
			m_guild.AddMember(member, name);
			if (member.rank < GUILDRANK_MAX)
			{
				fmt::format_to(txt, GUILD_MEMBERONLINE, GetGuildRankName(member.rank), name);
				AddEventList(txt, CHAT_GUILD);
			}
		}
		else
		{
			uint8_t newrank;
			Pop(data, (uint8_t &)newrank);
			if ((*it).second.rank != newrank)
			{
				fmt::format_to(txt, GUILD_MEMBERRANKCHANGE2, name, GetGuildRankName((*it).second.rank), GetGuildRankName(newrank));
				AddEventList(txt, CHAT_GUILD);
			}
			(*it).second.rank = newrank;

			Pop(data, (*it).second.map);
		}
	}
	else
	{
		if (it != m_guild.m_onlineList.end())
		{
			fmt::format_to(txt, GUILD_MEMBEROFFLINE, GetGuildRankName((*it).second.rank), name);
			AddEventList(txt, CHAT_GUILD);
			m_guild.RemoveMember(name);
		}
	}
}

void helbreath::InitItemList_GuildBank(char * data)
{
	uint16_t type;
	Pop(data, type);

	if (type == MSGTYPE_REJECT)
	{
		AddEventList(NOTIFY_MSG_HANDLER75);
		AddEventList(NOTIFY_MSG_HANDLER76);
		return;
	}

#ifdef _DEBUG
	AddEventList("Received Guild Bank List");
#endif

	m_guildBankMap.clear();

	uint16_t itemCnt;
	Pop(data, itemCnt);
	Pop(data, m_guildBankVer);

	for (int i = 0; i < itemCnt; i++)
	{
		CItem * item = new CItem;

		memcpy(item->m_cName, data, 20);
		data += 20;

		Pop(data, item->m_dwCount);
		Pop(data, (uint8_t &)item->m_cItemType);
		Pop(data, (uint8_t &)item->m_cEquipPos);
		Pop(data, (uint16_t &)item->m_sLevelLimit);
		Pop(data, (uint8_t &)item->m_cGenderLimit);
		Pop(data, item->m_wCurLifeSpan);
		Pop(data, item->m_wWeight);
		Pop(data, (uint16_t &)item->m_sSprite);
		Pop(data, (uint16_t &)item->m_sSpriteFrame);
		Pop(data, (uint8_t &)item->m_ItemColor);
		Pop(data, (uint16_t &)item->m_sItemSpecEffectValue2);
		Pop(data, item->m_dwAttribute);
		for (int i = 0; i < MAXITEMSOCKETS; i++)
			Pop(data, item->m_sockets[i]);
		Pop(data, item->m_serverPtr);

		item->m_sX = 40;
		item->m_sY = 30;

		m_guildBankMap.insert(std::pair<CItem *, uint32_t>(item, item->m_serverPtr));
	}

	m_guildBankIt = m_guildBankMap.begin();
}

void helbreath::RetrieveItemHandler_GuildBank(char * data)
{
	uint16_t type;
	Pop(data, type);

	if (type == MSGTYPE_REJECT) return;

	uint32_t serverPtr;
	Pop(data, serverPtr);

	uint8_t itemInd;
	Pop(data, itemInd);

	m_guildBankVer++;

	uint32_t m_tmpBankVer;
	Pop(data, m_tmpBankVer);
	if (m_guildBankVer != m_tmpBankVer)
		bSendCommand(MSGID_REQUEST_GUILDBANK);

	m_dialogBoxes[56].SetMode(0);


	ItemMapIter it = m_guildBankMap.begin();

	while (it != m_guildBankMap.end())
	{
		if ((*it).second == serverPtr)
			break;
		++it;
	}

	if (it == m_guildBankMap.end()) return;


	CItem * item = (*it).first;

	char cStr1[64], cStr2[64], cStr3[64];
	GetItemName(item, cStr1, cStr2, cStr3);

	char cTxt[120];
	memset(cTxt, 0, sizeof(cTxt));
	fmt::format_to(cTxt, RETIEVE_ITEM_HANDLER4, cStr1);//""You took out %s."
	AddEventList(cTxt, 10);

	if (it == m_guildBankIt)
	{
		//if(m_stDialogBoxInfo[56].sView > 0)
		//if(m_guildBankIt == m_guildBankMap.begin())
		++m_guildBankIt;
	}

	if (m_pItemList[itemInd] && (item->m_cItemType == ITEMTYPE_CONSUME || item->m_cItemType == ITEMTYPE_ARROW))
	{
		m_guildBankMap.erase(it);
		delete item;
	}
	else
	{
		short nX = 40, nY = 30;

		for (int j = 0; j < MAXITEMS; j++)
		{
			if (m_pItemList[j] && memcmp(m_pItemList[j]->m_cName, cStr1, 20) == 0)
			{
				nX = m_pItemList[j]->m_sX + 1;
				nY = m_pItemList[j]->m_sY + 1;
				break;
			}
		}

		m_pItemList[itemInd] = item;
		m_pItemList[itemInd]->m_sX = nX;
		m_pItemList[itemInd]->m_sY = nY;

		bSendCommand(MSGID_REQUEST_SETITEMPOS, 0, itemInd, nX, nY, 0, 0);

		for (int j = 0; j < MAXITEMS; j++)
		{
			if (m_cItemOrder[j] == -1)
			{
				m_cItemOrder[j] = itemInd;
				break;
			}
		}

		m_bIsItemEquipped[itemInd] = false;
		m_bIsItemDisabled[itemInd] = false;

		m_guildBankMap.erase(it);
	}
}

void helbreath::DrawDialogBox_ExtendedSysMenu()
{
	char onButton = m_dialogBoxes[59].OnButton();
	char menuTxt[64];

	PutString_SprFont(m_dialogBoxes[59].m_X + 120, m_dialogBoxes[59].m_Y + 25, DRAW_EXTENDEDSYSMENU0, 1, 1, 8);

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU1);
	strcat(menuTxt, m_showGrid ? DRAW_ENABLED : DRAW_DISABLED);
	RECT r = m_dialogBoxes[59].GetButton(1);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 1 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU2);
	strcat(menuTxt, m_tabbedNotification ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(2);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 2 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU3);
	strcat(menuTxt, m_ekScreenshot ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(3);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 3 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU4);
	strcat(menuTxt, m_showAllDmg ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(4);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 4 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU5);
	strcat(menuTxt, m_showTimeStamp ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(5);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 5 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU6);
	strcat(menuTxt, m_bigItems ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(6);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 6 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU7);
	strcat(menuTxt, m_windowsKey ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(7);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 7 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU8);
	strcat(menuTxt, m_showTime ? DRAW_ENABLED : DRAW_DISABLED);
	r = m_dialogBoxes[59].GetButton(8);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 8 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU9);
	r = m_dialogBoxes[59].GetButton(9);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 9 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU10);
	r = m_dialogBoxes[59].GetButton(10);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 10 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU11);
	r = m_dialogBoxes[59].GetButton(11);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 11 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

	strcpy(menuTxt, DRAW_EXTENDEDSYSMENU12);
	r = m_dialogBoxes[59].GetButton(12);
	PutAlignedString(r.left, r.right, r.top, menuTxt, onButton == 12 ? Color(255, 255, 255, 255) : Color(255, 4, 0, 50));

}

void helbreath::DlgBoxClick_ExtendedSysMenu()
{
	char onButton = m_dialogBoxes[59].OnButton();

	switch (onButton)
	{
		case 1:
			m_showGrid = !m_showGrid;
			break;

		case 2:
			m_tabbedNotification = !m_tabbedNotification;
			if (m_tabbedNotification)
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND18, 10);
			else
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND19, 10);
			break;

		case 3:
			m_ekScreenshot = !m_ekScreenshot;
			if (m_ekScreenshot)
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND16, 10);
			else
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND17, 10);
			break;

		case 4:
			m_showAllDmg = !m_showAllDmg;
			if (m_showAllDmg)
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND12, 10);
			else
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND13, 10);
			break;

		case 5:
			m_showTimeStamp = !m_showTimeStamp;
			if (m_showTimeStamp)
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND10, 10);
			else
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND11, 10);
			break;

		case 6:
			m_bigItems = !m_bigItems;
			if (m_bigItems)
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND14, 10);
			else
				AddEventList(BCHECK_LOCAL_CHAT_COMMAND15, 10);
			break;

		case 7:
			m_windowsKey = !m_windowsKey;
			//SetKeyboardHook(!m_windowsKey);
			break;

		case 8:
			m_showTime = !m_showTime;
			break;

		case 9:
			LoadFriendList();
			UpdateFriendsStatus();
			EnableDialogBox(43, 0, 0, 0);
			break;

		case 10:
			if (m_bIsDialogEnabled[60])  DisableDialogBox(60);
			else EnableDialogBox(60, 0, 0, 0);
			break;

		case 11:
			bSendCommand(MSGID_COMMAND_CHATMSG, 0, 0, 0, 0, 0, "/afk");
			break;

		case 12:
			m_bShowFPS = !m_bShowFPS;
			break;
	}
}

void helbreath::DrawDialogBox_MuteList()
{
	char onButton = m_dialogBoxes[60].OnButton();
	char playerTxt[32];
	int mutes = 0;
	int overButton;
	const int maxShown = 15;

	short sX = m_dialogBoxes[60].m_X;
	short sY = m_dialogBoxes[60].m_Y;

	PutString_SprFont(sX + 98, sY + 36, DRAW_MUTELIST, 1, 1, 8);

	for (std::set<string>::iterator it = m_MuteList.begin(); it != m_MuteList.end(); ++it)
	{
		mutes++;

		if (mutes > m_dialogBoxes[60].sView &&
			mutes < m_dialogBoxes[60].sView + maxShown)
		{
			overButton = mutes + 3 - m_dialogBoxes[60].sView;
			//uncomment 			PutAlignedString(&m_dialogBoxes[60].GetButton(overButton), it->c_str(), (onButton == overButton) ?Color(255,255,255,255) :Color(255,0,0,0));
		}
	}

	fmt::format_to(playerTxt, MSG_FRIENDSLIST5, m_dialogBoxes[60].cStr);
	PutString(sX + 30, m_dialogBoxes[60].ButtonY(2) - 15, playerTxt, Color(255, 0, 0, 0));

	//uncomment 	PutAlignedString(&m_dialogBoxes[60].GetButton(2), DRAW_MUTELIST1, onButton == 2 ?Color(255,255,255,255) :Color(255,0,0,0));

	Point pointerLoc = m_dialogBoxes[60].HandleScroll(maxShown, mutes);
	if (mutes > maxShown)
	{
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
		DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
	}
}

void helbreath::DlgBoxClick_MuteList()
{
	char onButton = m_dialogBoxes[60].OnButton();
	const int maxShown = 15;
	int mutes = 0;
	char playerTxt[128];

	for (std::set<string>::iterator it = m_MuteList.begin(); it != m_MuteList.end(); ++it)
	{
		mutes++;

		if (onButton == mutes + 3 - m_dialogBoxes[60].sView)
		{
			strcpy(m_dialogBoxes[60].cStr, it->c_str());
			break;
		}
	}

	if (onButton == 2)
	{
		if (m_MuteList.erase(m_dialogBoxes[60].cStr))
		{
			fmt::format_to(playerTxt, BCHECK_LOCAL_CHAT_COMMAND1, m_dialogBoxes[60].cStr);
			AddEventList(playerTxt, 10);
			SaveMuteList();
			m_dialogBoxes[60].cStr[0] = '\0';
		}
	}
}

void helbreath::ClearPartyMembers()
{
	for (std::vector<partyMember *>::iterator it = m_stPartyMember.begin(); it < m_stPartyMember.end();)
	{
		delete * it;
		it = m_stPartyMember.erase(it);
	}
}

void helbreath::ResponseQuestList(char * pData)
{
	char * cp;
	int * ip, i;
#ifdef _DEBUG
	AddEventList("Quest List?", 10);
#endif
	cp = pData + 6;

	ip = (int *)cp;
	m_iQuestCount = *ip;
	cp += 4;

	for (i = 0; i < m_iQuestCount; i++)
	{
		ip = (int *)cp;
		m_stQuestList[i].iIndex = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].Type = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].TargetType = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].MaxCount = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].RewardAmount = *ip;
		cp += 8;

		ip = (int *)cp;
		m_stQuestList[i].Contribution = *ip;
		cp += 4;

		ZeroMemory(m_stQuestList[i].TargetName, sizeof(m_stQuestList[i].TargetName));
		memcpy(m_stQuestList[i].TargetName, cp, 20);
		cp += 20;

		ip = (int *)cp;
		m_stQuestList[i].sX = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].sY = *ip;
		cp += 4;

		ip = (int *)cp;
		m_stQuestList[i].Range = *ip;
		cp += 4;
	}
}

void helbreath::DrawDialogBox_QuestList()
{
	short sX, sY;
	char cTemp[255], cTemp2[255], cTemp3[255], cTargetName[21], cNpcName[21];
	Point pointerLoc;
	Color color;

	char onButton = m_dialogBoxes[61].OnButton();
	sX = m_dialogBoxes[61].m_X;
	sY = m_dialogBoxes[61].m_Y;

	switch (m_dialogBoxes[61].GetMode())
	{
		case 0:
			if (!m_stQuest.bIsQuestCompleted)
			{
				if (m_stQuest.sQuestType == 0)
				{
					PutAlignedString(sX, sX + 90, sY + 30, "Find", 255, 255, 255);
					PutAlignedString(sX, sX + 300, sY + 30, "Location", 255, 255, 255);
					PutAlignedString(sX, sX + 435, sY + 30, "contri", 255, 255, 255);

					pointerLoc = m_dialogBoxes[61].HandleScroll(17, m_iQuestCount);

					if (m_iQuestCount > 17)
					{
						DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 3);
						DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
					}

					for (int i = 0; i < 17; i++)
					{
						if (i + m_dialogBoxes[61].sView < m_iQuestCount)
						{
							ZeroMemory(cNpcName, sizeof(cNpcName));
							GetNpcName(m_stQuestList[i + m_dialogBoxes[61].sView].TargetType, cNpcName);
							ZeroMemory(cTargetName, sizeof(cTargetName));
							GetOfficialMapName(m_stQuestList[i + m_dialogBoxes[61].sView].TargetName, cTargetName);

							if (m_stQuestList[i + m_dialogBoxes[61].sView].sX != 0)
							{
								ZeroMemory(cTemp, sizeof(cTemp));
								fmt::format_to(cTemp, "%s", cTargetName);
								m_Misc.ReplaceString(cTemp, '-', ' ');

								ZeroMemory(cTemp2, sizeof(cTemp2));
								fmt::format_to(cTemp2, "%3d,%3d Range:%2d", m_stQuestList[i + m_dialogBoxes[61].sView].sX, m_stQuestList[i + m_dialogBoxes[61].sView].sY, m_stQuestList[i + m_dialogBoxes[61].sView].Range);

								ZeroMemory(cTemp3, sizeof(cTemp3));
								fmt::format_to(cTemp3, "%d", m_stQuestList[i + m_dialogBoxes[61].sView].Contribution);
							}
							else
							{
								ZeroMemory(cTemp, sizeof(cTemp));
								fmt::format_to(cTemp, "%d %s", m_stQuestList[i + m_dialogBoxes[61].sView].MaxCount, cNpcName);
								m_Misc.ReplaceString(cTemp, '-', ' ');

								ZeroMemory(cTemp2, sizeof(cTemp2));
								fmt::format_to(cTemp2, "%s", cTargetName);
								m_Misc.ReplaceString(cTemp2, '-', ' ');

								ZeroMemory(cTemp3, sizeof(cTemp3));
								fmt::format_to(cTemp3, "%d", m_stQuestList[i + m_dialogBoxes[61].sView].Contribution);
							}

							if (onButton == i + 1)
								color = Color(255, 255, 255);
							else color = Color(255, 4, 0, 50);

							PutString(sX + 20, sY + 45 + i * 15, cTemp, color);
							PutString(sX + 123, sY + 45 + i * 15, cTemp2, color);
							PutString(sX + 215, sY + 45 + i * 15, cTemp3, color);
						}
					}

				}
				else
				{
					PutAlignedString(sX, sX + 250, sY + 125, DRAW_DIALOGBOX_QUESTLIST_MENU1, 55, 25, 25);
					PutAlignedString(sX, sX + 250, sY + 140, DRAW_DIALOGBOX_QUESTLIST_MENU2, 55, 25, 25);
				}
			}
			else
			{
				PutAlignedString(sX, sX + 255, sY + 125, DRAW_DIALOGBOX_QUESTLIST_MENU3, 55, 25, 25);
				PutAlignedString(sX, sX + 250, sY + 140, DRAW_DIALOGBOX_QUESTLIST_MENU4, 55, 25, 25);
			}
			break;
	}
}

void helbreath::DlgBoxClick_QuestList()
{
	char onButton = m_dialogBoxes[61].OnButton();

	if (m_iQuestCount > 0 && onButton && !m_stQuest.bIsQuestCompleted)
	{
		bSendCommand(MSGID_REQUEST_ACCEPT_QUEST, 0, 0, m_stQuestList[(onButton - 1) + m_dialogBoxes[61].sView].iIndex, 0, 0, 0);
		DisableDialogBox(61);
		DisableDialogBox(13);
		return;
	}
}
void helbreath::ShowSoccerVictory(short sSide)
{
	int i;
	DisableDialogBox(18);
	for (i = 0; i < TEXTDLGMAXLINES; i++)
	{
		if (m_pMsgTextList[i] != 0)
			delete m_pMsgTextList[i];
		m_pMsgTextList[i] = 0;
	}

	switch (m_side)
	{
		case 0:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Soccer event Has Finished!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Soccer event has finished in a tie", 0);
			break;
		case 1:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Soccer event Has Finished!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Soccer event has finished. Aresden Wins!", 0);
			break;
		case 2:
			PlaySound('E', 25, 0, 0);
			m_pMsgTextList[0] = new class CMsg(0, "Soccer event Has Finished!", 0);
			m_pMsgTextList[1] = new class CMsg(0, " ", 0);
			m_pMsgTextList[2] = new class CMsg(0, "Soccer event has finished. Elvine Wins!", 0);
			break;
	}
	m_pMsgTextList[3] = new class CMsg(0, " ", 0);

	if (sSide == m_side)
	{
		PlaySound('E', 23, 0, 0);
		PlaySound('C', 21, 0, 0);
		PlaySound('C', 22, 0, 0);
		m_pMsgTextList[4] = new class CMsg(0, "Congratulations.", 0);
		m_pMsgTextList[5] = new class CMsg(0, "As a victorious citizen,", 0);
		m_pMsgTextList[6] = new class CMsg(0, "You'r town will receive a reward.", 0);
		m_pMsgTextList[7] = new class CMsg(0, "      ", 0);
	}
	else
	{
		PlaySound('E', 24, 0, 0);
		PlaySound('C', 12, 0, 0);
		PlaySound('C', 13, 0, 0);
		m_pMsgTextList[4] = new class CMsg(0, "To our regret", 0);
		m_pMsgTextList[5] = new class CMsg(0, "As a defeated citizen,", 0);
		m_pMsgTextList[6] = new class CMsg(0, "You'r town won't receive any reward.", 0);
		m_pMsgTextList[7] = new class CMsg(0, "     ", 0);
	}
	for (i = 9; i < 18; i++)
		m_pMsgTextList[i] = new class CMsg(0, " ", 0);
	EnableDialogBox(18, 0, 0, 0);
}

void helbreath::DrawSoccerInfo()
{
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	fmt::format_to(G_cTxt, "%10s Goals %2d Out Of 20", sideName[ARESDEN], m_SoccerAresdenGoals);
	PutString_SprFont3(10, 155, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
	ZeroMemory(G_cTxt, sizeof(G_cTxt));
	fmt::format_to(G_cTxt, "%10s Goals %2d Out Of 20", sideName[ELVINE], m_SoccerElvineGoals);
	PutString_SprFont3(13, 170, G_cTxt, m_wR[14] * 4, m_wG[14] * 4, m_wB[14] * 4, true, 2);
}

#ifdef TitleClient
bool helbreath::FindTitleName(char * pName, int * ipIndex)
{
	int i, iRet = 0;
	//DWORD dwTmpTime;// commented, not used
	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		if (memcmp(m_stTitles[i].cCharName, pName, 10) == 0)
		{
			// if char exists in list of structs, then its been requested before

			// we do not say false here because when someone changes their title,
			// then the are de-referenced and have to be requested again because
			// their char name does not exist!

			m_stTitles[i].dwRefTime = m_dwCurTime;
			*ipIndex = i;
			return true;
		}
	}

	// if the char name doesnt exist.... create a new entry, set it as "NONE" for title.
	// after we return false, it will request the title anyway!

	// the ClearPlayerTitle method is performed if somebody changed their title. This clears
	// thier CharName from the struct which in turns makes this method return false again.

	//dwTmpTime = m_stTitles[0].dwRefTime;//besk commented, not used
	//BESK: we arent creating a new entry here, we are looking for a pre-existing entry with cCharName "NONE"
	//		after we find one, we set its cCharName as pName and cSubject as "NONE", and we return its index
	for (i = 0; i < MAXGUILDNAMES; i++)
	{
		if (strcmp(m_stTitles[i].cCharName, "NONE") == 0)
		{
			iRet = i;
			break;
		}
	}
	//BESK: what happens if we get here and we never found an empty index? we are then overwriting the first m_stTitles[] entry
	ZeroMemory(m_stTitles[iRet].cCharName, sizeof(m_stTitles[iRet].cCharName));
	memcpy(m_stTitles[iRet].cCharName, pName, 10);//BESK: cCharName is 12 bytes, why? if names are only 10...

	ZeroMemory(m_stTitles[iRet].cSubject, sizeof(m_stTitles[iRet].cSubject));
	memcpy(m_stTitles[iRet].cSubject, "NONE", 4);

	m_stTitles[iRet].dwRefTime = m_dwCurTime;
	m_stTitles[iRet].iCurrentNo = -1;

	*ipIndex = iRet;
	return false;
}

/*
void CGame::DrawDialogBox_Skill()
{
 short sX, sY;
 int  iTotalLines, iPointerLoc;
 char cTemp[255], cTemp2[255];
 double d1,d2,d3;
 Point pointerLoc;

	char onButton = m_dialogBoxes[15].OnButton();
	sX = m_dialogBoxes[15].m_X;
	sY = m_dialogBoxes[15].m_Y;

	//DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 0); // Normal Dialog
	//DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 1); // Skill Dialog Title Bar

	switch (m_dialogBoxes[15].GetMode()) {
	case 0:
		for (int line=0, skillIndex=0; line < 17;skillIndex++)
		if (line < MAXSKILLTYPE && m_pSkillCfgList[skillIndex+m_dialogBoxes[15].sView])
		{
			ZeroMemory(cTemp, sizeof(cTemp));
			fmt::format_to(cTemp, "%s", m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_cName);
			m_Misc.ReplaceString(cTemp, '-', ' ');
			ZeroMemory(cTemp2, sizeof(cTemp2));
			fmt::format_to(cTemp2, "%3d%%", m_pSkillCfgList[skillIndex + m_dialogBoxes[15].sView]->m_iLevel);

			COLORREF color =Color(255,5,5,5);
			if(m_pSkillCfgList[ skillIndex+m_dialogBoxes[15].sView ]->m_bIsUseable
				&& m_pSkillCfgList[ skillIndex+m_dialogBoxes[15].sView ]->m_iLevel != 0)
				{
				if (onButton == line + 1)
				{
					color =Color(255,255,255,255);
				}
			else
				{
					color =Color(255,34,30,120);
				}
			}

			PutString(sX + 30, sY + 45 + line*15, cTemp, color);
			PutString(sX + 183, sY + 45 + line*15, cTemp2, color);

			if (m_iDownSkillIndex == (skillIndex + m_dialogBoxes[15].sView))
				 m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutTransSpriteRGB(sX + 215, sY + 47 + line*15, 21, 50,50,50, m_dwTime);
			else m_pSprite[SPRID_INTERFACE_ADDINTERFACE]->PutSpriteFast(sX + 215, sY + 47 + line*15, 20, m_dwTime);
			line++;
		}

		iTotalLines = 0;
		for (int i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillCfgList[i] != NULL) iTotalLines++;

		pointerLoc = m_dialogBoxes[15].HandleScroll(17, iTotalLines);

		if (iTotalLines > 17)
		{
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
			DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
		}

		break;
	}
}
*/

void helbreath::DrawDialogBox_Titles()
{
	short sX, sY;
	uint64_t dwTime = m_dwCurTime;
	int  i, iTemp;
	char cTemp[255], cStr2[255], cStr3[255], cTemp2[256];
	int  iCurr, iNext;

	double dTmp1, dTmp2, dTmp3;
	int  iTotalLines;
	bool bFlagStatLow = false;
	bool bFlagRedShown = false;
	double d1, d2, d3;
	Point pointerLoc;

	char onButton = m_dialogBoxes[63].OnButton();
	sX = m_dialogBoxes[63].m_X;
	sY = m_dialogBoxes[63].m_Y;

	DrawNewDialogBox(SPRID_INTERFACE_ND_TEXT, sX, sY, 23);
	//PutString_SprFont(sX+100,sY+35,"Titles",7,0,0); // previously 1,1,8

	switch (m_dialogBoxes[63].GetMode())
	{
		case 0:
			iTotalLines = 0;
			for (i = 0; i < 50; i++)
			{
				if (m_pTitles[i] != 0) iTotalLines++;
			}

			pointerLoc = m_dialogBoxes[63].HandleScroll(14, iTotalLines);

			if (iTotalLines > 14)
			{
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, sX, sY, 1);
				DrawNewDialogBox(SPRID_INTERFACE_ND_GAME2, pointerLoc.x, pointerLoc.y, 7);
			}
			if (iTotalLines != 0)
			{
				for (int line = 0, TitleIndex = 0; line < 14; line++)
				{
					if (line < iTotalLines /*&& m_pTitles[TitleIndex+m_dialogBoxes[63].sView]*/)
					{
						ZeroMemory(cTemp, sizeof(cTemp));
						ZeroMemory(cTemp2, sizeof(cTemp2));
						GetTitleName(m_pTitles[TitleIndex + m_dialogBoxes[63].sView]->m_cSubject, m_pTitles[TitleIndex + m_dialogBoxes[63].sView]->m_iRank, cTemp2);
						m_Misc.ReplaceString(cTemp, '-', ' ');
						memcpy(cTemp, cTemp2, 23); // shorten the string to 23 characters

						if ((TitleIndex + m_dialogBoxes[63].sView) == m_iTitleIndex)// Changed from 53 to 60 xRisenx
						{
							PutString2(sX + 25, sY + TitleIndex * 18 + 65 - 30, cTemp, 255, 255, 204);
						}
						else
						{
							if ((m_stMCursor.sX >= sX + 20) && (m_stMCursor.sX <= sX + 220) && (m_stMCursor.sY >= sY + TitleIndex * 18 + 65 - 30) && (m_stMCursor.sY <= sY + TitleIndex * 18 + 79 - 30))
							{
								PutString2(sX + 25, sY + TitleIndex * 18 + 65 - 30, cTemp, 255, 255, 255);
							}
							else
							{
								PutString2(sX + 25, sY + TitleIndex * 18 + 65 - 30, cTemp, 128, 128, 128);
							}
						}

						iCurr = (int)(m_pTitles[TitleIndex + m_dialogBoxes[63].sView]->m_iCurrentNo);

						iNext = 99999;
						if (m_pTitles[TitleIndex + m_dialogBoxes[63].sView] != 0)// Changed from 53 to 60 xRisenx
						{
							iNext = m_pTitles[TitleIndex + m_dialogBoxes[63].sView]->m_iNextRankPoints;// Changed from 53 to 60 xRisenx
						}

						ZeroMemory(cTemp, sizeof(cTemp));
						fmt::format_to(cTemp, "(%d/%d)", iCurr, iNext);

						if ((TitleIndex + m_dialogBoxes[63].sView) == m_iTitleIndex)// Changed from 53 to 60 xRisenx
						{
							PutString2(sX + 145, sY + TitleIndex * 18 + 65 - 30, cTemp, 255, 255, 204);
						}
						else
						{
							if ((m_stMCursor.sX >= sX + 20) && (m_stMCursor.sX <= sX + 230) && (m_stMCursor.sY >= sY + TitleIndex * 18 + 65 - 30) && (m_stMCursor.sY <= sY + TitleIndex * 18 + 79 - 30))
							{
								PutString2(sX + 145, sY + TitleIndex * 18 + 65 - 30, cTemp, 255, 255, 255);
							}
							else
							{
								PutString2(sX + 145, sY + TitleIndex * 18 + 65 - 30, cTemp, 128, 128, 128);
							}
						}
						TitleIndex++;
					}
				}
			}
			// Clear Title
			if (m_iTitleIndex == -1)
			{
				PutString2(sX + 25, sY + 45 + (14 * 18), "Clear Title", 128, 128, 128); // No title choosen
				//DrawNewDialogBox(SPRID_INTERFACE_ND_BUTTON, sX+, sY +225, 22);
			}
			else
			{
				if ((m_stMCursor.sX >= sX + 20) && (m_stMCursor.sX <= sX + 82) && (m_stMCursor.sY >= sY + 299) && (m_stMCursor.sY < sY + 312))
				{
					PutString2(sX + 25, sY + 45 + (14 * 18), "Clear Title", 7, 0, 0); // Super Black when title is choosen and mouse is there
				}
				else
				{
					PutString2(sX + 25, sY + 45 + (14 * 18), "Clear Title", 255, 255, 255); // White when title is choosen and mouse not there
				}
			}

			// Refresh Button
			if ((m_dwCurTime - m_dwReqTitlesTime) > 2000)
			{
				if ((m_stMCursor.sX >= sX + 89) && (m_stMCursor.sX <= sX + 139) && (m_stMCursor.sY >= sY + 299) && (m_stMCursor.sY < sY + 312))
				{
					PutString2(sX + 95, sY + 45 + (14 * 18), "Refresh", 255, 255, 255); // White when mouse is there without pressing 
				}
				else
				{
					PutString2(sX + 95, sY + 45 + (14 * 18), "Refresh", 128, 128, 128); // Gray when mouse is not there without pressing 
				}
			}
			else
			{
				PutString2(sX + 95, sY + 45 + (14 * 18), "Refresh", 65, 65, 65); // Grey & Black when Pressed
			}

			/*		// Choose Button
					if(m_iTitleIndex == -1)
					{
						PutString2(sX+150,sY+45+(14*18),"Choose", 128,128,128); // No title choosen
					}
					else
					{
						if ((m_stMCursor.sX>=sX+144) && (m_stMCursor.sX<=sX+192) && (m_stMCursor.sY>=sY+299) && (m_stMCursor.sY<sY+312))
						{
							PutString2(sX+150,sY+45+(14*18),"Choose", 7,0,0); // Super Black when title is choosen and mouse is there
						}
						else {
							PutString2(sX+150,sY+45+(14*18),"Choose", 255,255,255); // White when title is choosen and mouse not there
						}
					}*/

					// Close Button
			if ((m_stMCursor.sX > sX + 194) && (m_stMCursor.sX < sX + 233) && (m_stMCursor.sY >= sY + 299) && (m_stMCursor.sY < sY + 312))
			{
				PutString2(sX + 200, sY + 45 + (14 * 18), "Close", 255, 255, 255); // White when mouse is there without pressing
			}
			else
			{
				PutString2(sX + 200, sY + 45 + (14 * 18), "Close", 128, 128, 128); // Grey when mouse is not there
			}
			break;

		default:
			break;
	}
}

void helbreath::DlgBoxClick_Titles()
{
	int i;
	short sX, sY, szX, szY;
	char cTemp[21];
	sX = m_dialogBoxes[63].m_X;
	sY = m_dialogBoxes[63].m_Y;
	szX = m_dialogBoxes[63].sSizeX;
	szY = m_dialogBoxes[63].sSizeY;
	char onButton = m_dialogBoxes[63].OnButton();

	for (i = 0; i < 14; i++)
		//if (onButton == 1) {
		if ((m_stMCursor.sX >= sX + 20) && (m_stMCursor.sX <= sX + 220) && (m_stMCursor.sY >= sY + i * 18 + 65 - 30) && (m_stMCursor.sY <= sY + i * 18 + 79 - 30))
		{
			if (m_pTitles[m_dialogBoxes[63].sView + i] != 0)
			{
				PlaySound('E', 14, 5);
				m_iTitleIndex = (m_dialogBoxes[63].sView + i);
				bSendCommand(MSGID_SETTITLE, 0, 0, m_pTitles[m_iTitleIndex]->m_iServerTitleIndex, 0, 0, 0);
				fmt::format_to(G_cTxt, "You have chosen \'%s Lvl.%d\' as your title", m_pTitles[m_iTitleIndex]->m_cSubject, m_pTitles[m_iTitleIndex]->m_iRank);
				AddEventList(G_cTxt, 10);
			}
			return;
		}

	// Refresh Monster Count
	if ((m_stMCursor.sX > sX + 95) && (m_stMCursor.sX < sX + 95 + 40) && (m_stMCursor.sY > sY + 45 + 14 * 18) && (m_stMCursor.sY < sY + 45 + 15 * 18))
		//if (onButton == 2)
	{
		if ((m_dwCurTime - m_dwReqTitlesTime) > 2000)
		{
			bSendCommand(MSGID_REQUEST_TITLES, 0, 0, 0, 0, 0, 0);
			m_dwReqTitlesTime = m_dwCurTime;
			m_cCommandCount--;
		}
	}

	/*	// Choose button
		if ((m_stMCursor.sX>sX+150) && (m_stMCursor.sX<sX+150+40) && (m_stMCursor.sY>sY+45+14*18) && (m_stMCursor.sY<sY+45+15*18))
		//if (onButton == 3)
		{
			if(m_iTitleIndex == -1)
			{
				AddEventList("Your title has not been choosen.", 10);
			}
			else
			{
				//DisableDialogBox(63); I'd rather not disable the dialog box. Leave that up to the user.
			}
		}*/

		// Close button
	if ((m_stMCursor.sX > sX + 200) && (m_stMCursor.sX < sX + 200 + 35) && (m_stMCursor.sY > sY + 45 + 14 * 18) && (m_stMCursor.sY < sY + 45 + 15 * 18))
		//if (onButton == 4)
	{
		DisableDialogBox(63);
	}

	// Clear Title
	if ((m_stMCursor.sX > sX + 25) && (m_stMCursor.sX < sX + 25 + 55) && (m_stMCursor.sY > sY + 45 + 14 * 18) && (m_stMCursor.sY < sY + 45 + 15 * 18))
		//if (onButton == 5)
	{
		PlaySound('E', 14, 5);
		m_iTitleIndex = -1;
		bSendCommand(MSGID_SETTITLE, 0, 0, m_iTitleIndex, 0, 0, 0);
		AddEventList("Your title has been cleared.", 10);
	}
}

void helbreath::GetTitleName(char * cSubject, int iRank, char * pStr1)
{

	char cTxt[256];

	ZeroMemory(cTxt, sizeof(cTxt));

	if (memcmp(cSubject, "Events", 6) == 0)
	{
		//if(iNumber >   0 && iNumber < 10)	   strcpy(cTxt, "Events Lv.0");
		//if(iNumber >= 10 && iNumber < 25)      strcpy(cTxt, "Events Lv.1");
		//if(iNumber >= 25 && iNumber < 50)      strcpy(cTxt, "Events Lv.2");
		//if(iNumber >= 50 && iNumber < 100)     strcpy(cTxt, "Events Lv.3");
		//if(iNumber >= 100 && iNumber < 250)    strcpy(cTxt, "Events Lv.4");
		//if(iNumber >= 250 && iNumber < 500)    strcpy(cTxt, "Events Lv.5");
		//if(iNumber >= 500 && iNumber < 1000)   strcpy(cTxt, "Events Lv.6");
		//if(iNumber >= 1000 && iNumber < 2500)  strcpy(cTxt, "Events Lv.7");
		//if(iNumber >= 2500 && iNumber < 5000)  strcpy(cTxt, "Events Lv.8");
		//if(iNumber >= 5000)					   strcpy(cTxt, "Events Lv.9");

		fmt::format_to(cTxt, "Events Lv.%d", iRank);

		//if (iRank == 0) {		 strcpy(cTxt, "Events Lv.0");
		//} else if (iRank == 1) { strcpy(cTxt, "Events Lv.1");
		//} else if (iRank == 2) { strcpy(cTxt, "Events Lv.2");
		//} else if (iRank == 3) { strcpy(cTxt, "Events Lv.3");
		//} else if (iRank == 4) { strcpy(cTxt, "Events Lv.4");
		//} else if (iRank == 5) { strcpy(cTxt, "Events Lv.5");
		//} else if (iRank == 6) { strcpy(cTxt, "Events Lv.6");
		//} else if (iRank == 7) { strcpy(cTxt, "Events Lv.7");
		//} else if (iRank == 8) { strcpy(cTxt, "Events Lv.8");
		//} else if (iRank == 9) { strcpy(cTxt, "Events Lv.9");
		//} else if (iRank == 10) { strcpy(cTxt, "Events Lv.10");
		//}
	}
	else if (memcmp(cSubject, "Donation", 8) == 0)
	{
		/*	if(iNumber >= 1 && iNumber < 5)			strcpy(cTxt, "Penny Pincher");
			if(iNumber >= 5 && iNumber < 10)		strcpy(cTxt, "Spare Change");
			if(iNumber >= 10 && iNumber < 20)		strcpy(cTxt, "Bargain Hunter");
			if(iNumber >= 20 && iNumber < 50)		strcpy(cTxt, "Rich Kid");
			if(iNumber >= 50 && iNumber < 100)		strcpy(cTxt, "Money Bags");
			if(iNumber >= 100 && iNumber < 175)		strcpy(cTxt, "Big Spender");
			if(iNumber >= 175 && iNumber < 250)		strcpy(cTxt, "Filthy Rich");
			if(iNumber >= 250 && iNumber < 500)		strcpy(cTxt, "Bling Bling");
			if(iNumber >= 500)					    strcpy(cTxt, "Bling Bling");*/
			//if (iRank == 0) {		 strcpy(cTxt, "Penny Pincher Lv.%d");
			//} else if (iRank == 1) { strcpy(cTxt, "Spare Change Lv.%d");
			//} else if (iRank == 2) { strcpy(cTxt, "Bargain Hunter Lv.%d");
			//} else if (iRank == 3) { strcpy(cTxt, "Rich Kid");
			//} else if (iRank == 4) { strcpy(cTxt, "Money Bags");
			//} else if (iRank == 5) { strcpy(cTxt, "Big Spender");
			//} else if (iRank == 6) { strcpy(cTxt, "Filthy Rich");
			//} else if (iRank == 7) { strcpy(cTxt, "Bling Bling");
			//} else if (iRank == 8) { strcpy(cTxt, "Events Lv.8");
			//} else if (iRank == 9) { strcpy(cTxt, "Events Lv.9");
			//} else if (iRank == 10) { strcpy(cTxt, "Philanthropist Lv.%d");
			//}
		if ((iRank >= 0) && (iRank < 4)) fmt::format_to(cTxt, "Tipper Lv.%d", iRank);
		else if ((iRank >= 4) && (iRank < 6)) fmt::format_to(cTxt, "Patron Lv.%d", iRank);
		else if ((iRank >= 6) && (iRank < 8)) fmt::format_to(cTxt, "Sponsor Lv.%d", iRank);
		else if ((iRank >= 8) && (iRank < 9)) fmt::format_to(cTxt, "Benefactor Lv.%d", iRank);
		else if ((iRank >= 9)) fmt::format_to(cTxt, "Philanthropist Lv.%d", iRank);



	}
	else if (memcmp(cSubject, "Gladiator", 9) == 0)
	{
		//if(iNumber >  0 && iNumber < 3)			strcpy(cTxt, "Novice Gladiator");
		//if(iNumber >= 3 && iNumber < 5)			strcpy(cTxt, "Fierce Gladiator");
		//if(iNumber >= 5 && iNumber < 10)		strcpy(cTxt, "Mighty Gladiator");
		//if(iNumber >= 10 && iNumber < 25)		strcpy(cTxt, "Deadly Gladiator");
		//if(iNumber >= 25 && iNumber < 50)		strcpy(cTxt, "Terrifying Gladiator");
		//if(iNumber >= 50 && iNumber < 100)		strcpy(cTxt, "Conquering Gladiator");
		//if(iNumber >= 100 && iNumber < 250)		strcpy(cTxt, "King's Gladiator");
		//if(iNumber >= 250 && iNumber < 500)		strcpy(cTxt, "Emperor's Gladiator");
		//if(iNumber >= 500 && iNumber < 1000)	strcpy(cTxt, "Adept Gladiator");
		//if(iNumber >= 1000 && iNumber < 2500)	strcpy(cTxt, "Vanquishing Gladiator");
		//if(iNumber >= 2500 && iNumber < 5000)	strcpy(cTxt, "Legendary Gladiator");
		//if(iNumber >= 5000)						strcpy(cTxt, "Legendary Gladiator");

		if (iRank == 0)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 1)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 2)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 3)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 4)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 5)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 6)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 7)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 8)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank == 9)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
		else if (iRank >= 10)
		{
			fmt::format_to(cTxt, "Gladiator Lv.%d", iRank);
		}
	}
	else if (memcmp(cSubject, "Constructor", 11) == 0)
	{
		//if(iNumber >  0 && iNumber < 3)			strcpy(cTxt, "Beginner Constructor");
		//if(iNumber >= 3 && iNumber < 5)			strcpy(cTxt, "Novice Constructor");
		//if(iNumber >= 5 && iNumber < 10)		strcpy(cTxt, "Expert Constructor");
		//if(iNumber >= 10 && iNumber < 25)		strcpy(cTxt, "Adept Constructor");
		//if(iNumber >= 25 && iNumber < 50)		strcpy(cTxt, "Master Constructor");
		//if(iNumber >= 50 && iNumber < 100)		strcpy(cTxt, "Elite Constructor");
		//if(iNumber >= 100 && iNumber < 250)		strcpy(cTxt, "Grandmaster Constructor");
		//if(iNumber >= 250 && iNumber < 500)		strcpy(cTxt, "Supreme Constructor");
		//if(iNumber >= 500 && iNumber < 1000)	strcpy(cTxt, "Divine Constructor");
		//if(iNumber >= 1000 && iNumber < 2500)	strcpy(cTxt, "Godly Constructor");
		//if(iNumber >= 2500 && iNumber < 5000)	strcpy(cTxt, "Legendary Constructor");
		//if(iNumber >= 5000)						strcpy(cTxt, "Legendary Constructor");

		fmt::format_to(cTxt, "Constructor Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Hero", 4) == 0)
	{
		//if(iNumber > 0  && iNumber < 25)		strcpy(cTxt, "Novice Hero");
		//if(iNumber >= 25 && iNumber < 50)		strcpy(cTxt, "Fierce Hero");
		//if(iNumber >= 50 && iNumber < 150)		strcpy(cTxt, "Mighty Hero");
		//if(iNumber >= 150 && iNumber < 300)		strcpy(cTxt, "Deadly Hero");
		//if(iNumber >= 300 && iNumber < 500)		strcpy(cTxt, "Terrifying Hero");
		//if(iNumber >= 500 && iNumber < 1500)	strcpy(cTxt, "Conquering Hero");
		//if(iNumber >= 1500 && iNumber < 3000)	strcpy(cTxt, "King's Hero");
		//if(iNumber >= 3000 && iNumber < 5000)	strcpy(cTxt, "Emperor's Hero");
		//if(iNumber >= 5000 && iNumber < 7500)	strcpy(cTxt, "Adept Hero");
		//if(iNumber >= 7500 && iNumber < 10000)	strcpy(cTxt, "Vanquishing Hero");
		//if(iNumber >= 10000 && iNumber < 20000)	strcpy(cTxt, "Divine Hero");
		//if(iNumber >= 20000 && iNumber < 50000)	strcpy(cTxt, "Godly Hero");
		//if(iNumber >= 50000)					strcpy(cTxt, "Legendary Hero");
		fmt::format_to(cTxt, "Hero Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Treasure", 8) == 0)
	{
		//if(iNumber >  0 && iNumber < 10)		strcpy(cTxt, "Novice Treasure Hunter");
		//if(iNumber >= 10 && iNumber < 25)		strcpy(cTxt, "Expert Treasure Hunter");
		//if(iNumber >= 25 && iNumber < 50)		strcpy(cTxt, "Adept Treasure Hunter");
		//if(iNumber >= 50 && iNumber < 100)		strcpy(cTxt, "Master Treasure Hunter");
		//if(iNumber >= 100 && iNumber < 250)		strcpy(cTxt, "Elite Treasure Hunter");
		//if(iNumber >= 250 && iNumber < 500)		strcpy(cTxt, "Grandmaster Treasure Hunter");
		//if(iNumber >= 500 && iNumber < 1000)	strcpy(cTxt, "Supreme Treasure Hunter");
		//if(iNumber >= 1000 && iNumber < 2500)	strcpy(cTxt, "Divine Treasure Hunter");
		//if(iNumber >= 2500 && iNumber < 5000)	strcpy(cTxt, "Godly Treasure Hunter");
		//if(iNumber >= 5000 && iNumber < 10000)	strcpy(cTxt, "Legendary Treasure Hunter");
		//if(iNumber >= 10000)					strcpy(cTxt, "Legendary Treasure Hunter");
		fmt::format_to(cTxt, "Treasure Hunter Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Drunkard", 8) == 0)
	{
		//if(iNumber >= 0 && iNumber < 5)			 strcpy(cTxt, "T Total Drunkard");
		//if(iNumber >= 5 && iNumber <  10)		 strcpy(cTxt, "Sober Drunkard");
		//if(iNumber >= 10 && iNumber <   20)		 strcpy(cTxt, "Tipsy Drunkard");
		//if(iNumber >= 20 && iNumber <  40)		 strcpy(cTxt, "Buzzed Drunkard");
		//if(iNumber >= 40 && iNumber <  80)	     strcpy(cTxt, "Drunk Drunkard");
		//if(iNumber >= 80 && iNumber <  160)		 strcpy(cTxt, "Wasted Drunkard");
		//if(iNumber >= 160 && iNumber < 320)		 strcpy(cTxt, "Smashed Drunkard");
		//if(iNumber >= 320 && iNumber < 640)		 strcpy(cTxt, "Binge Drunkard");
		//if(iNumber >= 640 && iNumber < 1280)	 strcpy(cTxt, "Hammered Drunkard");
		//if(iNumber >= 1280 && iNumber < 2560)	 strcpy(cTxt, "Plastered Drunkard");
		//if(iNumber >= 2560 && iNumber < 5120)	 strcpy(cTxt, "Sloshed Drunkard");
		//if(iNumber >= 5120 && iNumber < 10240)	 strcpy(cTxt, "Legendary Drunkard");
		//if(iNumber >= 10240)					 strcpy(cTxt, "Legendary Drunkard");
		fmt::format_to(cTxt, "Drunkard Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "SweetTooth", 10) == 0)
	{
		//if(iNumber >= 0 && iNumber < 5)			 strcpy(cTxt, "Sweet Tooth");
		//if(iNumber >= 5 && iNumber <  10)		 strcpy(cTxt, "Beginner Sweet Tooth");
		//if(iNumber >= 10 && iNumber <   20)		 strcpy(cTxt, "Novice Sweet Tooth");
		//if(iNumber >= 20 && iNumber <  40)		 strcpy(cTxt, "Expert Sweet Tooth");
		//if(iNumber >= 40 && iNumber <  80)	     strcpy(cTxt, "Adept Sweet Tooth");
		//if(iNumber >= 80 && iNumber <  160)		 strcpy(cTxt, "Master Sweet Tooth");
		//if(iNumber >= 160 && iNumber < 320)		 strcpy(cTxt, "Elite Sweet Tooth");
		//if(iNumber >= 320 && iNumber < 640)		 strcpy(cTxt, "Grandmaster Sweet Tooth");
		//if(iNumber >= 640 && iNumber < 1280)	 strcpy(cTxt, "Supreme Sweet Tooth");
		//if(iNumber >= 1280 && iNumber < 2560)	 strcpy(cTxt, "Divine Sweet Tooth");
		//if(iNumber >= 2560 && iNumber < 5120)	 strcpy(cTxt, "Godly Sweet Tooth");
		//if(iNumber >= 5120 && iNumber < 10240)	 strcpy(cTxt, "Legendary Sweet Tooth");
		//if(iNumber >= 10240)					 strcpy(cTxt, "Legendary Sweet Tooth");
		fmt::format_to(cTxt, "SweetTooth Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Suicide", 7) == 0)
	{
		//if(iNumber >= 10 && iNumber < 25)		strcpy(cTxt, "Novice Lemming");
		//if(iNumber >= 25 && iNumber < 50)		strcpy(cTxt, "Expert Lemming");
		//if(iNumber >= 50 && iNumber < 100)		strcpy(cTxt, "Adept Lemming");
		//if(iNumber >= 100 && iNumber < 250)		strcpy(cTxt, "Master Lemming");
		//if(iNumber >= 250 && iNumber < 500)		strcpy(cTxt, "Elite Lemming");
		//if(iNumber >= 500 && iNumber < 1000)	strcpy(cTxt, "Grandmaster Lemming");
		//if(iNumber >= 1000 && iNumber < 1750)	strcpy(cTxt, "Supreme Lemming");
		//if(iNumber >= 1750 && iNumber < 2500)	strcpy(cTxt, "Divine Lemming");
		//if(iNumber >= 2500 && iNumber < 5000)	strcpy(cTxt, "Godly Lemming");
		//if(iNumber >= 5000 && iNumber < 10000)	strcpy(cTxt, "Legendary Lemming");
		//if(iNumber >= 10000)					strcpy(cTxt, "Legendary Lemming");
		fmt::format_to(cTxt, "Suicide Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Alchemy", 7) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Herbalist (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Herbalist (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Herbalist (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Herbalist (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Herbalist (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Herbalist (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Herbalist (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Herbalist (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Herbalist (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Herbalist (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Herbalist (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Herbalist (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Herbalist (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Herbalist (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Herbalist (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Herbalist (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Herbalist (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Herbalist (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Herbalist (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Herbalist (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Herbalist (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Herbalist (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Herbalist (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Herbalist (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Herbalist (Lvl.25)");*/
		fmt::format_to(cTxt, "Herbalist Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Gemcutting", 10) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Gemcutter (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Gemcutter (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Gemcutter (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Gemcutter (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Gemcutter (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Gemcutter (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Gemcutter (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Gemcutter (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Gemcutter (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Gemcutter (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Gemcutter (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Gemcutter (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Gemcutter (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Gemcutter (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Gemcutter (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Gemcutter (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Gemcutter (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Gemcutter (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Gemcutter (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Gemcutter (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Gemcutter (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Gemcutter (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Gemcutter (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Gemcutter (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Gemcutter (Lvl.25)");*/
		fmt::format_to(cTxt, "Gemcutter Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Mining", 6) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Miner (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Miner (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Miner (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Miner (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Miner (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Miner (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Miner (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Miner (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Miner (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Miner (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Miner (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Miner (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Miner (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Miner (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Miner (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Miner (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Miner (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Miner (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Miner (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Miner (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Miner (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Miner (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Miner (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Miner (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Miner (Lvl.25)");*/
		fmt::format_to(cTxt, "Miner Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Blacksmithing", 13) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Blacksmith (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Blacksmith (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Blacksmith (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Blacksmith (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Blacksmith (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Blacksmith (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Blacksmith (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Blacksmith (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Blacksmith (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Blacksmith (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Blacksmith (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Blacksmith (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Blacksmith (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Blacksmith (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Blacksmith (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Blacksmith (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Blacksmith (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Blacksmith (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Blacksmith (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Blacksmith (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Blacksmith (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Blacksmith (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Blacksmith (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Blacksmith (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Blacksmith (Lvl.25)");*/
		fmt::format_to(cTxt, "Blacksmith Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Fishing", 7) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Fisherman (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Fisherman (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Fisherman (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Fisherman (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Fisherman (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Fisherman (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Fisherman (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Fisherman (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Fisherman (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Fisherman (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Fisherman (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Fisherman (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Fisherman (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Fisherman (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Fisherman (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Fisherman (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Fisherman (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Fisherman (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Fisherman (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Fisherman (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Fisherman (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Fisherman (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Fisherman (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Fisherman (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Fisherman (Lvl.25)");*/
		fmt::format_to(cTxt, "Fisherman Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Farming", 7) == 0)
	{
		/*if(iRank >= 1 && iRank <=   1)			 strcat(cTxt, "Trainee Farmer (Lvl.1)");
		if(iRank >= 2 && iRank <=   2)			 strcat(cTxt, "Initiate Farmer (Lvl.2)");
		if(iRank >= 3 && iRank <    5)			 strcat(cTxt, "Beginner Farmer (Lvl.3)");
		if(iRank >= 5 && iRank <    8)           strcat(cTxt, "Apprentice Farmer (Lvl.4)");
		if(iRank >= 8 && iRank <   13)           strcat(cTxt, "Novice Farmer (Lvl.5)");
		if(iRank >= 13 && iRank <  21)			 strcat(cTxt, "Novice Farmer (Lvl.6)");
		if(iRank >= 21 && iRank <   34)          strcat(cTxt, "Novice Farmer (Lvl.7)");
		if(iRank >= 34 && iRank <   55)			 strcat(cTxt, "Novice Farmer (Lvl.8)");
		if(iRank >= 55 && iRank <   89)			 strcat(cTxt, "Novice Farmer (Lvl.9)");
		if(iRank >= 89 && iRank <   144)		 strcat(cTxt, "Experienced Farmer (Lvl.10)");
		if(iRank >= 144 && iRank <   233)		 strcat(cTxt, "Experienced Farmer (Lvl.11)");
		if(iRank >= 233 && iRank <   377)		 strcat(cTxt, "Experienced Farmer (Lvl.12)");
		if(iRank >= 377 && iRank <   610)		 strcat(cTxt, "Experienced Farmer (Lvl.13)");
		if(iRank >= 610 && iRank <   987)		 strcat(cTxt, "Experienced Farmer (Lvl.14)");
		if(iRank >= 987 && iRank <  1597)		 strcat(cTxt, "Master Farmer (Lvl.15)");
		if(iRank >= 1597 && iRank <  2584)		 strcat(cTxt, "Master Farmer (Lvl.16)");
		if(iRank >= 2584 && iRank <  4181)		 strcat(cTxt, "Master Farmer (Lvl.17)");
		if(iRank >= 4181 && iRank <  6765)		 strcat(cTxt, "Master Farmer (Lvl.18)");
		if(iRank >= 6765 && iRank < 10946)		 strcat(cTxt, "Master Farmer (Lvl.19)");
		if(iRank >= 10946 && iRank < 17711)		 strcat(cTxt, "Grandmaster Farmer (Lvl.20)");
		if(iRank >= 17711 && iRank < 28657)		 strcat(cTxt, "Supreme Farmer (Lvl.21)");
		if(iRank >= 28657 && iRank < 46368)		 strcat(cTxt, "Supreme Farmer (Lvl.22)");
		if(iRank >= 46368 && iRank < 75025)		 strcat(cTxt, "Supreme Farmer (Lvl.23)");
		if(iRank >= 75025 && iRank < 121393)	 strcat(cTxt, "Supreme Farmer (Lvl.24)");
		if(iRank >= 121393)						 strcat(cTxt, "Legendary Farmer (Lvl.25)");*/
		fmt::format_to(cTxt, "Farmer Lv.%d", iRank);
	}
	else if (memcmp(cSubject, "Abaddon", 7) == 0 || memcmp(cSubject, "Wyvern", 6) == 0
		|| memcmp(cSubject, "FireWyvern", 10) == 0)
	{
		strcpy(cTxt, cSubject);
		//if(iNumber >= 20 && iNumber <=   50)		 strcat(cTxt, " Lvl.1");
		//if(iNumber > 50 && iNumber <=   75)			 strcat(cTxt, " Lvl.2");
		//if(iNumber >  75 && iNumber <=  100)		 strcat(cTxt, " Lvl.3");
		//if(iNumber > 100 && iNumber <=  125)         strcat(cTxt, " Lvl.4");
		//if(iNumber > 125 && iNumber <=  175)         strcat(cTxt, " Lvl.5");
		//if(iNumber > 175 && iNumber <= 250)			 strcat(cTxt, " Lvl.6");
		//if(iNumber > 250 && iNumber <= 500)          strcat(cTxt, " Lvl.7");
		//if(iNumber > 500 && iNumber <= 1000)		 strcat(cTxt, " Lvl.8");
		//if(iNumber > 1000)							 strcat(cTxt, " Lvl.9");
		fmt::format_to(cTxt, "%s Slayer Lv.%d", cSubject, iRank);
	}
	else
	{
		strcpy(cTxt, cSubject);
		/*if(iRank >= 1000 && iRank < 5000)      fmt::format_to(cTxt, "Initiate %s Hunter", cSubject);
		if(iRank >= 5000 && iRank < 10000)     fmt::format_to(cTxt, "Initiate %s Hunter", cSubject);
		if(iRank >= 10000 && iRank < 20000)    fmt::format_to(cTxt, "Beginner %s Hunter", cSubject);
		if(iRank >= 20000 && iRank < 50000)    fmt::format_to(cTxt, "Novice %s Hunter", cSubject);
		if(iRank >= 50000 && iRank < 100000)   fmt::format_to(cTxt, "Experienced %s Hunter", cSubject);
		if(iRank >= 100000 && iRank < 250000)  fmt::format_to(cTxt, "Master %s Hunter", cSubject);
		if(iRank >= 250000 && iRank < 500000)  fmt::format_to(cTxt, "Grand Master %s Slayer", cSubject);
		if(iRank >= 500000 && iRank < 750000)  fmt::format_to(cTxt, "Supreme %s Slayer", cSubject);
		if(iRank >= 750000)					   fmt::format_to(cTxt, "Legendary %s Slayer", cSubject);*/
		fmt::format_to(cTxt, "%s Slayer Lv.%d", cSubject, iRank);
	}



	strcpy(pStr1, cTxt);
}

int helbreath::iGetNextTitle(char * cSubject, uint32_t iNumber)
{

	char cTxt[256];

	ZeroMemory(cTxt, sizeof(cTxt));

	if (memcmp(cSubject, "Events", 6) == 0)
	{
		if (iNumber > 0 && iNumber < 10)     return 10;
		if (iNumber >= 10 && iNumber < 25)      return 25;
		if (iNumber >= 25 && iNumber < 50)      return 50;
		if (iNumber >= 50 && iNumber < 100)     return 100;
		if (iNumber >= 100 && iNumber < 250)    return 250;
		if (iNumber >= 250 && iNumber < 500)    return 500;
		if (iNumber >= 500 && iNumber < 1000)   return 1000;
		if (iNumber >= 1000 && iNumber < 2500)  return 2500;
		if (iNumber >= 2500 && iNumber < 5000)  return 5000;
		if (iNumber >= 5000)					   return 9999;
	}
	else if (memcmp(cSubject, "Donation", 8) == 0)
	{
		if (iNumber > 0 && iNumber < 5)			return 5;
		if (iNumber >= 5 && iNumber < 10)		return 10;
		if (iNumber >= 10 && iNumber < 20)		return 20;
		if (iNumber >= 20 && iNumber < 50)		return 50;
		if (iNumber >= 50 && iNumber < 100)		return 100;
		if (iNumber >= 100 && iNumber < 175)		return 175;
		if (iNumber >= 175 && iNumber < 250)		return 250;
		if (iNumber >= 250 && iNumber < 500)		return 500;
		if (iNumber >= 500)					    return 999;
	}
	else if (memcmp(cSubject, "Hero", 4) == 0)
	{
		if (iNumber >= 0 && iNumber < 5)		return 5;
		if (iNumber >= 5 && iNumber < 25)		return 25;
		if (iNumber >= 25 && iNumber < 50)		return 50;
		if (iNumber >= 50 && iNumber < 150)		return 150;
		if (iNumber >= 150 && iNumber < 300)		return 300;
		if (iNumber >= 300 && iNumber < 500)		return 500;
		if (iNumber >= 500 && iNumber < 1500)	return 1500;
		if (iNumber >= 1500 && iNumber < 3000)	return 3000;
		if (iNumber >= 3000 && iNumber < 5000)	return 5000;
		if (iNumber >= 5000 && iNumber < 7500)	return 7500;
		if (iNumber >= 7500 && iNumber < 10000)	return 10000;
		if (iNumber >= 10000 && iNumber < 20000)	return 20000;
		if (iNumber >= 20000 && iNumber < 50000)	return 50000;
		if (iNumber >= 50000)					return 99999;
	}
	else if (memcmp(cSubject, "Gladiator", 9) == 0 || memcmp(cSubject, "Constructor", 11) == 0)
	{
		if (iNumber >= 0 && iNumber < 2)		 return 3;
		if (iNumber >= 2 && iNumber < 5)		 return 5;
		if (iNumber >= 5 && iNumber < 10)		 return 10;
		if (iNumber >= 10 && iNumber < 25)		 return 25;
		if (iNumber >= 25 && iNumber < 50)		 return 50;
		if (iNumber >= 50 && iNumber < 100)	 return 100;
		if (iNumber >= 100 && iNumber < 250)	 return 250;
		if (iNumber >= 250 && iNumber < 500)	 return 500;
		if (iNumber >= 500 && iNumber < 1000)	 return 1000;
		if (iNumber >= 1000 && iNumber < 2500)	 return 2500;
		if (iNumber >= 2500 && iNumber < 5000)	 return 5000;
		if (iNumber >= 5000)					     return 9999;
	}
	else if (memcmp(cSubject, "Treasure", 8) == 0)
	{
		if (iNumber > 0 && iNumber < 10)	 return 10;
		if (iNumber >= 10 && iNumber < 25)		 return 25;
		if (iNumber >= 25 && iNumber < 50)		 return 50;
		if (iNumber >= 50 && iNumber < 100)	 return 100;
		if (iNumber >= 100 && iNumber < 250)	 return 250;
		if (iNumber >= 250 && iNumber < 500)	 return 500;
		if (iNumber >= 500 && iNumber < 1000)	 return 1000;
		if (iNumber >= 1000 && iNumber < 2500)	 return 2500;
		if (iNumber >= 2500 && iNumber < 5000)	 return 5000;
		if (iNumber >= 5000)					     return 9999;
	}
	else if (memcmp(cSubject, "Drunkard", 8) == 0 || memcmp(cSubject, "SweetTooth", 10) == 0)
	{
		if (iNumber >= 0 && iNumber < 5)			 return 5;
		if (iNumber >= 5 && iNumber < 10)		 return 10;
		if (iNumber >= 10 && iNumber < 20)		 return 20;
		if (iNumber >= 20 && iNumber < 40)		 return 40;
		if (iNumber >= 40 && iNumber < 80)	     return 80;
		if (iNumber >= 80 && iNumber < 160)		 return 160;
		if (iNumber >= 160 && iNumber < 320)		 return 320;
		if (iNumber >= 320 && iNumber < 640)		 return 640;
		if (iNumber >= 640 && iNumber < 1280)	 return 1280;
		if (iNumber >= 1280 && iNumber < 2560)	 return 2560;
		if (iNumber >= 2560 && iNumber < 5120)	 return 5120;
		if (iNumber >= 5120 && iNumber < 10240)	 return 10240;
		if (iNumber >= 10240)					 return 10240;
	}
	else if (memcmp(cSubject, "Suicide", 7) == 0)
	{
		if (iNumber >= 0 && iNumber < 10)	     return 10;
		if (iNumber >= 10 && iNumber < 25)		 return 25;
		if (iNumber >= 25 && iNumber < 50)	     return 50;
		if (iNumber >= 50 && iNumber < 100)	 return 100;
		if (iNumber >= 100 && iNumber < 250)	 return 250;
		if (iNumber >= 250 && iNumber < 500)	 return 500;
		if (iNumber >= 500 && iNumber < 1000)	 return 1000;
		if (iNumber >= 1000 && iNumber < 1750)	 return 1750;
		if (iNumber >= 1750 && iNumber < 2500)	 return 2500;
		if (iNumber >= 2500 && iNumber < 5000)	 return 5000;
		if (iNumber >= 5000 && iNumber < 10000)	 return 10000;
		if (iNumber >= 10000)					 return 99999;
	}
	else if (memcmp(cSubject, "Herbalist", 9) == 0 || memcmp(cSubject, "Miner", 5) == 0 || memcmp(cSubject, "Crafting", 8) == 0 || memcmp(cSubject, "Smither", 7) == 0
		|| memcmp(cSubject, "Fisher", 6) == 0 || memcmp(cSubject, "Farmer", 6) == 0)
	{
		if (iNumber == 0)							 return 1;
		if (iNumber >= 1 && iNumber <= 1)			 return 2;
		if (iNumber >= 2 && iNumber <= 2)			 return 3;
		if (iNumber >= 3 && iNumber < 5)           return 5;
		if (iNumber >= 5 && iNumber < 8)           return 8;
		if (iNumber >= 8 && iNumber < 13)			 return 13;//besk rank 5?
		if (iNumber >= 13 && iNumber < 21)          return 21;
		if (iNumber >= 21 && iNumber < 34)			 return 34;
		if (iNumber >= 34 && iNumber < 55)			 return 55;
		if (iNumber >= 55 && iNumber < 89)			 return 89;
		if (iNumber >= 89 && iNumber < 144)		 return 144;//besk rank 10
		if (iNumber >= 144 && iNumber < 233)		 return 233;
		if (iNumber >= 233 && iNumber < 377)		 return 377;
		if (iNumber >= 377 && iNumber < 610)		 return 610;
		if (iNumber >= 610 && iNumber < 987)		 return 987;
		if (iNumber >= 987 && iNumber < 1597)		 return 1597;//besk rank 15
		if (iNumber >= 1597 && iNumber < 2584)		 return 2584;
		if (iNumber >= 2584 && iNumber < 4181)		 return 4181;
		if (iNumber >= 4181 && iNumber < 6765)		 return 6765;
		if (iNumber >= 6765 && iNumber < 10946)		 return 10946;
		if (iNumber >= 10946 && iNumber < 17711)		 return 17711;//besk rank 20
		if (iNumber >= 17711 && iNumber < 28657)		 return 28657;
		if (iNumber >= 28657 && iNumber < 46368)		 return 46368;
		if (iNumber >= 46368 && iNumber < 75025)		 return 75025;
		if (iNumber >= 75025 && iNumber < 121393)	 return 121393;
		if (iNumber >= 121393)						 return 999999;//besk rank 25
	}
	else if (memcmp(cSubject, "Abaddon", 7) == 0 || memcmp(cSubject, "Wyvern", 6) == 0
		|| memcmp(cSubject, "FireWyvern", 10) == 0)
	{
		if (iNumber >= 0 && iNumber <= 20)		     return 20;
		if (iNumber > 20 && iNumber <= 50)			 return 50;
		if (iNumber > 50 && iNumber <= 85)			 return 85;
		if (iNumber > 85 && iNumber <= 130)			 return 130;
		if (iNumber > 130 && iNumber <= 170)         return 170;
		if (iNumber > 170 && iNumber <= 235)         return 235;
		if (iNumber > 235 && iNumber <= 385)			 return 385;
		if (iNumber > 250 && iNumber <= 550)          return 550;
		if (iNumber > 550 && iNumber <= 1200)		 return 1200;
		if (iNumber > 1200)							 return 2500;
	}
	else
	{
		if (iNumber >= 1000 && iNumber < 5000)      return 5000;
		if (iNumber >= 5000 && iNumber < 10000)     return 10000;
		if (iNumber >= 10000 && iNumber < 20000)    return 20000;
		if (iNumber >= 20000 && iNumber < 50000)    return 50000;
		if (iNumber >= 50000 && iNumber < 100000)   return 100000;
		if (iNumber >= 100000 && iNumber < 175000)  return 175000;
		if (iNumber >= 175000 && iNumber < 275000)  return 275000;
		if (iNumber >= 275000 && iNumber < 550000) return 550000;
		if (iNumber >= 550000)					   return 750000;
	}



	return 999999;
}

void helbreath::ClearPlayerTitle(char * cName)
{
	int i;

	for (i = 0; i < MAXGUILDNAMES; i++)
	{

		if (memcmp(cName, m_stTitles[i].cCharName, 10) == 0)
		{
			strcpy(m_stTitles[i].cSubject, "NONE");
			ZeroMemory(m_stTitles[i].cCharName, sizeof(m_stTitles[i].cCharName));
			strcpy(m_stTitles[i].cCharName, "NONE");
		}
	}
}

int helbreath::getTitleIndexFromSubject(char * cSubject)
{
	if (strcmp(cSubject, "NONE") == 0)
	{
		return -1;
	}
	else if (strcmp(cSubject, "Slime") == 0)
	{
		return 0;
	}
	else if (strcmp(cSubject, "GiantAnt") == 0)
	{
		return 1;
	}
	else if (strcmp(cSubject, "Amphis") == 0)
	{
		return 2;
	}
	else if (strcmp(cSubject, "Orc") == 0)
	{
		return 3;
	}
	else if (strcmp(cSubject, "OrcMage") == 0)
	{
		return 4;
	}
	else if (strcmp(cSubject, "Zombie") == 0)
	{
		return 5;
	}
	else if (strcmp(cSubject, "Skeleton") == 0)
	{
		return 6;
	}
	else if (strcmp(cSubject, "Scorpion") == 0)
	{
		return 7;
	}
	else if (strcmp(cSubject, "ClayGolem") == 0)
	{
		return 8;
	}
	else if (strcmp(cSubject, "StoneGolem") == 0)
	{
		return 9;
	}
	else if (strcmp(cSubject, "Helhound") == 0)
	{
		return 10;
	}
	else if (strcmp(cSubject, "GiantFrog") == 0)
	{
		return 11;
	}
	else if (strcmp(cSubject, "Rudolf") == 0)
	{
		return 12;
	}
	else if (strcmp(cSubject, "Troll") == 0)
	{
		return 13;
	}
	else if (strcmp(cSubject, "Cyclops") == 0)
	{
		return 14;
	}
	else if (strcmp(cSubject, "IceGolem") == 0)
	{
		return 15;
	}
	else if (strcmp(cSubject, "Beholder") == 0)
	{
		return 16;
	}
	else if (strcmp(cSubject, "CannibalPlant") == 0)
	{
		return 17;
	}
	else if (strcmp(cSubject, "Ogre") == 0)
	{
		return 18;
	}
	else if (strcmp(cSubject, "DireBoar") == 0)
	{
		return 19;
	}
	else if (strcmp(cSubject, "Tentocle") == 0)
	{
		return 20;
	}
	else if (strcmp(cSubject, "GiantCrawfish") == 0)
	{
		return 21;
	}
	else if (strcmp(cSubject, "MountainGiant") == 0)
	{
		return 22;
	}
	else if (strcmp(cSubject, "GiantPlant") == 0)
	{
		return 23;
	}
	else if (strcmp(cSubject, "Liche") == 0)
	{
		return 24;
	}
	else if (strcmp(cSubject, "Stalker") == 0)
	{
		return 25;
	}
	else if (strcmp(cSubject, "Werewolf") == 0)
	{
		return 26;
	}
	else if (strcmp(cSubject, "DarkElf") == 0)
	{
		return 27;
	}
	else if (strcmp(cSubject, "Frost") == 0)
	{
		return 28;
	}
	else if (strcmp(cSubject, "ClawTurtle") == 0)
	{
		return 29;
	}
	else if (strcmp(cSubject, "Ettin") == 0)
	{
		return 30;
	}
	else if (strcmp(cSubject, "Demon") == 0)
	{
		return 31;
	}
	else if (strcmp(cSubject, "Unicorn") == 0)
	{
		return 32;
	}
	else if (strcmp(cSubject, "Gargoyle") == 0)
	{
		return 33;
	}
	else if (strcmp(cSubject, "GiantLizard") == 0)
	{
		return 34;
	}
	else if (strcmp(cSubject, "Lizie") == 0)
	{
		return 35;
	}
	else if (strcmp(cSubject, "Hellclaw") == 0)
	{
		return 36;
	}
	else if (strcmp(cSubject, "Tigerworm") == 0)
	{
		return 37;
	}
	else if (strcmp(cSubject, "Wyvern") == 0)
	{
		return 38;
	}
	else if (strcmp(cSubject, "FireWyvern") == 0)
	{
		return 39;
	}
	else if (strcmp(cSubject, "Abbadon") == 0)
	{
		return 40;
	}
	else if (strcmp(cSubject, "Centaurus") == 0)
	{
		return 41;
	}
	else if (strcmp(cSubject, "MasterMageOrc") == 0)
	{
		return 42;
	}
	else if (strcmp(cSubject, "Minotaur") == 0)
	{
		return 43;
	}
	else if (strcmp(cSubject, "Mining") == 0)
	{
		return 44;
	}
	else if (strcmp(cSubject, "Fishing") == 0)
	{
		return 45;
	}
	else if (strcmp(cSubject, "Farming") == 0)
	{
		return 46;
	}
	else if (strcmp(cSubject, "Alchemy") == 0)
	{
		return 47;
	}
	else if (strcmp(cSubject, "Blacksmithing") == 0)
	{
		return 48;
	}
	else if (strcmp(cSubject, "Gemcutting") == 0)
	{
		return 49;
	} /*else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	} else if (strcmp(cSubject, "xxxxxxxxx") == 0) {
		return 0000000;
	}


	*/
	return -1;


}
#endif

void helbreath::_LoadItemContents()
{
	char cFileName[255], cTemp[255];
	HANDLE hFile;
	FILE * pFile;
	uint32_t  dwFileSize;
	char * pBuffer;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cFileName, sizeof(cFileName));
	strcat(cFileName, "data\\shops\\ItemConfigs\\ItemConfig1.txt");

	hFile = CreateFileA(cFileName, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFileName, "rt");
	if (pFile == 0) return;
	else
	{
		pBuffer = new char[dwFileSize + 1];
		ZeroMemory(pBuffer, dwFileSize + 1);
		fread(pBuffer, dwFileSize, 1, pFile);

		__bDecodeContentsAndBuildItemList(pBuffer);
		isItemLoaded = true;
		delete[] pBuffer;
	}
	fclose(pFile);
}

bool helbreath::__bDecodeContentsAndBuildItemList(char * pBuffer)
{
	char * pContents, * token;
	char seps[] = "= ,\t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemListIndex = 0;
	class CStrTok * pStrTok;

	pContents = pBuffer;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != 0)
	{
		if (cReadModeA != 0)
		{
			//
			switch (cReadModeA)
			{
				case 1:
					switch (cReadModeB)
					{
						case 1:
							m_pBuildItemListStats[iItemListIndex]->ItemUniqueID = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							ZeroMemory(m_pBuildItemListStats[iItemListIndex]->m_cName, sizeof(m_pBuildItemListStats[iItemListIndex]->m_cName));
							memcpy(m_pBuildItemListStats[iItemListIndex]->m_cName, token, strlen(token));
							cReadModeB = 3;
							break;
						case 3:	// m_cItemType
							m_pBuildItemListStats[iItemListIndex]->m_cItemType = atoi(token);
							cReadModeB = 4;
							break;
						case 4: // m_cEquipPos
							m_pBuildItemListStats[iItemListIndex]->m_cEquipPos = atoi(token);
							cReadModeB = 5;
							break;
						case 5: // m_sItemEffectType
							//m_pBuildItemListStats[iItemListIndex]->m_sItemEffectType = atoi(token);
							cReadModeB = 6;
							break;
						case 6:	// m_sItemEffectValue1
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue1 = atoi(token);
							cReadModeB = 7;
							break;
						case 7: // m_sItemEffectValue2
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue2 = atoi(token);
							cReadModeB = 8;
							break;
						case 8: // m_sItemEffectValue3
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue3 = atoi(token);
							cReadModeB = 9;
							break;
						case 9: // m_sItemEffectValue4
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue4 = atoi(token);
							cReadModeB = 10;
							break;
						case 10: // m_sItemEffectValue5
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue5 = atoi(token);
							cReadModeB = 11;
							break;
						case 11: // m_sItemEffectValue6
							m_pBuildItemListStats[iItemListIndex]->m_sItemEffectValue6 = atoi(token);
							cReadModeB = 12;
							break;
						case 12: // m_wMaxLifeSpan
							m_pBuildItemListStats[iItemListIndex]->m_wMaxLifeSpan = (uint16_t)atoi(token);
							cReadModeB = 13;
							break;
						case 13: // m_sMaxFixCount
							//m_pBuildItemListStats[iItemListIndex]->m_sMaxFixCount = atoi(token);
							cReadModeB = 14;
							break;
						case 14: // m_sSprite
							m_pBuildItemListStats[iItemListIndex]->m_sSprite = atoi(token);
							cReadModeB = 15;
							break;
						case 15: // m_sSpriteFrame
							m_pBuildItemListStats[iItemListIndex]->m_sSpriteFrame = atoi(token);
							cReadModeB = 16;
							break;
						case 16: // m_wPrice
							m_pBuildItemListStats[iItemListIndex]->m_wPrice = atoi(token);
							cReadModeB = 17;
							break;
						case 17: // m_wWeight
							m_pBuildItemListStats[iItemListIndex]->m_wWeight = atoi(token);
							cReadModeB = 18;
							break;
						case 18: // Appr Value
							//m_pBuildItemListStats[iItemListIndex]->m_cApprValue = atoi(token);
							cReadModeB = 19;
							break;
						case 19: // m_cSpeed
							m_pBuildItemListStats[iItemListIndex]->m_cSpeed = atoi(token);
							cReadModeB = 20;
							break;
						case 20: // Level Limit
							m_pBuildItemListStats[iItemListIndex]->m_sLevelLimit = atoi(token);
							m_pBuildItemListStats[iItemListIndex]->m_dwCount = 1;
							cReadModeA = 0;
							cReadModeB = 0;
							iItemListIndex++;
							break;
					}
					break;

				default:
					break;
			}
		}
		else
		{
			if (memcmp(token, "ItemForSale", 4) == 0)
			{
				if (iItemListIndex >= MAXITEMSTATS)
				{
					delete pStrTok;
					return false;
				}
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemListStats[iItemListIndex] = new class CItem;
			}
		}
		token = pStrTok->pGet();
	}
	delete pStrTok;
	if ((cReadModeA != 0) || (cReadModeB != 0)) return false;
	return true;
}

void helbreath::isValue(uint32_t value)
{
	if (value < 30)
	{
		isCommon = true;
		m_itemColor = Color(255, 255, 255, 255);
		isUncommon = isRare = isEpic = isLegendary = false;
	}
	else if ((value >= 30) && (value < 60))
	{
		isUncommon = true;
		m_itemColor = Color(255, 0, 200, 0);
		isCommon = isRare = isEpic = isLegendary = false;
	}
	else if ((value >= 60) && (value < 80))
	{
		isRare = true;
		m_itemColor = Color(255, 0, 0, 200);
		isCommon = isUncommon = isEpic = isLegendary = false;
	}
	else if ((value >= 80) && (value < 100))
	{
		isEpic = true;
		m_itemColor = Color(255, 225, 191, 0);
		isCommon = isUncommon = isRare = isLegendary = false;
	}
	else if ((value >= 100))
	{
		isLegendary = true;
		m_itemColor = Color(255, 225, 132, 0);
		isCommon = isUncommon = isRare = isEpic = false;
	}
}

void helbreath::HandleItemDescription(CItem * item)
{
	if (strcmp(item->m_cName, "RingofOgrepower") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 40);
	}
	else if (strcmp(item->m_cName, "RingofDemonpower") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 50);
	}
	else if (strcmp(item->m_cName, "RingofDragonpower") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 60);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "RingoftheXelima") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 70);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "RingoftheAbaddon") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 100);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "RingofWizard") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICDAMAGE, 5);
	}
	else if (strcmp(item->m_cName, "RingofMage") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICDAMAGE, 10);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "RingofGrandMage") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICDAMAGE, 15);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "RingofArchmage") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICDAMAGE, 20);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfMerien") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DEFENSE, 500);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "MerienShield") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MERIENSHIELD, 60);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "MerienPlateMailM") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MERIENARMOR, 60);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "MerienPlateMailW") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MERIENARMOR, 60);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "MagicWand(M.Shield)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MSHIELDWAND, 14);
	}
	else if (strcmp(item->m_cName, "NecklaceOfKloness") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_REPDAMAGE, 1, 100);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "KlonessWand(MS.20)") == 0 || strcmp(item->m_cName, "KlonessWand(MS.10)") == 0 || strcmp(item->m_cName, "KlonessEsterk") == 0
		|| strcmp(item->m_cName, "KlonessBlade") == 0 || strcmp(item->m_cName, "KlonessAxe") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_REPDAMAGE, 1, 100);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfXelima") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_XELIMANECK, 160);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "XelimaBlade") == 0 || strcmp(item->m_cName, "XelimaAxe") == 0 || strcmp(item->m_cName, "XelimaRapier") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_XELIMAWEAPON, 50);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "Excaliber") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_EXCALIBER);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "DarkElfBow") == 0)
	{
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfLightPro") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_AIRABSORBNECK, 25);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfAirEle") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_AIRABSORBNECK, 50);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfFirePro") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FIREABSORBNECK, 25);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfEfreet") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FIREABSORBNECK, 50);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfIcePro") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ICEABSORBNECK1, 25, 50);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfIceEle") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ICEABSORBNECK2, 50);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfPoisonPro") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_POISONABSORBNECK1, 50);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfSufferent") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_POISONABSORBNECK2, 100);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfBeholder") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_NECKOFBEHOLDER);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "NecklaceOfLiche") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICSAVE, 35);
		m_itemColor = Color(255, 190, 119, 119);
	}
	else if (strcmp(item->m_cName, "NecklaceOfStoneGol") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DEFENSE, 400);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "RingoftheXelima") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MELEEDAMAGE, 75);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "SwordofMedusa") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MEDUSASWORD, 60);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "SwordofIceElemental") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ICEELESWORD);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "DemonSlayer") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DEMONSLAYER);
		m_itemColor = Color(255, 150, 0, 0);
	}
	else if (strcmp(item->m_cName, "StormBringer") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_STORMBRINGER);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "DarkExecutor") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DARKEXECUTOR);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "LightingBlade") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_LIGHTINGBLADE);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "BerserkWand(MS.20)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ZERKWAND, 30);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "BerserkWand(MS.10)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ZERKWAND, 30);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "ResurWand(MS.20)") == 0 || strcmp(item->m_cName, "ResurWand(MS.10)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_REZZWAND, 100, 100);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "LegendWand(MS25)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_LEGENDWAND, 10);
	}
	else if (strcmp(item->m_cName, "CritPot") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_CRITPOT, 200);
	}
	else if (strcmp(item->m_cName, "RedPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HPPOTION, 15, 30);
	}
	else if (strcmp(item->m_cName, "BigRedPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HPPOTION, 40, 60);
	}
	else if (strcmp(item->m_cName, "BluePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MPPOTION, 15, 30);
	}
	else if (strcmp(item->m_cName, "BigBluePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MPPOTION, 40, 60);
	}
	else if (strcmp(item->m_cName, "GreenPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SPPOTION, 15, 30);
	}
	else if (strcmp(item->m_cName, "BigGreenPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SPPOTION, 40, 50);
	}
	else if (strcmp(item->m_cName, "DilutionPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DELUTIONPOTION, 20);
	}
	else if (strcmp(item->m_cName, "Baguette") == 0 || strcmp(item->m_cName, "Meat") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FOOD, 20, 30, 5);
	}
	else if (strcmp(item->m_cName, "ArcheryManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ARCHERYMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "ShieldManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SHIELDMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "LongSwordManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_LONGSWORDMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "FencingManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FENCINGMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "FishingManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FISHINGMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "AxeManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_AXEMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "MagicResistManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAGICRESISTMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "RecallScroll") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_RECALLSCROLL);
	}
	else if (strcmp(item->m_cName, "InvisibilityScroll") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_INVISSCROLL);
	}
	else if (strcmp(item->m_cName, "DetectInviScroll") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DETECTINVISSCROLL);
	}
	else if (strcmp(item->m_cName, "GuildAdmissionTicket") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GUILDADMISSION);
	}
	else if (strcmp(item->m_cName, "GuildSucessionTicket") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GUILDWITHDRAWAL);
	}
	else if (strcmp(item->m_cName, "FlowerBasket") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BASKETFLOWERS);
	}
	else if (strcmp(item->m_cName, "Flowerpot") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_POTFLOWERS);
	}
	else if (strcmp(item->m_cName, "Map") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MAP);
	}
	else if (strcmp(item->m_cName, "FishingRod") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FISHINGROD);
	}
	else if (strcmp(item->m_cName, "PretendCorpseManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_PRETENDCORPSEMANUAL, 20);
	}
	else if (strncmp(item->m_cName, "ArenaTicket", 11) == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ARENATICKETS);
	}
	else if (strcmp(item->m_cName, "AlchemyBowl") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ALCHEMYBOWL);
	}
	else if (strcmp(item->m_cName, "PickAxe") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_PICKAXE);
	}
	else if (strcmp(item->m_cName, "Hoe") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HOE);
	}
	else if (strcmp(item->m_cName, "ManufacturingHammer") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SMITHSANVIL);
	}
	else if (strcmp(item->m_cName, "HammerAttackManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAMMERATTACKMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "AresdenFlag(Master)") == 0 || strcmp(item->m_cName, "ElvineFlag(Master)") == 0 || strcmp(item->m_cName, "AresdenFlag") == 0
		|| strcmp(item->m_cName, "ElvineFlag") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_EVENTITEM);
	}
	else if (strcmp(item->m_cName, "StaffAttackManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_STAFFATTACKMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "HairColorPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAIRCOLORPOTION);
	}
	else if (strcmp(item->m_cName, "HairStylePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAIRSTYLEPOTION);
	}
	else if (strcmp(item->m_cName, "SkinColorPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SKINCOLORPOTION);
	}
	else if (strcmp(item->m_cName, "InvisibilityPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_INVISPOTION);
	}
	else if (strcmp(item->m_cName, "SexChangePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SEXCHANGEPOTION);
	}
	else if (strcmp(item->m_cName, "OgrePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_OGREPOTION);
	}
	else if (strcmp(item->m_cName, "UnderWearPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_UNDERWEARPOTION);
	}
	else if (strncmp(item->m_cName, "Dye", 3) == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_CLOTHINGDYE);
	}
	else if (strcmp(item->m_cName, "DecolorationPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DECOLORATIONPOTION);
	}
	else if (strcmp(item->m_cName, "HandAttackManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HANDATTACKMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "ShortSwordManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SHORTSWORDMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "PowerGreenPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_POWERGREENPOTION, 15);
	}
	else if (strcmp(item->m_cName, "SuperGreenPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_POWERGREENPOTION, 30);
	}
	else if (strcmp(item->m_cName, "BloodSword") == 0 || strcmp(item->m_cName, "BloodAxe") == 0 || strcmp(item->m_cName, "BloodRapier") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BLOODWEAPON, 20);
		m_itemColor = Color(255, 125, 0, 0);
	}
	else if (strcmp(item->m_cName, "StoneOfXelima") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_XELIMASTONE);
	}
	else if (strcmp(item->m_cName, "StoneOfMerien") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MERIENSTONE);
	}
	else if (strcmp(item->m_cName, "UnfreezePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_UNFREEZEPOTION);
	}
	else if (strncmp(item->m_cName, "SeedBag", 7) == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SEEDBAG);
	}
	else if (strcmp(item->m_cName, "SuperRedPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HPPOTION, 503, 524);
	}
	else if (strcmp(item->m_cName, "SuperBluePotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MPPOTION, 503, 524);
	}
	else if (strcmp(item->m_cName, "SuperGreenPotion") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SPPOTION, 504, 532);
	}
	else if (strstr(item->m_cName, "ResetScroll") != 0 && strcmp(item->m_cName, "ResetScroll(ALL)") != 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_RESETSCROLL);
	}
	else if (strcmp(item->m_cName, "ResetScroll(ALL)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_RESETSCROLLALL);
	}
	else if (strcmp(item->m_cName, "AlchemyManual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ALCHEMYMANUAL, 20);
	}
	else if (strcmp(item->m_cName, "MsRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MSRUNE);
	}
	else if (strcmp(item->m_cName, "DmgRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DMGRUNE);
	}
	else if (strcmp(item->m_cName, "DefRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DEFRUNE);
	}
	else if (strcmp(item->m_cName, "MrRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MRRUNE);
	}
	else if (strcmp(item->m_cName, "DiaRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_DIARUNE);
	}
	else if (strcmp(item->m_cName, "RubyRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_RUBYRUNE);
	}
	else if (strcmp(item->m_cName, "EmeRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_EMERUNE);
	}
	else if (strcmp(item->m_cName, "SapRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SAPRUNE);
	}
	else if (strcmp(item->m_cName, "MasterDefRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASTERDEFRUNE);
	}
	else if (strcmp(item->m_cName, "MasterMrRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASTERMRRUNE);
	}
	else if (strcmp(item->m_cName, "MasterDmgRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASTERDMGRUNE);
	}
	else if (strcmp(item->m_cName, "MasterMsRune") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASTERMSRUNE);
	}

	if (strcmp(item->m_cName, "RingOfWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_WISDOM, 50);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "NeckOfWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_WISDOM, 50);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "RingOfGWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATERWISDOM, 100);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NeckOfGWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATERWISDOM, 100);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "RingOfAncWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ANCIENTWISDOM, 150);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "NeckOfAncWis") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ANCIENTWISDOM, 150);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "RingOfReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_REGENRATION, 20);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "NeckOfReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_REGENRATION, 25);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "RingOfGReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATERREGENRATION, 45);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "NeckOfGReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATERREGENRATION, 55);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "RingOfAncReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ANCIENTREGENRATION, 105);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "NeckOfAncReg") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ANCIENTREGENRATION, 125);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "WandOfWitch") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_WANDOFWITCH, 12);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "WandOfGWitch") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_WANDOFGWITCH, 14);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "WandOfAncWitch") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_WANDOFANCWITCH, 18);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "HamOfWrathran") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAMOFWRATHRAN);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "HamOfGWrathran") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAMOFWRATHRAN);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "HamOfAncWrathran") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_HAMOFWRATHRAN);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "G.Zerk.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GZERKMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "A.Zerk.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_AZERKMANUAL);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "Scan.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SCANMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "I.S.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ISMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "B.S.W.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BSWMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "M.H.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MHMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "M.S.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MSMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "C.O.T.G.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_COTGMANUAL);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "S.O.T.G.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_SOTGMANUAL);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "M.B.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MBMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "F.S.W.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FSWMANUAL);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "L.C.Manual") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_LCMANUAL);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "Greater(M.Shield)") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATERMSHIELD, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "MagicMissleBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ENERGYSTRIKEBS, 22);
		m_itemColor = Color(255, 255, 255, 255);
	}
	else if (strcmp(item->m_cName, "EnergyBoltBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ENERGYBOLTBS, 22);
		m_itemColor = Color(255, 255, 255, 255);
	}
	else if (strcmp(item->m_cName, "FireBallBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FIREBALLBS, 22);
		m_itemColor = Color(255, 255, 255, 255);
	}
	else if (strcmp(item->m_cName, "GreatHealBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATHEALBS, 22);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "FireStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_FIRESTRIKEBS, 22);
		m_itemColor = Color(255, 255, 255, 255);
	}
	else if (strcmp(item->m_cName, "TriEnergyBoltBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_TRIPLEENERGYBOLTBS, 22);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "ChillWindBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_CHILLWINDBS, 22);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "BerserkBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BERSERKBS, 22);
		m_itemColor = Color(255, 0, 0, 200);
	}
	else if (strcmp(item->m_cName, "IceStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ICESTRIKEBS, 22);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "EnergyStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ENERGYSTRIKEBS, 22);
		m_itemColor = Color(255, 0, 200, 0);
	}
	else if (strcmp(item->m_cName, "M.ChillWindBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASSCHILLWINDBS, 22);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "ArmorBreakBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ARMORBREAKBS, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "G.BerserkBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_GREATBERSERKBS, 22);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "M.IceStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASSICESTRIKEBS, 22);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "A.BerserkBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_ANCIENTBERSERKBS, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "LightStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_LIGHTNINGSTRIKEBS, 22);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "MeteorStrikeBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_METEORSTRIKEBS, 22);
		m_itemColor = Color(255, 225, 191, 0);
	}
	else if (strcmp(item->m_cName, "MassHealBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_MASSHEALBS, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "BlizzardBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BLIZZARDBS, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}
	else if (strcmp(item->m_cName, "E.S.WBS") == 0)
	{
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_EARTHSHOCKWAVEBS, 22);
		m_itemColor = Color(255, 225, 132, 0);
	}/*else if(strcmp(item->m_cName, "BS") == 0){
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BS, 22);
		m_itemColor =Color(255,225,132,0);
	}else if(strcmp(item->m_cName, "BS") == 0){
		fmt::format_to(G_cTxt, ITEM_DESCRIPTION_BS, 22);
		m_itemColor =Color(255,225,132,0);
	}*/

	// String search classification
	if (strstr(item->m_cName, "Manual") != 0)
	{
		m_itemColor = Color(255, 150, 241, 255);
	}
	else if (strstr(item->m_cName, "Potion") != 0)
	{
		m_itemColor = Color(255, 0, 186, 255);
	}
	else if (strstr(item->m_cName, "Rune") != 0)
	{
		if (strstr(item->m_cName, "Master") != 0)
		{
			m_itemColor = Color(255, 225, 132, 0);
		}
		else
		{
			m_itemColor = Color(255, 225, 191, 0);
		}
	}

	int iValue = 0;
	char STAT[5];
	ZeroMemory(STAT, sizeof(STAT));
	if ((memcmp(item->m_cName, "AngelicPendant(STR)", 19) == 0) || (memcmp(item->m_cName, "AngelicPendant(DEX)", 19) == 0)
		|| (memcmp(item->m_cName, "AngelicPendant(INT)", 19) == 0) || (memcmp(item->m_cName, "AngelicPendant(MAG)", 19) == 0))
	{
		iValue = (item->m_dwAttribute & 0xF0000000) >> 28;
		if (memcmp(item->m_cName, "AngelicPendant(STR)", 19) == 0)
		{
			strcpy(STAT, "STR");
		}
		else if (memcmp(item->m_cName, "AngelicPendant(DEX)", 19) == 0)
		{
			strcpy(STAT, "DEX");
		}
		else if (memcmp(item->m_cName, "AngelicPendant(INT)", 19) == 0)
		{
			strcpy(STAT, "INT");
		}
		else if (memcmp(item->m_cName, "AngelicPendant(MAG)", 19) == 0)
		{
			strcpy(STAT, "MAG");
		}

		switch (iValue)
		{
			case 0:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 1:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 2:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 3:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 4:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 5:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 6:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 7:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 8:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 9:	fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 10: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 11: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 12: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 13: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 14: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
			case 15: fmt::format_to(G_cTxt, "+%i %s", 12 * iValue, STAT); break;
		}
	}
}

// Beholder Necklace Fix xRisenx
bool helbreath::bCheckItemEquiped(const char itemName[])
{
	for (int i = 0; i < MAXITEMS; i++)
	{
		if (m_pItemList[i] != 0)
		{
			if (strcmp(m_pItemList[i]->m_cName, itemName) == 0)
			{
				for (int x = 0; x < MAXITEMEQUIPPOS; x++)
				{
					if (m_sItemEquipmentStatus[x] == i)
						return true;
				}
			}
		}
	}
	return false;
}

